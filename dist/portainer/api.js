"use strict";
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * PortainerCE API
 * Portainer API is an HTTP API served by Portainer. It is used by the Portainer UI and everything you can do with the UI can be done using the HTTP API. Examples are available at https://documentation.portainer.io/api/api-examples/ You can find out more about Portainer at [http://portainer.io](http://portainer.io) and get some support on [Slack](http://portainer.io/slack/).  # Authentication  Most of the API environments(endpoints) require to be authenticated as well as some level of authorization to be used. Portainer API uses JSON Web Token to manage authentication and thus requires you to provide a token in the **Authorization** header of each request with the **Bearer** authentication mechanism.  Example:  ``` Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiIsInJvbGUiOjEsImV4cCI6MTQ5OTM3NjE1NH0.NJ6vE8FY1WG6jsRQzfMqeatJ4vh2TWAeeYfDhP71YEE ```  # Security  Each API environment(endpoint) has an associated access policy, it is documented in the description of each environment(endpoint).  Different access policies are available:  - Public access - Authenticated access - Restricted access - Administrator access  ### Public access  No authentication is required to access the environments(endpoints) with this access policy.  ### Authenticated access  Authentication is required to access the environments(endpoints) with this access policy.  ### Restricted access  Authentication is required to access the environments(endpoints) with this access policy. Extra-checks might be added to ensure access to the resource is granted. Returned data might also be filtered.  ### Administrator access  Authentication as well as an administrator role are required to access the environments(endpoints) with this access policy.  # Execute Docker requests  Portainer **DO NOT** expose specific environments(endpoints) to manage your Docker resources (create a container, remove a volume, etc...).  Instead, it acts as a reverse-proxy to the Docker HTTP API. This means that you can execute Docker requests **via** the Portainer HTTP API.  To do so, you can use the `/endpoints/{id}/docker` Portainer API environment(endpoint) (which is not documented below due to Swagger limitations). This environment(endpoint) has a restricted access policy so you still need to be authenticated to be able to query this environment(endpoint). Any query on this environment(endpoint) will be proxied to the Docker API of the associated environment(endpoint) (requests and responses objects are the same as documented in the Docker API).  # Private Registry  Using private registry, you will need to pass a based64 encoded JSON string ‘{\"registryId\":\\<registryID value\\>}’ inside the Request Header. The parameter name is \"X-Registry-Auth\". \\<registryID value\\> - The registry ID where the repository was created.  Example:  ``` eyJyZWdpc3RyeUlkIjoxfQ== ```  **NOTE**: You can find more information on how to query the Docker API in the [Docker official documentation](https://docs.docker.com/engine/api/v1.30/) as well as in [this Portainer example](https://documentation.portainer.io/api/api-examples/).
 *
 * OpenAPI spec version: 2.20.3
 * Contact: info@portainer.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitopsApiFetchParamCreator = exports.EndpointsApi = exports.EndpointsApiFactory = exports.EndpointsApiFp = exports.EndpointsApiFetchParamCreator = exports.EndpointGroupsApi = exports.EndpointGroupsApiFactory = exports.EndpointGroupsApiFp = exports.EndpointGroupsApiFetchParamCreator = exports.EdgeTemplatesApi = exports.EdgeTemplatesApiFactory = exports.EdgeTemplatesApiFp = exports.EdgeTemplatesApiFetchParamCreator = exports.EdgeStacksApi = exports.EdgeStacksApiFactory = exports.EdgeStacksApiFp = exports.EdgeStacksApiFetchParamCreator = exports.EdgeJobsApi = exports.EdgeJobsApiFactory = exports.EdgeJobsApiFp = exports.EdgeJobsApiFetchParamCreator = exports.EdgeGroupsApi = exports.EdgeGroupsApiFactory = exports.EdgeGroupsApiFp = exports.EdgeGroupsApiFetchParamCreator = exports.EdgeApi = exports.EdgeApiFactory = exports.EdgeApiFp = exports.EdgeApiFetchParamCreator = exports.DockerApi = exports.DockerApiFactory = exports.DockerApiFp = exports.DockerApiFetchParamCreator = exports.CustomTemplatesApi = exports.CustomTemplatesApiFactory = exports.CustomTemplatesApiFp = exports.CustomTemplatesApiFetchParamCreator = exports.BackupApi = exports.BackupApiFactory = exports.BackupApiFp = exports.BackupApiFetchParamCreator = exports.AuthApi = exports.AuthApiFactory = exports.AuthApiFp = exports.AuthApiFetchParamCreator = exports.UsersThemePayload = exports.PortainerUserThemeSettings = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = void 0;
exports.StacksApiFactory = exports.StacksApiFp = exports.StacksApiFetchParamCreator = exports.SslApi = exports.SslApiFactory = exports.SslApiFp = exports.SslApiFetchParamCreator = exports.SettingsApi = exports.SettingsApiFactory = exports.SettingsApiFp = exports.SettingsApiFetchParamCreator = exports.RolesApi = exports.RolesApiFactory = exports.RolesApiFp = exports.RolesApiFetchParamCreator = exports.ResourceControlsApi = exports.ResourceControlsApiFactory = exports.ResourceControlsApiFp = exports.ResourceControlsApiFetchParamCreator = exports.RegistriesApi = exports.RegistriesApiFactory = exports.RegistriesApiFp = exports.RegistriesApiFetchParamCreator = exports.RbacEnabledApi = exports.RbacEnabledApiFactory = exports.RbacEnabledApiFp = exports.RbacEnabledApiFetchParamCreator = exports.MotdApi = exports.MotdApiFactory = exports.MotdApiFp = exports.MotdApiFetchParamCreator = exports.LdapApi = exports.LdapApiFactory = exports.LdapApiFp = exports.LdapApiFetchParamCreator = exports.KubernetesApi = exports.KubernetesApiFactory = exports.KubernetesApiFp = exports.KubernetesApiFetchParamCreator = exports.IntelApi = exports.IntelApiFactory = exports.IntelApiFp = exports.IntelApiFetchParamCreator = exports.HelmApi = exports.HelmApiFactory = exports.HelmApiFp = exports.HelmApiFetchParamCreator = exports.GitopsApi = exports.GitopsApiFactory = exports.GitopsApiFp = void 0;
exports.WebsocketApi = exports.WebsocketApiFactory = exports.WebsocketApiFp = exports.WebsocketApiFetchParamCreator = exports.WebhooksApi = exports.WebhooksApiFactory = exports.WebhooksApiFp = exports.WebhooksApiFetchParamCreator = exports.UsersApi = exports.UsersApiFactory = exports.UsersApiFp = exports.UsersApiFetchParamCreator = exports.UploadApi = exports.UploadApiFactory = exports.UploadApiFp = exports.UploadApiFetchParamCreator = exports.TemplatesApi = exports.TemplatesApiFactory = exports.TemplatesApiFp = exports.TemplatesApiFetchParamCreator = exports.TeamsApi = exports.TeamsApiFactory = exports.TeamsApiFp = exports.TeamsApiFetchParamCreator = exports.TeamMembershipsApi = exports.TeamMembershipsApiFactory = exports.TeamMembershipsApiFp = exports.TeamMembershipsApiFetchParamCreator = exports.TagsApi = exports.TagsApiFactory = exports.TagsApiFp = exports.TagsApiFetchParamCreator = exports.SystemApi = exports.SystemApiFactory = exports.SystemApiFp = exports.SystemApiFetchParamCreator = exports.StatusApi = exports.StatusApiFactory = exports.StatusApiFp = exports.StatusApiFetchParamCreator = exports.StacksApi = void 0;
const url = __importStar(require("url"));
const portableFetch = __importStar(require("portable-fetch"));
const BASE_PATH = "http://localhost/api".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, fetch = portableFetch) {
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace PortainerUserThemeSettings
 */
var PortainerUserThemeSettings;
(function (PortainerUserThemeSettings) {
    /**
     * @export
     * @enum {string}
     */
    let ColorEnum;
    (function (ColorEnum) {
        ColorEnum[ColorEnum["Dark"] = 'dark'] = "Dark";
        ColorEnum[ColorEnum["Light"] = 'light'] = "Light";
        ColorEnum[ColorEnum["Highcontrast"] = 'highcontrast'] = "Highcontrast";
        ColorEnum[ColorEnum["Auto"] = 'auto'] = "Auto";
    })(ColorEnum = PortainerUserThemeSettings.ColorEnum || (PortainerUserThemeSettings.ColorEnum = {}));
})(PortainerUserThemeSettings || (exports.PortainerUserThemeSettings = PortainerUserThemeSettings = {}));
/**
 * @export
 * @namespace UsersThemePayload
 */
var UsersThemePayload;
(function (UsersThemePayload) {
    /**
     * @export
     * @enum {string}
     */
    let ColorEnum;
    (function (ColorEnum) {
        ColorEnum[ColorEnum["Dark"] = 'dark'] = "Dark";
        ColorEnum[ColorEnum["Light"] = 'light'] = "Light";
        ColorEnum[ColorEnum["Highcontrast"] = 'highcontrast'] = "Highcontrast";
        ColorEnum[ColorEnum["Auto"] = 'auto'] = "Auto";
    })(ColorEnum = UsersThemePayload.ColorEnum || (UsersThemePayload.ColorEnum = {}));
})(UsersThemePayload || (exports.UsersThemePayload = UsersThemePayload = {}));
/**
 * AuthApi - fetch parameter creator
 * @export
 */
const AuthApiFetchParamCreator = function (configuration) {
    return {
        /**
         * **Access policy**: public Use this environment(endpoint) to authenticate against Portainer using a username and password.
         * @summary Authenticate
         * @param {AuthAuthenticatePayload} body Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling authenticateUser.');
            }
            const localVarPath = `/auth`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("AuthAuthenticatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options = {}) {
            const localVarPath = `/auth/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Authenticate with OAuth
         * @param {AuthOauthPayload} body OAuth Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateOAuth(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling validateOAuth.');
            }
            const localVarPath = `/auth/oauth/validate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("AuthOauthPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AuthApiFetchParamCreator = AuthApiFetchParamCreator;
/**
 * AuthApi - functional programming interface
 * @export
 */
const AuthApiFp = function (configuration) {
    return {
        /**
         * **Access policy**: public Use this environment(endpoint) to authenticate against Portainer using a username and password.
         * @summary Authenticate
         * @param {AuthAuthenticatePayload} body Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser(body, options) {
            const localVarFetchArgs = (0, exports.AuthApiFetchParamCreator)(configuration).authenticateUser(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: public
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options) {
            const localVarFetchArgs = (0, exports.AuthApiFetchParamCreator)(configuration).logout(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: public
         * @summary Authenticate with OAuth
         * @param {AuthOauthPayload} body OAuth Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateOAuth(body, options) {
            const localVarFetchArgs = (0, exports.AuthApiFetchParamCreator)(configuration).validateOAuth(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.AuthApiFp = AuthApiFp;
/**
 * AuthApi - factory interface
 * @export
 */
const AuthApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * **Access policy**: public Use this environment(endpoint) to authenticate against Portainer using a username and password.
         * @summary Authenticate
         * @param {AuthAuthenticatePayload} body Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser(body, options) {
            return (0, exports.AuthApiFp)(configuration).authenticateUser(body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: public
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options) {
            return (0, exports.AuthApiFp)(configuration).logout(options)(fetch, basePath);
        },
        /**
         * **Access policy**: public
         * @summary Authenticate with OAuth
         * @param {AuthOauthPayload} body OAuth Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateOAuth(body, options) {
            return (0, exports.AuthApiFp)(configuration).validateOAuth(body, options)(fetch, basePath);
        },
    };
};
exports.AuthApiFactory = AuthApiFactory;
/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
class AuthApi extends BaseAPI {
    /**
     * **Access policy**: public Use this environment(endpoint) to authenticate against Portainer using a username and password.
     * @summary Authenticate
     * @param {AuthAuthenticatePayload} body Credentials used for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    authenticateUser(body, options) {
        return (0, exports.AuthApiFp)(this.configuration).authenticateUser(body, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: public
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    logout(options) {
        return (0, exports.AuthApiFp)(this.configuration).logout(options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: public
     * @summary Authenticate with OAuth
     * @param {AuthOauthPayload} body OAuth Credentials used for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    validateOAuth(body, options) {
        return (0, exports.AuthApiFp)(this.configuration).validateOAuth(body, options)(this.fetch, this.basePath);
    }
}
exports.AuthApi = AuthApi;
/**
 * BackupApi - fetch parameter creator
 * @export
 */
const BackupApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates an archive with a system data snapshot that could be used to restore the system. **Access policy**: admin
         * @summary Creates an archive with a system data snapshot that could be used to restore the system.
         * @param {BackupBackupPayload} [body] An object contains the password to encrypt the backup with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup(body, options = {}) {
            const localVarPath = `/backup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("BackupBackupPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers a system restore using provided backup file **Access policy**: public
         * @summary Triggers a system restore using provided backup file
         * @param {BackupRestorePayload} restorePayload Restore request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore(restorePayload, options = {}) {
            // verify required parameter 'restorePayload' is not null or undefined
            if (restorePayload === null || restorePayload === undefined) {
                throw new RequiredError('restorePayload', 'Required parameter restorePayload was null or undefined when calling restore.');
            }
            const localVarPath = `/restore`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("BackupRestorePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(restorePayload || {}) : (restorePayload || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.BackupApiFetchParamCreator = BackupApiFetchParamCreator;
/**
 * BackupApi - functional programming interface
 * @export
 */
const BackupApiFp = function (configuration) {
    return {
        /**
         * Creates an archive with a system data snapshot that could be used to restore the system. **Access policy**: admin
         * @summary Creates an archive with a system data snapshot that could be used to restore the system.
         * @param {BackupBackupPayload} [body] An object contains the password to encrypt the backup with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup(body, options) {
            const localVarFetchArgs = (0, exports.BackupApiFetchParamCreator)(configuration).backup(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Triggers a system restore using provided backup file **Access policy**: public
         * @summary Triggers a system restore using provided backup file
         * @param {BackupRestorePayload} restorePayload Restore request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore(restorePayload, options) {
            const localVarFetchArgs = (0, exports.BackupApiFetchParamCreator)(configuration).restore(restorePayload, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.BackupApiFp = BackupApiFp;
/**
 * BackupApi - factory interface
 * @export
 */
const BackupApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Creates an archive with a system data snapshot that could be used to restore the system. **Access policy**: admin
         * @summary Creates an archive with a system data snapshot that could be used to restore the system.
         * @param {BackupBackupPayload} [body] An object contains the password to encrypt the backup with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup(body, options) {
            return (0, exports.BackupApiFp)(configuration).backup(body, options)(fetch, basePath);
        },
        /**
         * Triggers a system restore using provided backup file **Access policy**: public
         * @summary Triggers a system restore using provided backup file
         * @param {BackupRestorePayload} restorePayload Restore request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore(restorePayload, options) {
            return (0, exports.BackupApiFp)(configuration).restore(restorePayload, options)(fetch, basePath);
        },
    };
};
exports.BackupApiFactory = BackupApiFactory;
/**
 * BackupApi - object-oriented interface
 * @export
 * @class BackupApi
 * @extends {BaseAPI}
 */
class BackupApi extends BaseAPI {
    /**
     * Creates an archive with a system data snapshot that could be used to restore the system. **Access policy**: admin
     * @summary Creates an archive with a system data snapshot that could be used to restore the system.
     * @param {BackupBackupPayload} [body] An object contains the password to encrypt the backup with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    backup(body, options) {
        return (0, exports.BackupApiFp)(this.configuration).backup(body, options)(this.fetch, this.basePath);
    }
    /**
     * Triggers a system restore using provided backup file **Access policy**: public
     * @summary Triggers a system restore using provided backup file
     * @param {BackupRestorePayload} restorePayload Restore request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    restore(restorePayload, options) {
        return (0, exports.BackupApiFp)(this.configuration).restore(restorePayload, options)(this.fetch, this.basePath);
    }
}
exports.BackupApi = BackupApi;
/**
 * CustomTemplatesApi - fetch parameter creator
 * @export
 */
const CustomTemplatesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {'string' | 'file' | 'repository'} method method for creating template
         * @param {any} body for body documentation see the relevant /custom_templates/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreate(method, body, options = {}) {
            // verify required parameter 'method' is not null or undefined
            if (method === null || method === undefined) {
                throw new RequiredError('method', 'Required parameter method was null or undefined when calling customTemplateCreate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling customTemplateCreate.');
            }
            const localVarPath = `/custom_templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {string} title Title of the template
         * @param {string} description Description of the template
         * @param {string} note A note that will be displayed in the UI. Supports HTML content
         * @param {number} platform Platform associated to the template (1 - &#39;linux&#39;, 2 - &#39;windows&#39;)
         * @param {number} type Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
         * @param {any} file File
         * @param {string} [logo] URL of the template&#39;s logo
         * @param {string} [variables] A json array of variables definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateFile(title, description, note, platform, type, file, logo, variables, options = {}) {
            // verify required parameter 'title' is not null or undefined
            if (title === null || title === undefined) {
                throw new RequiredError('title', 'Required parameter title was null or undefined when calling customTemplateCreateFile.');
            }
            // verify required parameter 'description' is not null or undefined
            if (description === null || description === undefined) {
                throw new RequiredError('description', 'Required parameter description was null or undefined when calling customTemplateCreateFile.');
            }
            // verify required parameter 'note' is not null or undefined
            if (note === null || note === undefined) {
                throw new RequiredError('note', 'Required parameter note was null or undefined when calling customTemplateCreateFile.');
            }
            // verify required parameter 'platform' is not null or undefined
            if (platform === null || platform === undefined) {
                throw new RequiredError('platform', 'Required parameter platform was null or undefined when calling customTemplateCreateFile.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type', 'Required parameter type was null or undefined when calling customTemplateCreateFile.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling customTemplateCreateFile.');
            }
            const localVarPath = `/custom_templates/create/file`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (title !== undefined) {
                localVarFormParams.set('Title', title);
            }
            if (description !== undefined) {
                localVarFormParams.set('Description', description);
            }
            if (note !== undefined) {
                localVarFormParams.set('Note', note);
            }
            if (platform !== undefined) {
                localVarFormParams.set('Platform', platform);
            }
            if (type !== undefined) {
                localVarFormParams.set('Type', type);
            }
            if (file !== undefined) {
                localVarFormParams.set('File', file);
            }
            if (logo !== undefined) {
                localVarFormParams.set('Logo', logo);
            }
            if (variables !== undefined) {
                localVarFormParams.set('Variables', variables);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromGitRepositoryPayload} body Required when using method&#x3D;repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateRepository(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling customTemplateCreateRepository.');
            }
            const localVarPath = `/custom_templates/create/repository`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("CustomtemplatesCustomTemplateFromGitRepositoryPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromFileContentPayload} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateString(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling customTemplateCreateString.');
            }
            const localVarPath = `/custom_templates/create/string`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("CustomtemplatesCustomTemplateFromFileContentPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a template. **Access policy**: authenticated
         * @summary Remove a template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling customTemplateDelete.');
            }
            const localVarPath = `/custom_templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the content of the Stack file for the specified custom template **Access policy**: authenticated
         * @summary Get Template stack file content.
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateFile(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling customTemplateFile.');
            }
            const localVarPath = `/custom_templates/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a template created from git repository method. **Access policy**: authenticated
         * @summary Fetch the latest config file content based on custom template's git repository configuration
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateGitFetch(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling customTemplateGitFetch.');
            }
            const localVarPath = `/custom_templates/{id}/git_fetch`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a template. **Access policy**: authenticated
         * @summary Inspect a custom template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateInspect(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling customTemplateInspect.');
            }
            const localVarPath = `/custom_templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available custom templates. **Access policy**: authenticated
         * @summary List available custom templates
         * @param {Array<number>} type Template types
         * @param {boolean} [edge] Filter by edge templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateList(type, edge, options = {}) {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type', 'Required parameter type was null or undefined when calling customTemplateList.');
            }
            const localVarPath = `/custom_templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (type) {
                localVarQueryParameter['type'] = type;
            }
            if (edge !== undefined) {
                localVarQueryParameter['edge'] = edge;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a template. **Access policy**: authenticated
         * @summary Update a template
         * @param {number} id Template identifier
         * @param {CustomtemplatesCustomTemplateUpdatePayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateUpdate(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling customTemplateUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling customTemplateUpdate.');
            }
            const localVarPath = `/custom_templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("CustomtemplatesCustomTemplateUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.CustomTemplatesApiFetchParamCreator = CustomTemplatesApiFetchParamCreator;
/**
 * CustomTemplatesApi - functional programming interface
 * @export
 */
const CustomTemplatesApiFp = function (configuration) {
    return {
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {'string' | 'file' | 'repository'} method method for creating template
         * @param {any} body for body documentation see the relevant /custom_templates/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreate(method, body, options) {
            const localVarFetchArgs = (0, exports.CustomTemplatesApiFetchParamCreator)(configuration).customTemplateCreate(method, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {string} title Title of the template
         * @param {string} description Description of the template
         * @param {string} note A note that will be displayed in the UI. Supports HTML content
         * @param {number} platform Platform associated to the template (1 - &#39;linux&#39;, 2 - &#39;windows&#39;)
         * @param {number} type Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
         * @param {any} file File
         * @param {string} [logo] URL of the template&#39;s logo
         * @param {string} [variables] A json array of variables definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateFile(title, description, note, platform, type, file, logo, variables, options) {
            const localVarFetchArgs = (0, exports.CustomTemplatesApiFetchParamCreator)(configuration).customTemplateCreateFile(title, description, note, platform, type, file, logo, variables, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromGitRepositoryPayload} body Required when using method&#x3D;repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateRepository(body, options) {
            const localVarFetchArgs = (0, exports.CustomTemplatesApiFetchParamCreator)(configuration).customTemplateCreateRepository(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromFileContentPayload} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateString(body, options) {
            const localVarFetchArgs = (0, exports.CustomTemplatesApiFetchParamCreator)(configuration).customTemplateCreateString(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a template. **Access policy**: authenticated
         * @summary Remove a template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateDelete(id, options) {
            const localVarFetchArgs = (0, exports.CustomTemplatesApiFetchParamCreator)(configuration).customTemplateDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve the content of the Stack file for the specified custom template **Access policy**: authenticated
         * @summary Get Template stack file content.
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateFile(id, options) {
            const localVarFetchArgs = (0, exports.CustomTemplatesApiFetchParamCreator)(configuration).customTemplateFile(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details about a template created from git repository method. **Access policy**: authenticated
         * @summary Fetch the latest config file content based on custom template's git repository configuration
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateGitFetch(id, options) {
            const localVarFetchArgs = (0, exports.CustomTemplatesApiFetchParamCreator)(configuration).customTemplateGitFetch(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details about a template. **Access policy**: authenticated
         * @summary Inspect a custom template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateInspect(id, options) {
            const localVarFetchArgs = (0, exports.CustomTemplatesApiFetchParamCreator)(configuration).customTemplateInspect(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List available custom templates. **Access policy**: authenticated
         * @summary List available custom templates
         * @param {Array<number>} type Template types
         * @param {boolean} [edge] Filter by edge templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateList(type, edge, options) {
            const localVarFetchArgs = (0, exports.CustomTemplatesApiFetchParamCreator)(configuration).customTemplateList(type, edge, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a template. **Access policy**: authenticated
         * @summary Update a template
         * @param {number} id Template identifier
         * @param {CustomtemplatesCustomTemplateUpdatePayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateUpdate(id, body, options) {
            const localVarFetchArgs = (0, exports.CustomTemplatesApiFetchParamCreator)(configuration).customTemplateUpdate(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.CustomTemplatesApiFp = CustomTemplatesApiFp;
/**
 * CustomTemplatesApi - factory interface
 * @export
 */
const CustomTemplatesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {'string' | 'file' | 'repository'} method method for creating template
         * @param {any} body for body documentation see the relevant /custom_templates/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreate(method, body, options) {
            return (0, exports.CustomTemplatesApiFp)(configuration).customTemplateCreate(method, body, options)(fetch, basePath);
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {string} title Title of the template
         * @param {string} description Description of the template
         * @param {string} note A note that will be displayed in the UI. Supports HTML content
         * @param {number} platform Platform associated to the template (1 - &#39;linux&#39;, 2 - &#39;windows&#39;)
         * @param {number} type Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
         * @param {any} file File
         * @param {string} [logo] URL of the template&#39;s logo
         * @param {string} [variables] A json array of variables definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateFile(title, description, note, platform, type, file, logo, variables, options) {
            return (0, exports.CustomTemplatesApiFp)(configuration).customTemplateCreateFile(title, description, note, platform, type, file, logo, variables, options)(fetch, basePath);
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromGitRepositoryPayload} body Required when using method&#x3D;repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateRepository(body, options) {
            return (0, exports.CustomTemplatesApiFp)(configuration).customTemplateCreateRepository(body, options)(fetch, basePath);
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromFileContentPayload} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateString(body, options) {
            return (0, exports.CustomTemplatesApiFp)(configuration).customTemplateCreateString(body, options)(fetch, basePath);
        },
        /**
         * Remove a template. **Access policy**: authenticated
         * @summary Remove a template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateDelete(id, options) {
            return (0, exports.CustomTemplatesApiFp)(configuration).customTemplateDelete(id, options)(fetch, basePath);
        },
        /**
         * Retrieve the content of the Stack file for the specified custom template **Access policy**: authenticated
         * @summary Get Template stack file content.
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateFile(id, options) {
            return (0, exports.CustomTemplatesApiFp)(configuration).customTemplateFile(id, options)(fetch, basePath);
        },
        /**
         * Retrieve details about a template created from git repository method. **Access policy**: authenticated
         * @summary Fetch the latest config file content based on custom template's git repository configuration
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateGitFetch(id, options) {
            return (0, exports.CustomTemplatesApiFp)(configuration).customTemplateGitFetch(id, options)(fetch, basePath);
        },
        /**
         * Retrieve details about a template. **Access policy**: authenticated
         * @summary Inspect a custom template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateInspect(id, options) {
            return (0, exports.CustomTemplatesApiFp)(configuration).customTemplateInspect(id, options)(fetch, basePath);
        },
        /**
         * List available custom templates. **Access policy**: authenticated
         * @summary List available custom templates
         * @param {Array<number>} type Template types
         * @param {boolean} [edge] Filter by edge templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateList(type, edge, options) {
            return (0, exports.CustomTemplatesApiFp)(configuration).customTemplateList(type, edge, options)(fetch, basePath);
        },
        /**
         * Update a template. **Access policy**: authenticated
         * @summary Update a template
         * @param {number} id Template identifier
         * @param {CustomtemplatesCustomTemplateUpdatePayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateUpdate(id, body, options) {
            return (0, exports.CustomTemplatesApiFp)(configuration).customTemplateUpdate(id, body, options)(fetch, basePath);
        },
    };
};
exports.CustomTemplatesApiFactory = CustomTemplatesApiFactory;
/**
 * CustomTemplatesApi - object-oriented interface
 * @export
 * @class CustomTemplatesApi
 * @extends {BaseAPI}
 */
class CustomTemplatesApi extends BaseAPI {
    /**
     * Create a custom template. **Access policy**: authenticated
     * @summary Create a custom template
     * @param {'string' | 'file' | 'repository'} method method for creating template
     * @param {any} body for body documentation see the relevant /custom_templates/{method} endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    customTemplateCreate(method, body, options) {
        return (0, exports.CustomTemplatesApiFp)(this.configuration).customTemplateCreate(method, body, options)(this.fetch, this.basePath);
    }
    /**
     * Create a custom template. **Access policy**: authenticated
     * @summary Create a custom template
     * @param {string} title Title of the template
     * @param {string} description Description of the template
     * @param {string} note A note that will be displayed in the UI. Supports HTML content
     * @param {number} platform Platform associated to the template (1 - &#39;linux&#39;, 2 - &#39;windows&#39;)
     * @param {number} type Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
     * @param {any} file File
     * @param {string} [logo] URL of the template&#39;s logo
     * @param {string} [variables] A json array of variables definitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    customTemplateCreateFile(title, description, note, platform, type, file, logo, variables, options) {
        return (0, exports.CustomTemplatesApiFp)(this.configuration).customTemplateCreateFile(title, description, note, platform, type, file, logo, variables, options)(this.fetch, this.basePath);
    }
    /**
     * Create a custom template. **Access policy**: authenticated
     * @summary Create a custom template
     * @param {CustomtemplatesCustomTemplateFromGitRepositoryPayload} body Required when using method&#x3D;repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    customTemplateCreateRepository(body, options) {
        return (0, exports.CustomTemplatesApiFp)(this.configuration).customTemplateCreateRepository(body, options)(this.fetch, this.basePath);
    }
    /**
     * Create a custom template. **Access policy**: authenticated
     * @summary Create a custom template
     * @param {CustomtemplatesCustomTemplateFromFileContentPayload} body body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    customTemplateCreateString(body, options) {
        return (0, exports.CustomTemplatesApiFp)(this.configuration).customTemplateCreateString(body, options)(this.fetch, this.basePath);
    }
    /**
     * Remove a template. **Access policy**: authenticated
     * @summary Remove a template
     * @param {number} id Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    customTemplateDelete(id, options) {
        return (0, exports.CustomTemplatesApiFp)(this.configuration).customTemplateDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve the content of the Stack file for the specified custom template **Access policy**: authenticated
     * @summary Get Template stack file content.
     * @param {number} id Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    customTemplateFile(id, options) {
        return (0, exports.CustomTemplatesApiFp)(this.configuration).customTemplateFile(id, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve details about a template created from git repository method. **Access policy**: authenticated
     * @summary Fetch the latest config file content based on custom template's git repository configuration
     * @param {number} id Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    customTemplateGitFetch(id, options) {
        return (0, exports.CustomTemplatesApiFp)(this.configuration).customTemplateGitFetch(id, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve details about a template. **Access policy**: authenticated
     * @summary Inspect a custom template
     * @param {number} id Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    customTemplateInspect(id, options) {
        return (0, exports.CustomTemplatesApiFp)(this.configuration).customTemplateInspect(id, options)(this.fetch, this.basePath);
    }
    /**
     * List available custom templates. **Access policy**: authenticated
     * @summary List available custom templates
     * @param {Array<number>} type Template types
     * @param {boolean} [edge] Filter by edge templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    customTemplateList(type, edge, options) {
        return (0, exports.CustomTemplatesApiFp)(this.configuration).customTemplateList(type, edge, options)(this.fetch, this.basePath);
    }
    /**
     * Update a template. **Access policy**: authenticated
     * @summary Update a template
     * @param {number} id Template identifier
     * @param {CustomtemplatesCustomTemplateUpdatePayload} body Template details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    customTemplateUpdate(id, body, options) {
        return (0, exports.CustomTemplatesApiFp)(this.configuration).customTemplateUpdate(id, body, options)(this.fetch, this.basePath);
    }
}
exports.CustomTemplatesApi = CustomTemplatesApi;
/**
 * DockerApi - fetch parameter creator
 * @export
 */
const DockerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * **Access policy**:
         * @summary Fetch container gpus data
         * @param {number} environmentId Environment identifier
         * @param {number} containerId Container identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockerContainerGpusInspect(environmentId, containerId, options = {}) {
            // verify required parameter 'environmentId' is not null or undefined
            if (environmentId === null || environmentId === undefined) {
                throw new RequiredError('environmentId', 'Required parameter environmentId was null or undefined when calling dockerContainerGpusInspect.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId', 'Required parameter containerId was null or undefined when calling dockerContainerGpusInspect.');
            }
            const localVarPath = `/docker/{environmentId}/containers/{containerId}/gpus`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**:
         * @summary Fetch images
         * @param {number} environmentId Environment identifier
         * @param {boolean} [withUsage] Include image usage information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockerImagesList(environmentId, withUsage, options = {}) {
            // verify required parameter 'environmentId' is not null or undefined
            if (environmentId === null || environmentId === undefined) {
                throw new RequiredError('environmentId', 'Required parameter environmentId was null or undefined when calling dockerImagesList.');
            }
            const localVarPath = `/docker/{environmentId}/images`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (withUsage !== undefined) {
                localVarQueryParameter['withUsage'] = withUsage;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.DockerApiFetchParamCreator = DockerApiFetchParamCreator;
/**
 * DockerApi - functional programming interface
 * @export
 */
const DockerApiFp = function (configuration) {
    return {
        /**
         * **Access policy**:
         * @summary Fetch container gpus data
         * @param {number} environmentId Environment identifier
         * @param {number} containerId Container identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockerContainerGpusInspect(environmentId, containerId, options) {
            const localVarFetchArgs = (0, exports.DockerApiFetchParamCreator)(configuration).dockerContainerGpusInspect(environmentId, containerId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**:
         * @summary Fetch images
         * @param {number} environmentId Environment identifier
         * @param {boolean} [withUsage] Include image usage information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockerImagesList(environmentId, withUsage, options) {
            const localVarFetchArgs = (0, exports.DockerApiFetchParamCreator)(configuration).dockerImagesList(environmentId, withUsage, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.DockerApiFp = DockerApiFp;
/**
 * DockerApi - factory interface
 * @export
 */
const DockerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * **Access policy**:
         * @summary Fetch container gpus data
         * @param {number} environmentId Environment identifier
         * @param {number} containerId Container identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockerContainerGpusInspect(environmentId, containerId, options) {
            return (0, exports.DockerApiFp)(configuration).dockerContainerGpusInspect(environmentId, containerId, options)(fetch, basePath);
        },
        /**
         * **Access policy**:
         * @summary Fetch images
         * @param {number} environmentId Environment identifier
         * @param {boolean} [withUsage] Include image usage information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockerImagesList(environmentId, withUsage, options) {
            return (0, exports.DockerApiFp)(configuration).dockerImagesList(environmentId, withUsage, options)(fetch, basePath);
        },
    };
};
exports.DockerApiFactory = DockerApiFactory;
/**
 * DockerApi - object-oriented interface
 * @export
 * @class DockerApi
 * @extends {BaseAPI}
 */
class DockerApi extends BaseAPI {
    /**
     * **Access policy**:
     * @summary Fetch container gpus data
     * @param {number} environmentId Environment identifier
     * @param {number} containerId Container identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DockerApi
     */
    dockerContainerGpusInspect(environmentId, containerId, options) {
        return (0, exports.DockerApiFp)(this.configuration).dockerContainerGpusInspect(environmentId, containerId, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**:
     * @summary Fetch images
     * @param {number} environmentId Environment identifier
     * @param {boolean} [withUsage] Include image usage information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DockerApi
     */
    dockerImagesList(environmentId, withUsage, options) {
        return (0, exports.DockerApiFp)(this.configuration).dockerImagesList(environmentId, withUsage, options)(this.fetch, this.basePath);
    }
}
exports.DockerApi = DockerApi;
/**
 * EdgeApi - fetch parameter creator
 * @export
 */
const EdgeApiFetchParamCreator = function (configuration) {
    return {
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointsIdEdgeJobsJobIDLogsPost.');
            }
            // verify required parameter 'jobID' is not null or undefined
            if (jobID === null || jobID === undefined) {
                throw new RequiredError('jobID', 'Required parameter jobID was null or undefined when calling endpointsIdEdgeJobsJobIDLogsPost.');
            }
            const localVarPath = `/endpoints/{id}/edge/jobs/{jobID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id, stackId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointsIdEdgeStacksStackIdGet.');
            }
            // verify required parameter 'stackId' is not null or undefined
            if (stackId === null || stackId === undefined) {
                throw new RequiredError('stackId', 'Required parameter stackId was null or undefined when calling endpointsIdEdgeStacksStackIdGet.');
            }
            const localVarPath = `/endpoints/{id}/edge/stacks/{stackId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"stackId"}}`, encodeURIComponent(String(stackId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EdgeApiFetchParamCreator = EdgeApiFetchParamCreator;
/**
 * EdgeApi - functional programming interface
 * @export
 */
const EdgeApiFp = function (configuration) {
    return {
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options) {
            const localVarFetchArgs = (0, exports.EdgeApiFetchParamCreator)(configuration).endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id, stackId, options) {
            const localVarFetchArgs = (0, exports.EdgeApiFetchParamCreator)(configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.EdgeApiFp = EdgeApiFp;
/**
 * EdgeApi - factory interface
 * @export
 */
const EdgeApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options) {
            return (0, exports.EdgeApiFp)(configuration).endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options)(fetch, basePath);
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id, stackId, options) {
            return (0, exports.EdgeApiFp)(configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options)(fetch, basePath);
        },
    };
};
exports.EdgeApiFactory = EdgeApiFactory;
/**
 * EdgeApi - object-oriented interface
 * @export
 * @class EdgeApi
 * @extends {BaseAPI}
 */
class EdgeApi extends BaseAPI {
    /**
     * **Access policy**: public
     * @summary Inspect an EdgeJob Log
     * @param {number} id environment(endpoint) Id
     * @param {number} jobID Job Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeApi
     */
    endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options) {
        return (0, exports.EdgeApiFp)(this.configuration).endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: public
     * @summary Inspect an Edge Stack for an Environment(Endpoint)
     * @param {number} id environment(endpoint) Id
     * @param {number} stackId EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeApi
     */
    endpointsIdEdgeStacksStackIdGet(id, stackId, options) {
        return (0, exports.EdgeApiFp)(this.configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options)(this.fetch, this.basePath);
    }
}
exports.EdgeApi = EdgeApi;
/**
 * EdgeGroupsApi - fetch parameter creator
 * @export
 */
const EdgeGroupsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeGroup
         * @param {EdgegroupsEdgeGroupCreatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupCreate(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling edgeGroupCreate.');
            }
            const localVarPath = `/edge_groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EdgegroupsEdgeGroupCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Deletes an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeGroupDelete.');
            }
            const localVarPath = `/edge_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspects an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupInspect(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeGroupInspect.');
            }
            const localVarPath = `/edge_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary list EdgeGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupList(options = {}) {
            const localVarPath = `/edge_groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Updates an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {EdgegroupsEdgeGroupUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egeGroupUpdate(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling egeGroupUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling egeGroupUpdate.');
            }
            const localVarPath = `/edge_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EdgegroupsEdgeGroupUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EdgeGroupsApiFetchParamCreator = EdgeGroupsApiFetchParamCreator;
/**
 * EdgeGroupsApi - functional programming interface
 * @export
 */
const EdgeGroupsApiFp = function (configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeGroup
         * @param {EdgegroupsEdgeGroupCreatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupCreate(body, options) {
            const localVarFetchArgs = (0, exports.EdgeGroupsApiFetchParamCreator)(configuration).edgeGroupCreate(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Deletes an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupDelete(id, options) {
            const localVarFetchArgs = (0, exports.EdgeGroupsApiFetchParamCreator)(configuration).edgeGroupDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspects an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupInspect(id, options) {
            const localVarFetchArgs = (0, exports.EdgeGroupsApiFetchParamCreator)(configuration).edgeGroupInspect(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary list EdgeGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupList(options) {
            const localVarFetchArgs = (0, exports.EdgeGroupsApiFetchParamCreator)(configuration).edgeGroupList(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Updates an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {EdgegroupsEdgeGroupUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egeGroupUpdate(id, body, options) {
            const localVarFetchArgs = (0, exports.EdgeGroupsApiFetchParamCreator)(configuration).egeGroupUpdate(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.EdgeGroupsApiFp = EdgeGroupsApiFp;
/**
 * EdgeGroupsApi - factory interface
 * @export
 */
const EdgeGroupsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeGroup
         * @param {EdgegroupsEdgeGroupCreatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupCreate(body, options) {
            return (0, exports.EdgeGroupsApiFp)(configuration).edgeGroupCreate(body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Deletes an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupDelete(id, options) {
            return (0, exports.EdgeGroupsApiFp)(configuration).edgeGroupDelete(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Inspects an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupInspect(id, options) {
            return (0, exports.EdgeGroupsApiFp)(configuration).edgeGroupInspect(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary list EdgeGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupList(options) {
            return (0, exports.EdgeGroupsApiFp)(configuration).edgeGroupList(options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Updates an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {EdgegroupsEdgeGroupUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egeGroupUpdate(id, body, options) {
            return (0, exports.EdgeGroupsApiFp)(configuration).egeGroupUpdate(id, body, options)(fetch, basePath);
        },
    };
};
exports.EdgeGroupsApiFactory = EdgeGroupsApiFactory;
/**
 * EdgeGroupsApi - object-oriented interface
 * @export
 * @class EdgeGroupsApi
 * @extends {BaseAPI}
 */
class EdgeGroupsApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Create an EdgeGroup
     * @param {EdgegroupsEdgeGroupCreatePayload} body EdgeGroup data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    edgeGroupCreate(body, options) {
        return (0, exports.EdgeGroupsApiFp)(this.configuration).edgeGroupCreate(body, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Deletes an EdgeGroup
     * @param {number} id EdgeGroup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    edgeGroupDelete(id, options) {
        return (0, exports.EdgeGroupsApiFp)(this.configuration).edgeGroupDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Inspects an EdgeGroup
     * @param {number} id EdgeGroup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    edgeGroupInspect(id, options) {
        return (0, exports.EdgeGroupsApiFp)(this.configuration).edgeGroupInspect(id, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary list EdgeGroups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    edgeGroupList(options) {
        return (0, exports.EdgeGroupsApiFp)(this.configuration).edgeGroupList(options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Updates an EdgeGroup
     * @param {number} id EdgeGroup Id
     * @param {EdgegroupsEdgeGroupUpdatePayload} body EdgeGroup data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    egeGroupUpdate(id, body, options) {
        return (0, exports.EdgeGroupsApiFp)(this.configuration).egeGroupUpdate(id, body, options)(this.fetch, this.basePath);
    }
}
exports.EdgeGroupsApi = EdgeGroupsApi;
/**
 * EdgeJobsApi - fetch parameter creator
 * @export
 */
const EdgeJobsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob
         * @param {'file' | 'string'} method Creation Method
         * @param {any} body for body documentation see the relevant /edge_jobs/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreate(method, body, options = {}) {
            // verify required parameter 'method' is not null or undefined
            if (method === null || method === undefined) {
                throw new RequiredError('method', 'Required parameter method was null or undefined when calling edgeJobCreate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling edgeJobCreate.');
            }
            const localVarPath = `/edge_jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a file
         * @param {any} file Content of the Stack file
         * @param {string} name Name of the stack
         * @param {string} cronExpression A cron expression to schedule this job
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {string} endpoints JSON stringified array of Environment ids
         * @param {boolean} [recurring] If recurring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateFile(file, name, cronExpression, edgeGroups, endpoints, recurring, options = {}) {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling edgeJobCreateFile.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling edgeJobCreateFile.');
            }
            // verify required parameter 'cronExpression' is not null or undefined
            if (cronExpression === null || cronExpression === undefined) {
                throw new RequiredError('cronExpression', 'Required parameter cronExpression was null or undefined when calling edgeJobCreateFile.');
            }
            // verify required parameter 'edgeGroups' is not null or undefined
            if (edgeGroups === null || edgeGroups === undefined) {
                throw new RequiredError('edgeGroups', 'Required parameter edgeGroups was null or undefined when calling edgeJobCreateFile.');
            }
            // verify required parameter 'endpoints' is not null or undefined
            if (endpoints === null || endpoints === undefined) {
                throw new RequiredError('endpoints', 'Required parameter endpoints was null or undefined when calling edgeJobCreateFile.');
            }
            const localVarPath = `/edge_jobs/create/file`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (file !== undefined) {
                localVarFormParams.set('file', file);
            }
            if (name !== undefined) {
                localVarFormParams.set('Name', name);
            }
            if (cronExpression !== undefined) {
                localVarFormParams.set('CronExpression', cronExpression);
            }
            if (edgeGroups !== undefined) {
                localVarFormParams.set('EdgeGroups', edgeGroups);
            }
            if (endpoints !== undefined) {
                localVarFormParams.set('Endpoints', endpoints);
            }
            if (recurring !== undefined) {
                localVarFormParams.set('Recurring', recurring);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a text
         * @param {EdgejobsEdgeJobCreateFromFileContentPayload} body EdgeGroup data when method is string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateString(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling edgeJobCreateString.');
            }
            const localVarPath = `/edge_jobs/create/string`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EdgejobsEdgeJobCreateFromFileContentPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeJobDelete.');
            }
            const localVarPath = `/edge_jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch a file of an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobFile(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeJobFile.');
            }
            const localVarPath = `/edge_jobs/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobInspect(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeJobInspect.');
            }
            const localVarPath = `/edge_jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch EdgeJobs list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobList(options = {}) {
            const localVarPath = `/edge_jobs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTaskLogsInspect(id, taskID, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeJobTaskLogsInspect.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID', 'Required parameter taskID was null or undefined when calling edgeJobTaskLogsInspect.');
            }
            const localVarPath = `/edge_jobs/{id}/tasks/{taskID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Clear the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksClear(id, taskID, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeJobTasksClear.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID', 'Required parameter taskID was null or undefined when calling edgeJobTasksClear.');
            }
            const localVarPath = `/edge_jobs/{id}/tasks/{taskID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Collect the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksCollect(id, taskID, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeJobTasksCollect.');
            }
            // verify required parameter 'taskID' is not null or undefined
            if (taskID === null || taskID === undefined) {
                throw new RequiredError('taskID', 'Required parameter taskID was null or undefined when calling edgeJobTasksCollect.');
            }
            const localVarPath = `/edge_jobs/{id}/tasks/{taskID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the list of tasks on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksList(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeJobTasksList.');
            }
            const localVarPath = `/edge_jobs/{id}/tasks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {EdgejobsEdgeJobUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobUpdate(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeJobUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling edgeJobUpdate.');
            }
            const localVarPath = `/edge_jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EdgejobsEdgeJobUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EdgeJobsApiFetchParamCreator = EdgeJobsApiFetchParamCreator;
/**
 * EdgeJobsApi - functional programming interface
 * @export
 */
const EdgeJobsApiFp = function (configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob
         * @param {'file' | 'string'} method Creation Method
         * @param {any} body for body documentation see the relevant /edge_jobs/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreate(method, body, options) {
            const localVarFetchArgs = (0, exports.EdgeJobsApiFetchParamCreator)(configuration).edgeJobCreate(method, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a file
         * @param {any} file Content of the Stack file
         * @param {string} name Name of the stack
         * @param {string} cronExpression A cron expression to schedule this job
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {string} endpoints JSON stringified array of Environment ids
         * @param {boolean} [recurring] If recurring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateFile(file, name, cronExpression, edgeGroups, endpoints, recurring, options) {
            const localVarFetchArgs = (0, exports.EdgeJobsApiFetchParamCreator)(configuration).edgeJobCreateFile(file, name, cronExpression, edgeGroups, endpoints, recurring, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a text
         * @param {EdgejobsEdgeJobCreateFromFileContentPayload} body EdgeGroup data when method is string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateString(body, options) {
            const localVarFetchArgs = (0, exports.EdgeJobsApiFetchParamCreator)(configuration).edgeJobCreateString(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobDelete(id, options) {
            const localVarFetchArgs = (0, exports.EdgeJobsApiFetchParamCreator)(configuration).edgeJobDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch a file of an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobFile(id, options) {
            const localVarFetchArgs = (0, exports.EdgeJobsApiFetchParamCreator)(configuration).edgeJobFile(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobInspect(id, options) {
            const localVarFetchArgs = (0, exports.EdgeJobsApiFetchParamCreator)(configuration).edgeJobInspect(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch EdgeJobs list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobList(options) {
            const localVarFetchArgs = (0, exports.EdgeJobsApiFetchParamCreator)(configuration).edgeJobList(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTaskLogsInspect(id, taskID, options) {
            const localVarFetchArgs = (0, exports.EdgeJobsApiFetchParamCreator)(configuration).edgeJobTaskLogsInspect(id, taskID, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Clear the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksClear(id, taskID, options) {
            const localVarFetchArgs = (0, exports.EdgeJobsApiFetchParamCreator)(configuration).edgeJobTasksClear(id, taskID, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Collect the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksCollect(id, taskID, options) {
            const localVarFetchArgs = (0, exports.EdgeJobsApiFetchParamCreator)(configuration).edgeJobTasksCollect(id, taskID, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the list of tasks on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksList(id, options) {
            const localVarFetchArgs = (0, exports.EdgeJobsApiFetchParamCreator)(configuration).edgeJobTasksList(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {EdgejobsEdgeJobUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobUpdate(id, body, options) {
            const localVarFetchArgs = (0, exports.EdgeJobsApiFetchParamCreator)(configuration).edgeJobUpdate(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.EdgeJobsApiFp = EdgeJobsApiFp;
/**
 * EdgeJobsApi - factory interface
 * @export
 */
const EdgeJobsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob
         * @param {'file' | 'string'} method Creation Method
         * @param {any} body for body documentation see the relevant /edge_jobs/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreate(method, body, options) {
            return (0, exports.EdgeJobsApiFp)(configuration).edgeJobCreate(method, body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a file
         * @param {any} file Content of the Stack file
         * @param {string} name Name of the stack
         * @param {string} cronExpression A cron expression to schedule this job
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {string} endpoints JSON stringified array of Environment ids
         * @param {boolean} [recurring] If recurring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateFile(file, name, cronExpression, edgeGroups, endpoints, recurring, options) {
            return (0, exports.EdgeJobsApiFp)(configuration).edgeJobCreateFile(file, name, cronExpression, edgeGroups, endpoints, recurring, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a text
         * @param {EdgejobsEdgeJobCreateFromFileContentPayload} body EdgeGroup data when method is string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateString(body, options) {
            return (0, exports.EdgeJobsApiFp)(configuration).edgeJobCreateString(body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobDelete(id, options) {
            return (0, exports.EdgeJobsApiFp)(configuration).edgeJobDelete(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch a file of an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobFile(id, options) {
            return (0, exports.EdgeJobsApiFp)(configuration).edgeJobFile(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobInspect(id, options) {
            return (0, exports.EdgeJobsApiFp)(configuration).edgeJobInspect(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch EdgeJobs list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobList(options) {
            return (0, exports.EdgeJobsApiFp)(configuration).edgeJobList(options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTaskLogsInspect(id, taskID, options) {
            return (0, exports.EdgeJobsApiFp)(configuration).edgeJobTaskLogsInspect(id, taskID, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Clear the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksClear(id, taskID, options) {
            return (0, exports.EdgeJobsApiFp)(configuration).edgeJobTasksClear(id, taskID, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Collect the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksCollect(id, taskID, options) {
            return (0, exports.EdgeJobsApiFp)(configuration).edgeJobTasksCollect(id, taskID, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the list of tasks on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksList(id, options) {
            return (0, exports.EdgeJobsApiFp)(configuration).edgeJobTasksList(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {EdgejobsEdgeJobUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobUpdate(id, body, options) {
            return (0, exports.EdgeJobsApiFp)(configuration).edgeJobUpdate(id, body, options)(fetch, basePath);
        },
    };
};
exports.EdgeJobsApiFactory = EdgeJobsApiFactory;
/**
 * EdgeJobsApi - object-oriented interface
 * @export
 * @class EdgeJobsApi
 * @extends {BaseAPI}
 */
class EdgeJobsApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Create an EdgeJob
     * @param {'file' | 'string'} method Creation Method
     * @param {any} body for body documentation see the relevant /edge_jobs/create/{method} endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    edgeJobCreate(method, body, options) {
        return (0, exports.EdgeJobsApiFp)(this.configuration).edgeJobCreate(method, body, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Create an EdgeJob from a file
     * @param {any} file Content of the Stack file
     * @param {string} name Name of the stack
     * @param {string} cronExpression A cron expression to schedule this job
     * @param {string} edgeGroups JSON stringified array of Edge Groups ids
     * @param {string} endpoints JSON stringified array of Environment ids
     * @param {boolean} [recurring] If recurring
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    edgeJobCreateFile(file, name, cronExpression, edgeGroups, endpoints, recurring, options) {
        return (0, exports.EdgeJobsApiFp)(this.configuration).edgeJobCreateFile(file, name, cronExpression, edgeGroups, endpoints, recurring, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Create an EdgeJob from a text
     * @param {EdgejobsEdgeJobCreateFromFileContentPayload} body EdgeGroup data when method is string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    edgeJobCreateString(body, options) {
        return (0, exports.EdgeJobsApiFp)(this.configuration).edgeJobCreateString(body, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Delete an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    edgeJobDelete(id, options) {
        return (0, exports.EdgeJobsApiFp)(this.configuration).edgeJobDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Fetch a file of an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    edgeJobFile(id, options) {
        return (0, exports.EdgeJobsApiFp)(this.configuration).edgeJobFile(id, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Inspect an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    edgeJobInspect(id, options) {
        return (0, exports.EdgeJobsApiFp)(this.configuration).edgeJobInspect(id, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Fetch EdgeJobs list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    edgeJobList(options) {
        return (0, exports.EdgeJobsApiFp)(this.configuration).edgeJobList(options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Fetch the log for a specifc task on an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {number} taskID Task Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    edgeJobTaskLogsInspect(id, taskID, options) {
        return (0, exports.EdgeJobsApiFp)(this.configuration).edgeJobTaskLogsInspect(id, taskID, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Clear the log for a specifc task on an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {number} taskID Task Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    edgeJobTasksClear(id, taskID, options) {
        return (0, exports.EdgeJobsApiFp)(this.configuration).edgeJobTasksClear(id, taskID, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Collect the log for a specifc task on an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {number} taskID Task Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    edgeJobTasksCollect(id, taskID, options) {
        return (0, exports.EdgeJobsApiFp)(this.configuration).edgeJobTasksCollect(id, taskID, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Fetch the list of tasks on an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    edgeJobTasksList(id, options) {
        return (0, exports.EdgeJobsApiFp)(this.configuration).edgeJobTasksList(id, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Update an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {EdgejobsEdgeJobUpdatePayload} body EdgeGroup data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    edgeJobUpdate(id, body, options) {
        return (0, exports.EdgeJobsApiFp)(this.configuration).edgeJobUpdate(id, body, options)(this.fetch, this.basePath);
    }
}
exports.EdgeJobsApi = EdgeJobsApi;
/**
 * EdgeStacksApi - fetch parameter creator
 * @export
 */
const EdgeStacksApiFetchParamCreator = function (configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack
         * @param {'file' | 'string' | 'repository'} method Creation Method
         * @param {any} body for body documentation see the relevant /edge_stacks/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreate(method, body, options = {}) {
            // verify required parameter 'method' is not null or undefined
            if (method === null || method === undefined) {
                throw new RequiredError('method', 'Required parameter method was null or undefined when calling edgeStackCreate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling edgeStackCreate.');
            }
            const localVarPath = `/edge_stacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from file
         * @param {string} name Name of the stack
         * @param {any} file Content of the Stack file
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {number} deploymentType deploy type 0 - &#39;compose&#39;, 1 - &#39;kubernetes&#39;, 2 - &#39;nomad&#39;
         * @param {string} [registries] JSON stringified array of Registry ids to use for this stack
         * @param {boolean} [useManifestNamespaces] Uses the manifest&#39;s namespaces instead of the default one, relevant only for kube environments
         * @param {boolean} [prePullImage] Pre Pull image
         * @param {boolean} [retryDeploy] Retry deploy
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateFile(name, file, edgeGroups, deploymentType, registries, useManifestNamespaces, prePullImage, retryDeploy, dryrun, options = {}) {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling edgeStackCreateFile.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling edgeStackCreateFile.');
            }
            // verify required parameter 'edgeGroups' is not null or undefined
            if (edgeGroups === null || edgeGroups === undefined) {
                throw new RequiredError('edgeGroups', 'Required parameter edgeGroups was null or undefined when calling edgeStackCreateFile.');
            }
            // verify required parameter 'deploymentType' is not null or undefined
            if (deploymentType === null || deploymentType === undefined) {
                throw new RequiredError('deploymentType', 'Required parameter deploymentType was null or undefined when calling edgeStackCreateFile.');
            }
            const localVarPath = `/edge_stacks/create/file`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (dryrun !== undefined) {
                localVarQueryParameter['dryrun'] = dryrun;
            }
            if (name !== undefined) {
                localVarFormParams.set('Name', name);
            }
            if (file !== undefined) {
                localVarFormParams.set('file', file);
            }
            if (edgeGroups !== undefined) {
                localVarFormParams.set('EdgeGroups', edgeGroups);
            }
            if (deploymentType !== undefined) {
                localVarFormParams.set('DeploymentType', deploymentType);
            }
            if (registries !== undefined) {
                localVarFormParams.set('Registries', registries);
            }
            if (useManifestNamespaces !== undefined) {
                localVarFormParams.set('UseManifestNamespaces', useManifestNamespaces);
            }
            if (prePullImage !== undefined) {
                localVarFormParams.set('PrePullImage', prePullImage);
            }
            if (retryDeploy !== undefined) {
                localVarFormParams.set('RetryDeploy', retryDeploy);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a git repository
         * @param {EdgestacksEdgeStackFromGitRepositoryPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateRepository(body, dryrun, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling edgeStackCreateRepository.');
            }
            const localVarPath = `/edge_stacks/create/repository`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (dryrun !== undefined) {
                localVarQueryParameter['dryrun'] = dryrun;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EdgestacksEdgeStackFromGitRepositoryPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a text
         * @param {EdgestacksEdgeStackFromStringPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateString(body, dryrun, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling edgeStackCreateString.');
            }
            const localVarPath = `/edge_stacks/create/string`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (dryrun !== undefined) {
                localVarQueryParameter['dryrun'] = dryrun;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EdgestacksEdgeStackFromStringPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeStackDelete.');
            }
            const localVarPath = `/edge_stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the stack file for an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackFile(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeStackFile.');
            }
            const localVarPath = `/edge_stacks/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackInspect(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeStackInspect.');
            }
            const localVarPath = `/edge_stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of EdgeStacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackList(options = {}) {
            const localVarPath = `/edge_stacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Delete an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {number} environmentId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackStatusDelete(id, environmentId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeStackStatusDelete.');
            }
            // verify required parameter 'environmentId' is not null or undefined
            if (environmentId === null || environmentId === undefined) {
                throw new RequiredError('environmentId', 'Required parameter environmentId was null or undefined when calling edgeStackStatusDelete.');
            }
            const localVarPath = `/edge_stacks/{id}/status/{environmentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Update an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateStatusPayload} body EdgeStack status payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackStatusUpdate(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeStackStatusUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling edgeStackStatusUpdate.');
            }
            const localVarPath = `/edge_stacks/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EdgestacksUpdateStatusPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateEdgeStackPayload} body EdgeStack data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackUpdate(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling edgeStackUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling edgeStackUpdate.');
            }
            const localVarPath = `/edge_stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EdgestacksUpdateEdgeStackPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id, stackId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointsIdEdgeStacksStackIdGet.');
            }
            // verify required parameter 'stackId' is not null or undefined
            if (stackId === null || stackId === undefined) {
                throw new RequiredError('stackId', 'Required parameter stackId was null or undefined when calling endpointsIdEdgeStacksStackIdGet.');
            }
            const localVarPath = `/endpoints/{id}/edge/stacks/{stackId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"stackId"}}`, encodeURIComponent(String(stackId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EdgeStacksApiFetchParamCreator = EdgeStacksApiFetchParamCreator;
/**
 * EdgeStacksApi - functional programming interface
 * @export
 */
const EdgeStacksApiFp = function (configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack
         * @param {'file' | 'string' | 'repository'} method Creation Method
         * @param {any} body for body documentation see the relevant /edge_stacks/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreate(method, body, options) {
            const localVarFetchArgs = (0, exports.EdgeStacksApiFetchParamCreator)(configuration).edgeStackCreate(method, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from file
         * @param {string} name Name of the stack
         * @param {any} file Content of the Stack file
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {number} deploymentType deploy type 0 - &#39;compose&#39;, 1 - &#39;kubernetes&#39;, 2 - &#39;nomad&#39;
         * @param {string} [registries] JSON stringified array of Registry ids to use for this stack
         * @param {boolean} [useManifestNamespaces] Uses the manifest&#39;s namespaces instead of the default one, relevant only for kube environments
         * @param {boolean} [prePullImage] Pre Pull image
         * @param {boolean} [retryDeploy] Retry deploy
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateFile(name, file, edgeGroups, deploymentType, registries, useManifestNamespaces, prePullImage, retryDeploy, dryrun, options) {
            const localVarFetchArgs = (0, exports.EdgeStacksApiFetchParamCreator)(configuration).edgeStackCreateFile(name, file, edgeGroups, deploymentType, registries, useManifestNamespaces, prePullImage, retryDeploy, dryrun, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a git repository
         * @param {EdgestacksEdgeStackFromGitRepositoryPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateRepository(body, dryrun, options) {
            const localVarFetchArgs = (0, exports.EdgeStacksApiFetchParamCreator)(configuration).edgeStackCreateRepository(body, dryrun, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a text
         * @param {EdgestacksEdgeStackFromStringPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateString(body, dryrun, options) {
            const localVarFetchArgs = (0, exports.EdgeStacksApiFetchParamCreator)(configuration).edgeStackCreateString(body, dryrun, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackDelete(id, options) {
            const localVarFetchArgs = (0, exports.EdgeStacksApiFetchParamCreator)(configuration).edgeStackDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the stack file for an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackFile(id, options) {
            const localVarFetchArgs = (0, exports.EdgeStacksApiFetchParamCreator)(configuration).edgeStackFile(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackInspect(id, options) {
            const localVarFetchArgs = (0, exports.EdgeStacksApiFetchParamCreator)(configuration).edgeStackInspect(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of EdgeStacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackList(options) {
            const localVarFetchArgs = (0, exports.EdgeStacksApiFetchParamCreator)(configuration).edgeStackList(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Delete an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {number} environmentId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackStatusDelete(id, environmentId, options) {
            const localVarFetchArgs = (0, exports.EdgeStacksApiFetchParamCreator)(configuration).edgeStackStatusDelete(id, environmentId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Update an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateStatusPayload} body EdgeStack status payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackStatusUpdate(id, body, options) {
            const localVarFetchArgs = (0, exports.EdgeStacksApiFetchParamCreator)(configuration).edgeStackStatusUpdate(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateEdgeStackPayload} body EdgeStack data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackUpdate(id, body, options) {
            const localVarFetchArgs = (0, exports.EdgeStacksApiFetchParamCreator)(configuration).edgeStackUpdate(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id, stackId, options) {
            const localVarFetchArgs = (0, exports.EdgeStacksApiFetchParamCreator)(configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.EdgeStacksApiFp = EdgeStacksApiFp;
/**
 * EdgeStacksApi - factory interface
 * @export
 */
const EdgeStacksApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack
         * @param {'file' | 'string' | 'repository'} method Creation Method
         * @param {any} body for body documentation see the relevant /edge_stacks/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreate(method, body, options) {
            return (0, exports.EdgeStacksApiFp)(configuration).edgeStackCreate(method, body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from file
         * @param {string} name Name of the stack
         * @param {any} file Content of the Stack file
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {number} deploymentType deploy type 0 - &#39;compose&#39;, 1 - &#39;kubernetes&#39;, 2 - &#39;nomad&#39;
         * @param {string} [registries] JSON stringified array of Registry ids to use for this stack
         * @param {boolean} [useManifestNamespaces] Uses the manifest&#39;s namespaces instead of the default one, relevant only for kube environments
         * @param {boolean} [prePullImage] Pre Pull image
         * @param {boolean} [retryDeploy] Retry deploy
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateFile(name, file, edgeGroups, deploymentType, registries, useManifestNamespaces, prePullImage, retryDeploy, dryrun, options) {
            return (0, exports.EdgeStacksApiFp)(configuration).edgeStackCreateFile(name, file, edgeGroups, deploymentType, registries, useManifestNamespaces, prePullImage, retryDeploy, dryrun, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a git repository
         * @param {EdgestacksEdgeStackFromGitRepositoryPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateRepository(body, dryrun, options) {
            return (0, exports.EdgeStacksApiFp)(configuration).edgeStackCreateRepository(body, dryrun, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a text
         * @param {EdgestacksEdgeStackFromStringPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateString(body, dryrun, options) {
            return (0, exports.EdgeStacksApiFp)(configuration).edgeStackCreateString(body, dryrun, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackDelete(id, options) {
            return (0, exports.EdgeStacksApiFp)(configuration).edgeStackDelete(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the stack file for an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackFile(id, options) {
            return (0, exports.EdgeStacksApiFp)(configuration).edgeStackFile(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackInspect(id, options) {
            return (0, exports.EdgeStacksApiFp)(configuration).edgeStackInspect(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of EdgeStacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackList(options) {
            return (0, exports.EdgeStacksApiFp)(configuration).edgeStackList(options)(fetch, basePath);
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Delete an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {number} environmentId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackStatusDelete(id, environmentId, options) {
            return (0, exports.EdgeStacksApiFp)(configuration).edgeStackStatusDelete(id, environmentId, options)(fetch, basePath);
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Update an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateStatusPayload} body EdgeStack status payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackStatusUpdate(id, body, options) {
            return (0, exports.EdgeStacksApiFp)(configuration).edgeStackStatusUpdate(id, body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateEdgeStackPayload} body EdgeStack data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackUpdate(id, body, options) {
            return (0, exports.EdgeStacksApiFp)(configuration).edgeStackUpdate(id, body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id, stackId, options) {
            return (0, exports.EdgeStacksApiFp)(configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options)(fetch, basePath);
        },
    };
};
exports.EdgeStacksApiFactory = EdgeStacksApiFactory;
/**
 * EdgeStacksApi - object-oriented interface
 * @export
 * @class EdgeStacksApi
 * @extends {BaseAPI}
 */
class EdgeStacksApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Create an EdgeStack
     * @param {'file' | 'string' | 'repository'} method Creation Method
     * @param {any} body for body documentation see the relevant /edge_stacks/create/{method} endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    edgeStackCreate(method, body, options) {
        return (0, exports.EdgeStacksApiFp)(this.configuration).edgeStackCreate(method, body, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Create an EdgeStack from file
     * @param {string} name Name of the stack
     * @param {any} file Content of the Stack file
     * @param {string} edgeGroups JSON stringified array of Edge Groups ids
     * @param {number} deploymentType deploy type 0 - &#39;compose&#39;, 1 - &#39;kubernetes&#39;, 2 - &#39;nomad&#39;
     * @param {string} [registries] JSON stringified array of Registry ids to use for this stack
     * @param {boolean} [useManifestNamespaces] Uses the manifest&#39;s namespaces instead of the default one, relevant only for kube environments
     * @param {boolean} [prePullImage] Pre Pull image
     * @param {boolean} [retryDeploy] Retry deploy
     * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    edgeStackCreateFile(name, file, edgeGroups, deploymentType, registries, useManifestNamespaces, prePullImage, retryDeploy, dryrun, options) {
        return (0, exports.EdgeStacksApiFp)(this.configuration).edgeStackCreateFile(name, file, edgeGroups, deploymentType, registries, useManifestNamespaces, prePullImage, retryDeploy, dryrun, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Create an EdgeStack from a git repository
     * @param {EdgestacksEdgeStackFromGitRepositoryPayload} body stack config
     * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    edgeStackCreateRepository(body, dryrun, options) {
        return (0, exports.EdgeStacksApiFp)(this.configuration).edgeStackCreateRepository(body, dryrun, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Create an EdgeStack from a text
     * @param {EdgestacksEdgeStackFromStringPayload} body stack config
     * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    edgeStackCreateString(body, dryrun, options) {
        return (0, exports.EdgeStacksApiFp)(this.configuration).edgeStackCreateString(body, dryrun, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Delete an EdgeStack
     * @param {number} id EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    edgeStackDelete(id, options) {
        return (0, exports.EdgeStacksApiFp)(this.configuration).edgeStackDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Fetches the stack file for an EdgeStack
     * @param {number} id EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    edgeStackFile(id, options) {
        return (0, exports.EdgeStacksApiFp)(this.configuration).edgeStackFile(id, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Inspect an EdgeStack
     * @param {number} id EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    edgeStackInspect(id, options) {
        return (0, exports.EdgeStacksApiFp)(this.configuration).edgeStackInspect(id, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Fetches the list of EdgeStacks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    edgeStackList(options) {
        return (0, exports.EdgeStacksApiFp)(this.configuration).edgeStackList(options)(this.fetch, this.basePath);
    }
    /**
     * Authorized only if the request is done by an Edge Environment(Endpoint)
     * @summary Delete an EdgeStack status
     * @param {number} id EdgeStack Id
     * @param {number} environmentId Environment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    edgeStackStatusDelete(id, environmentId, options) {
        return (0, exports.EdgeStacksApiFp)(this.configuration).edgeStackStatusDelete(id, environmentId, options)(this.fetch, this.basePath);
    }
    /**
     * Authorized only if the request is done by an Edge Environment(Endpoint)
     * @summary Update an EdgeStack status
     * @param {number} id EdgeStack Id
     * @param {EdgestacksUpdateStatusPayload} body EdgeStack status payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    edgeStackStatusUpdate(id, body, options) {
        return (0, exports.EdgeStacksApiFp)(this.configuration).edgeStackStatusUpdate(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Update an EdgeStack
     * @param {number} id EdgeStack Id
     * @param {EdgestacksUpdateEdgeStackPayload} body EdgeStack data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    edgeStackUpdate(id, body, options) {
        return (0, exports.EdgeStacksApiFp)(this.configuration).edgeStackUpdate(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: public
     * @summary Inspect an Edge Stack for an Environment(Endpoint)
     * @param {number} id environment(endpoint) Id
     * @param {number} stackId EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    endpointsIdEdgeStacksStackIdGet(id, stackId, options) {
        return (0, exports.EdgeStacksApiFp)(this.configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options)(this.fetch, this.basePath);
    }
}
exports.EdgeStacksApi = EdgeStacksApi;
/**
 * EdgeTemplatesApi - fetch parameter creator
 * @export
 */
const EdgeTemplatesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of Edge Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeTemplateList(options = {}) {
            const localVarPath = `/edge_templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EdgeTemplatesApiFetchParamCreator = EdgeTemplatesApiFetchParamCreator;
/**
 * EdgeTemplatesApi - functional programming interface
 * @export
 */
const EdgeTemplatesApiFp = function (configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of Edge Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeTemplateList(options) {
            const localVarFetchArgs = (0, exports.EdgeTemplatesApiFetchParamCreator)(configuration).edgeTemplateList(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.EdgeTemplatesApiFp = EdgeTemplatesApiFp;
/**
 * EdgeTemplatesApi - factory interface
 * @export
 */
const EdgeTemplatesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of Edge Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeTemplateList(options) {
            return (0, exports.EdgeTemplatesApiFp)(configuration).edgeTemplateList(options)(fetch, basePath);
        },
    };
};
exports.EdgeTemplatesApiFactory = EdgeTemplatesApiFactory;
/**
 * EdgeTemplatesApi - object-oriented interface
 * @export
 * @class EdgeTemplatesApi
 * @extends {BaseAPI}
 */
class EdgeTemplatesApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Fetches the list of Edge Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeTemplatesApi
     */
    edgeTemplateList(options) {
        return (0, exports.EdgeTemplatesApiFp)(this.configuration).edgeTemplateList(options)(this.fetch, this.basePath);
    }
}
exports.EdgeTemplatesApi = EdgeTemplatesApi;
/**
 * EndpointGroupsApi - fetch parameter creator
 * @export
 */
const EndpointGroupsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Add an environment(endpoint) to an environment(endpoint) group **Access policy**: administrator
         * @summary Add an environment(endpoint) to an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupAddEndpoint(id, endpointId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointGroupAddEndpoint.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling endpointGroupAddEndpoint.');
            }
            const localVarPath = `/endpoint_groups/{id}/endpoints/{endpointId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"endpointId"}}`, encodeURIComponent(String(endpointId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an environment(endpoint) group. **Access policy**: administrator
         * @summary Remove an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointGroupDelete.');
            }
            const localVarPath = `/endpoint_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Removes environment(endpoint) from an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDeleteEndpoint(id, endpointId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointGroupDeleteEndpoint.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling endpointGroupDeleteEndpoint.');
            }
            const localVarPath = `/endpoint_groups/{id}/endpoints/{endpointId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"endpointId"}}`, encodeURIComponent(String(endpointId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all environment(endpoint) groups based on the current user authorizations. Will return all environment(endpoint) groups if using an administrator account otherwise it will only return authorized environment(endpoint) groups. **Access policy**: restricted
         * @summary List Environment(Endpoint) groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupList(options = {}) {
            const localVarPath = `/endpoint_groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an environment(endpoint) group. **Access policy**: administrator
         * @summary Update an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {EndpointgroupsEndpointGroupUpdatePayload} body EndpointGroup details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupUpdate(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointGroupUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling endpointGroupUpdate.');
            }
            const localVarPath = `/endpoint_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EndpointgroupsEndpointGroupUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details abont an environment(endpoint) group. **Access policy**: administrator
         * @summary Inspect an Environment(Endpoint) group
         * @param {number} id Environment(Endpoint) group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsIdGet(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointGroupsIdGet.');
            }
            const localVarPath = `/endpoint_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new environment(endpoint) group. **Access policy**: administrator
         * @summary Create an Environment(Endpoint) Group
         * @param {EndpointgroupsEndpointGroupCreatePayload} body Environment(Endpoint) Group details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsPost(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling endpointGroupsPost.');
            }
            const localVarPath = `/endpoint_groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EndpointgroupsEndpointGroupCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EndpointGroupsApiFetchParamCreator = EndpointGroupsApiFetchParamCreator;
/**
 * EndpointGroupsApi - functional programming interface
 * @export
 */
const EndpointGroupsApiFp = function (configuration) {
    return {
        /**
         * Add an environment(endpoint) to an environment(endpoint) group **Access policy**: administrator
         * @summary Add an environment(endpoint) to an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupAddEndpoint(id, endpointId, options) {
            const localVarFetchArgs = (0, exports.EndpointGroupsApiFetchParamCreator)(configuration).endpointGroupAddEndpoint(id, endpointId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove an environment(endpoint) group. **Access policy**: administrator
         * @summary Remove an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDelete(id, options) {
            const localVarFetchArgs = (0, exports.EndpointGroupsApiFetchParamCreator)(configuration).endpointGroupDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Removes environment(endpoint) from an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDeleteEndpoint(id, endpointId, options) {
            const localVarFetchArgs = (0, exports.EndpointGroupsApiFetchParamCreator)(configuration).endpointGroupDeleteEndpoint(id, endpointId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all environment(endpoint) groups based on the current user authorizations. Will return all environment(endpoint) groups if using an administrator account otherwise it will only return authorized environment(endpoint) groups. **Access policy**: restricted
         * @summary List Environment(Endpoint) groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupList(options) {
            const localVarFetchArgs = (0, exports.EndpointGroupsApiFetchParamCreator)(configuration).endpointGroupList(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an environment(endpoint) group. **Access policy**: administrator
         * @summary Update an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {EndpointgroupsEndpointGroupUpdatePayload} body EndpointGroup details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupUpdate(id, body, options) {
            const localVarFetchArgs = (0, exports.EndpointGroupsApiFetchParamCreator)(configuration).endpointGroupUpdate(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details abont an environment(endpoint) group. **Access policy**: administrator
         * @summary Inspect an Environment(Endpoint) group
         * @param {number} id Environment(Endpoint) group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsIdGet(id, options) {
            const localVarFetchArgs = (0, exports.EndpointGroupsApiFetchParamCreator)(configuration).endpointGroupsIdGet(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new environment(endpoint) group. **Access policy**: administrator
         * @summary Create an Environment(Endpoint) Group
         * @param {EndpointgroupsEndpointGroupCreatePayload} body Environment(Endpoint) Group details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsPost(body, options) {
            const localVarFetchArgs = (0, exports.EndpointGroupsApiFetchParamCreator)(configuration).endpointGroupsPost(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.EndpointGroupsApiFp = EndpointGroupsApiFp;
/**
 * EndpointGroupsApi - factory interface
 * @export
 */
const EndpointGroupsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Add an environment(endpoint) to an environment(endpoint) group **Access policy**: administrator
         * @summary Add an environment(endpoint) to an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupAddEndpoint(id, endpointId, options) {
            return (0, exports.EndpointGroupsApiFp)(configuration).endpointGroupAddEndpoint(id, endpointId, options)(fetch, basePath);
        },
        /**
         * Remove an environment(endpoint) group. **Access policy**: administrator
         * @summary Remove an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDelete(id, options) {
            return (0, exports.EndpointGroupsApiFp)(configuration).endpointGroupDelete(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: administrator
         * @summary Removes environment(endpoint) from an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDeleteEndpoint(id, endpointId, options) {
            return (0, exports.EndpointGroupsApiFp)(configuration).endpointGroupDeleteEndpoint(id, endpointId, options)(fetch, basePath);
        },
        /**
         * List all environment(endpoint) groups based on the current user authorizations. Will return all environment(endpoint) groups if using an administrator account otherwise it will only return authorized environment(endpoint) groups. **Access policy**: restricted
         * @summary List Environment(Endpoint) groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupList(options) {
            return (0, exports.EndpointGroupsApiFp)(configuration).endpointGroupList(options)(fetch, basePath);
        },
        /**
         * Update an environment(endpoint) group. **Access policy**: administrator
         * @summary Update an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {EndpointgroupsEndpointGroupUpdatePayload} body EndpointGroup details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupUpdate(id, body, options) {
            return (0, exports.EndpointGroupsApiFp)(configuration).endpointGroupUpdate(id, body, options)(fetch, basePath);
        },
        /**
         * Retrieve details abont an environment(endpoint) group. **Access policy**: administrator
         * @summary Inspect an Environment(Endpoint) group
         * @param {number} id Environment(Endpoint) group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsIdGet(id, options) {
            return (0, exports.EndpointGroupsApiFp)(configuration).endpointGroupsIdGet(id, options)(fetch, basePath);
        },
        /**
         * Create a new environment(endpoint) group. **Access policy**: administrator
         * @summary Create an Environment(Endpoint) Group
         * @param {EndpointgroupsEndpointGroupCreatePayload} body Environment(Endpoint) Group details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsPost(body, options) {
            return (0, exports.EndpointGroupsApiFp)(configuration).endpointGroupsPost(body, options)(fetch, basePath);
        },
    };
};
exports.EndpointGroupsApiFactory = EndpointGroupsApiFactory;
/**
 * EndpointGroupsApi - object-oriented interface
 * @export
 * @class EndpointGroupsApi
 * @extends {BaseAPI}
 */
class EndpointGroupsApi extends BaseAPI {
    /**
     * Add an environment(endpoint) to an environment(endpoint) group **Access policy**: administrator
     * @summary Add an environment(endpoint) to an environment(endpoint) group
     * @param {number} id EndpointGroup identifier
     * @param {number} endpointId Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    endpointGroupAddEndpoint(id, endpointId, options) {
        return (0, exports.EndpointGroupsApiFp)(this.configuration).endpointGroupAddEndpoint(id, endpointId, options)(this.fetch, this.basePath);
    }
    /**
     * Remove an environment(endpoint) group. **Access policy**: administrator
     * @summary Remove an environment(endpoint) group
     * @param {number} id EndpointGroup identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    endpointGroupDelete(id, options) {
        return (0, exports.EndpointGroupsApiFp)(this.configuration).endpointGroupDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: administrator
     * @summary Removes environment(endpoint) from an environment(endpoint) group
     * @param {number} id EndpointGroup identifier
     * @param {number} endpointId Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    endpointGroupDeleteEndpoint(id, endpointId, options) {
        return (0, exports.EndpointGroupsApiFp)(this.configuration).endpointGroupDeleteEndpoint(id, endpointId, options)(this.fetch, this.basePath);
    }
    /**
     * List all environment(endpoint) groups based on the current user authorizations. Will return all environment(endpoint) groups if using an administrator account otherwise it will only return authorized environment(endpoint) groups. **Access policy**: restricted
     * @summary List Environment(Endpoint) groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    endpointGroupList(options) {
        return (0, exports.EndpointGroupsApiFp)(this.configuration).endpointGroupList(options)(this.fetch, this.basePath);
    }
    /**
     * Update an environment(endpoint) group. **Access policy**: administrator
     * @summary Update an environment(endpoint) group
     * @param {number} id EndpointGroup identifier
     * @param {EndpointgroupsEndpointGroupUpdatePayload} body EndpointGroup details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    endpointGroupUpdate(id, body, options) {
        return (0, exports.EndpointGroupsApiFp)(this.configuration).endpointGroupUpdate(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve details abont an environment(endpoint) group. **Access policy**: administrator
     * @summary Inspect an Environment(Endpoint) group
     * @param {number} id Environment(Endpoint) group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    endpointGroupsIdGet(id, options) {
        return (0, exports.EndpointGroupsApiFp)(this.configuration).endpointGroupsIdGet(id, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new environment(endpoint) group. **Access policy**: administrator
     * @summary Create an Environment(Endpoint) Group
     * @param {EndpointgroupsEndpointGroupCreatePayload} body Environment(Endpoint) Group details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    endpointGroupsPost(body, options) {
        return (0, exports.EndpointGroupsApiFp)(this.configuration).endpointGroupsPost(body, options)(this.fetch, this.basePath);
    }
}
exports.EndpointGroupsApi = EndpointGroupsApi;
/**
 * EndpointsApi - fetch parameter creator
 * @export
 */
const EndpointsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * De-association an edge environment(endpoint). **Access policy**: administrator
         * @summary De-association an edge environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointAssociationDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointAssociationDelete.');
            }
            const localVarPath = `/endpoints/{id}/association`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new environment(endpoint) that will be used to manage an environment(endpoint). **Access policy**: administrator
         * @summary Create a new environment(endpoint)
         * @param {string} name Name that will be used to identify this environment(endpoint) (example: my-environment)
         * @param {number} endpointCreationType Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment)
         * @param {string} edgeTunnelServerAddress URL or IP address that will be used to establish a reverse tunnel
         * @param {string} [URL] URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment)
         * @param {string} [publicURL] URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375)
         * @param {number} [groupID] Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned).
         * @param {boolean} [TLS] Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipVerify] Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipClientVerify] Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {any} [tLSCACertFile] TLS CA certificate file
         * @param {any} [tLSCertFile] TLS client certificate file
         * @param {any} [tLSKeyFile] TLS client key file
         * @param {string} [azureApplicationID] Azure application ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureTenantID] Azure tenant ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureAuthenticationKey] Azure authentication key. Required if environment(endpoint) type is set to 3
         * @param {Array<number>} [tagIds] List of tag identifiers to which this environment(endpoint) is associated
         * @param {number} [edgeCheckinInterval] The check in interval for edge agent (in seconds)
         * @param {string} [gpus] List of GPUs - json stringified array of {name, value} structs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreate(name, endpointCreationType, edgeTunnelServerAddress, URL, publicURL, groupID, TLS, tLSSkipVerify, tLSSkipClientVerify, tLSCACertFile, tLSCertFile, tLSKeyFile, azureApplicationID, azureTenantID, azureAuthenticationKey, tagIds, edgeCheckinInterval, gpus, options = {}) {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling endpointCreate.');
            }
            // verify required parameter 'endpointCreationType' is not null or undefined
            if (endpointCreationType === null || endpointCreationType === undefined) {
                throw new RequiredError('endpointCreationType', 'Required parameter endpointCreationType was null or undefined when calling endpointCreate.');
            }
            // verify required parameter 'edgeTunnelServerAddress' is not null or undefined
            if (edgeTunnelServerAddress === null || edgeTunnelServerAddress === undefined) {
                throw new RequiredError('edgeTunnelServerAddress', 'Required parameter edgeTunnelServerAddress was null or undefined when calling endpointCreate.');
            }
            const localVarPath = `/endpoints`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (name !== undefined) {
                localVarFormParams.set('Name', name);
            }
            if (endpointCreationType !== undefined) {
                localVarFormParams.set('EndpointCreationType', endpointCreationType);
            }
            if (URL !== undefined) {
                localVarFormParams.set('URL', URL);
            }
            if (publicURL !== undefined) {
                localVarFormParams.set('PublicURL', publicURL);
            }
            if (groupID !== undefined) {
                localVarFormParams.set('GroupID', groupID);
            }
            if (TLS !== undefined) {
                localVarFormParams.set('TLS', TLS);
            }
            if (tLSSkipVerify !== undefined) {
                localVarFormParams.set('TLSSkipVerify', tLSSkipVerify);
            }
            if (tLSSkipClientVerify !== undefined) {
                localVarFormParams.set('TLSSkipClientVerify', tLSSkipClientVerify);
            }
            if (tLSCACertFile !== undefined) {
                localVarFormParams.set('TLSCACertFile', tLSCACertFile);
            }
            if (tLSCertFile !== undefined) {
                localVarFormParams.set('TLSCertFile', tLSCertFile);
            }
            if (tLSKeyFile !== undefined) {
                localVarFormParams.set('TLSKeyFile', tLSKeyFile);
            }
            if (azureApplicationID !== undefined) {
                localVarFormParams.set('AzureApplicationID', azureApplicationID);
            }
            if (azureTenantID !== undefined) {
                localVarFormParams.set('AzureTenantID', azureTenantID);
            }
            if (azureAuthenticationKey !== undefined) {
                localVarFormParams.set('AzureAuthenticationKey', azureAuthenticationKey);
            }
            if (tagIds) {
                tagIds.forEach((element) => {
                    localVarFormParams.append('TagIds', element);
                });
            }
            if (edgeCheckinInterval !== undefined) {
                localVarFormParams.set('EdgeCheckinInterval', edgeCheckinInterval);
            }
            if (edgeTunnelServerAddress !== undefined) {
                localVarFormParams.set('EdgeTunnelServerAddress', edgeTunnelServerAddress);
            }
            if (gpus !== undefined) {
                localVarFormParams.set('Gpus', gpus);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create or retrieve the endpoint for an EdgeID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreateGlobalKey(options = {}) {
            const localVarPath = `/endpoints/global-key`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an environment(endpoint). **Access policy**: administrator
         * @summary Remove an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointDelete.');
            }
            const localVarPath = `/endpoints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get docker pull limits for a docker hub registry in the environment **Access policy**:
         * @summary fetch docker pull limits
         * @param {number} id endpoint ID
         * @param {number} registryId registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDockerhubStatus(id, registryId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointDockerhubStatus.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId', 'Required parameter registryId was null or undefined when calling endpointDockerhubStatus.');
            }
            const localVarPath = `/endpoints/{id}/dockerhub/{registryId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * environment(endpoint) for edge agent to check status of environment(endpoint) **Access policy**: restricted only to Edge environments(endpoints)
         * @summary Get environment(endpoint) status
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointEdgeStatusInspect(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointEdgeStatusInspect.');
            }
            const localVarPath = `/endpoints/{id}/edge/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * force update a docker service **Access policy**: authenticated
         * @summary force update a docker service
         * @param {number} id endpoint identifier
         * @param {EndpointsForceUpdateServicePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointForceUpdateService(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointForceUpdateService.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling endpointForceUpdateService.');
            }
            const localVarPath = `/endpoints/{id}/forceupdateservice`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EndpointsForceUpdateServicePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about an environment(endpoint). **Access policy**: restricted
         * @summary Inspect an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointInspect(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointInspect.');
            }
            const localVarPath = `/endpoints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all environments(endpoints) based on the current user authorizations. Will return all environments(endpoints) if using an administrator or team leader account otherwise it will only return authorized environments(endpoints). **Access policy**: restricted
         * @summary List environments(endpoints)
         * @param {number} [start] Start searching from
         * @param {number} [limit] Limit results to this value
         * @param {number} [order] Order sorted results by desc/asc
         * @param {string} [search] Search query
         * @param {Array<number>} [groupIds] List environments(endpoints) of these groups
         * @param {Array<number>} [status] List environments(endpoints) by this status
         * @param {Array<number>} [types] List environments(endpoints) of this type
         * @param {Array<number>} [tagIds] search environments(endpoints) with these tags (depends on tagsPartialMatch)
         * @param {boolean} [tagsPartialMatch] If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags
         * @param {Array<number>} [endpointIds] will return only these environments(endpoints)
         * @param {boolean} [provisioned] If true, will return environment(endpoint) that were provisioned
         * @param {Array<string>} [agentVersions] will return only environments with on of these agent versions
         * @param {boolean} [edgeAsync] if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents)
         * @param {boolean} [edgeDeviceUntrusted] if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents)
         * @param {number} [edgeCheckInPassedSeconds] if bigger then zero, show only edge agents that checked-in in the last provided seconds (relevant only for edge agents)
         * @param {boolean} [excludeSnapshots] if true, the snapshot data won&#39;t be retrieved
         * @param {string} [name] will return only environments(endpoints) with this name
         * @param {string} [edgeStackStatus] only applied when edgeStackId exists. Filter the returned environments based on their deployment status in the stack (not the environment status!)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointList(start, limit, order, search, groupIds, status, types, tagIds, tagsPartialMatch, endpointIds, provisioned, agentVersions, edgeAsync, edgeDeviceUntrusted, edgeCheckInPassedSeconds, excludeSnapshots, name, edgeStackStatus, options = {}) {
            const localVarPath = `/endpoints`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (groupIds) {
                localVarQueryParameter['groupIds'] = groupIds;
            }
            if (status) {
                localVarQueryParameter['status'] = status;
            }
            if (types) {
                localVarQueryParameter['types'] = types;
            }
            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds;
            }
            if (tagsPartialMatch !== undefined) {
                localVarQueryParameter['tagsPartialMatch'] = tagsPartialMatch;
            }
            if (endpointIds) {
                localVarQueryParameter['endpointIds'] = endpointIds;
            }
            if (provisioned !== undefined) {
                localVarQueryParameter['provisioned'] = provisioned;
            }
            if (agentVersions) {
                localVarQueryParameter['agentVersions'] = agentVersions;
            }
            if (edgeAsync !== undefined) {
                localVarQueryParameter['edgeAsync'] = edgeAsync;
            }
            if (edgeDeviceUntrusted !== undefined) {
                localVarQueryParameter['edgeDeviceUntrusted'] = edgeDeviceUntrusted;
            }
            if (edgeCheckInPassedSeconds !== undefined) {
                localVarQueryParameter['edgeCheckInPassedSeconds'] = edgeCheckInPassedSeconds;
            }
            if (excludeSnapshots !== undefined) {
                localVarQueryParameter['excludeSnapshots'] = excludeSnapshots;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (edgeStackStatus !== undefined) {
                localVarQueryParameter['edgeStackStatus'] = edgeStackStatus;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all registries based on the current user authorizations in current environment. **Access policy**: authenticated
         * @summary List Registries on environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] required if kubernetes environment, will show registries by namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistriesList(id, namespace, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointRegistriesList.');
            }
            const localVarPath = `/endpoints/{id}/registries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary update registry access for environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {number} registryId Registry identifier
         * @param {EndpointsRegistryAccessPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistryAccess(id, registryId, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointRegistryAccess.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId', 'Required parameter registryId was null or undefined when calling endpointRegistryAccess.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling endpointRegistryAccess.');
            }
            const localVarPath = `/endpoints/{id}/registries/{registryId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EndpointsRegistryAccessPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update settings for an environment(endpoint). **Access policy**: authenticated
         * @summary Update settings for an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointSettingsUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSettingsUpdate(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointSettingsUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling endpointSettingsUpdate.');
            }
            const localVarPath = `/endpoints/{id}/settings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EndpointsEndpointSettingsUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Snapshots an environment(endpoint) **Access policy**: administrator
         * @summary Snapshots an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshot(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointSnapshot.');
            }
            const localVarPath = `/endpoints/{id}/snapshot`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Snapshot all environments(endpoints) **Access policy**: administrator
         * @summary Snapshot all environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshots(options = {}) {
            const localVarPath = `/endpoints/snapshot`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an environment(endpoint). **Access policy**: authenticated
         * @summary Update an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdate(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling endpointUpdate.');
            }
            const localVarPath = `/endpoints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EndpointsEndpointUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update relations for a list of environments Edge groups, tags and environment group can be updated.  **Access policy**: administrator
         * @summary Update relations for a list of environments
         * @param {EndpointsEndpointUpdateRelationsPayload} body Environment relations data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdateRelations(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling endpointUpdateRelations.');
            }
            const localVarPath = `/endpoints/relations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("EndpointsEndpointUpdateRelationsPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload a file under a specific path on the file system of an environment (endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} path The destination path to upload the file to
         * @param {any} file The file to upload
         * @param {string} [volumeID] Optional volume identifier to upload the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdDockerV2BrowsePutPost(id, path, file, volumeID, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointsIdDockerV2BrowsePutPost.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path', 'Required parameter path was null or undefined when calling endpointsIdDockerV2BrowsePutPost.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling endpointsIdDockerV2BrowsePutPost.');
            }
            const localVarPath = `/endpoints/{id}/docker/v2/browse/put`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (volumeID !== undefined) {
                localVarQueryParameter['volumeID'] = volumeID;
            }
            if (path !== undefined) {
                localVarFormParams.set('Path', path);
            }
            if (file !== undefined) {
                localVarFormParams.set('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointsIdEdgeJobsJobIDLogsPost.');
            }
            // verify required parameter 'jobID' is not null or undefined
            if (jobID === null || jobID === undefined) {
                throw new RequiredError('jobID', 'Required parameter jobID was null or undefined when calling endpointsIdEdgeJobsJobIDLogsPost.');
            }
            const localVarPath = `/endpoints/{id}/edge/jobs/{jobID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id, stackId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling endpointsIdEdgeStacksStackIdGet.');
            }
            // verify required parameter 'stackId' is not null or undefined
            if (stackId === null || stackId === undefined) {
                throw new RequiredError('stackId', 'Required parameter stackId was null or undefined when calling endpointsIdEdgeStacksStackIdGet.');
            }
            const localVarPath = `/endpoints/{id}/edge/stacks/{stackId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"stackId"}}`, encodeURIComponent(String(stackId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EndpointsApiFetchParamCreator = EndpointsApiFetchParamCreator;
/**
 * EndpointsApi - functional programming interface
 * @export
 */
const EndpointsApiFp = function (configuration) {
    return {
        /**
         * De-association an edge environment(endpoint). **Access policy**: administrator
         * @summary De-association an edge environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointAssociationDelete(id, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointAssociationDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new environment(endpoint) that will be used to manage an environment(endpoint). **Access policy**: administrator
         * @summary Create a new environment(endpoint)
         * @param {string} name Name that will be used to identify this environment(endpoint) (example: my-environment)
         * @param {number} endpointCreationType Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment)
         * @param {string} edgeTunnelServerAddress URL or IP address that will be used to establish a reverse tunnel
         * @param {string} [URL] URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment)
         * @param {string} [publicURL] URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375)
         * @param {number} [groupID] Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned).
         * @param {boolean} [TLS] Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipVerify] Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipClientVerify] Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {any} [tLSCACertFile] TLS CA certificate file
         * @param {any} [tLSCertFile] TLS client certificate file
         * @param {any} [tLSKeyFile] TLS client key file
         * @param {string} [azureApplicationID] Azure application ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureTenantID] Azure tenant ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureAuthenticationKey] Azure authentication key. Required if environment(endpoint) type is set to 3
         * @param {Array<number>} [tagIds] List of tag identifiers to which this environment(endpoint) is associated
         * @param {number} [edgeCheckinInterval] The check in interval for edge agent (in seconds)
         * @param {string} [gpus] List of GPUs - json stringified array of {name, value} structs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreate(name, endpointCreationType, edgeTunnelServerAddress, URL, publicURL, groupID, TLS, tLSSkipVerify, tLSSkipClientVerify, tLSCACertFile, tLSCertFile, tLSKeyFile, azureApplicationID, azureTenantID, azureAuthenticationKey, tagIds, edgeCheckinInterval, gpus, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointCreate(name, endpointCreationType, edgeTunnelServerAddress, URL, publicURL, groupID, TLS, tLSSkipVerify, tLSSkipClientVerify, tLSCACertFile, tLSCertFile, tLSKeyFile, azureApplicationID, azureTenantID, azureAuthenticationKey, tagIds, edgeCheckinInterval, gpus, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create or retrieve the endpoint for an EdgeID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreateGlobalKey(options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointCreateGlobalKey(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove an environment(endpoint). **Access policy**: administrator
         * @summary Remove an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDelete(id, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * get docker pull limits for a docker hub registry in the environment **Access policy**:
         * @summary fetch docker pull limits
         * @param {number} id endpoint ID
         * @param {number} registryId registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDockerhubStatus(id, registryId, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointDockerhubStatus(id, registryId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * environment(endpoint) for edge agent to check status of environment(endpoint) **Access policy**: restricted only to Edge environments(endpoints)
         * @summary Get environment(endpoint) status
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointEdgeStatusInspect(id, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointEdgeStatusInspect(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * force update a docker service **Access policy**: authenticated
         * @summary force update a docker service
         * @param {number} id endpoint identifier
         * @param {EndpointsForceUpdateServicePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointForceUpdateService(id, body, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointForceUpdateService(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details about an environment(endpoint). **Access policy**: restricted
         * @summary Inspect an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointInspect(id, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointInspect(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all environments(endpoints) based on the current user authorizations. Will return all environments(endpoints) if using an administrator or team leader account otherwise it will only return authorized environments(endpoints). **Access policy**: restricted
         * @summary List environments(endpoints)
         * @param {number} [start] Start searching from
         * @param {number} [limit] Limit results to this value
         * @param {number} [order] Order sorted results by desc/asc
         * @param {string} [search] Search query
         * @param {Array<number>} [groupIds] List environments(endpoints) of these groups
         * @param {Array<number>} [status] List environments(endpoints) by this status
         * @param {Array<number>} [types] List environments(endpoints) of this type
         * @param {Array<number>} [tagIds] search environments(endpoints) with these tags (depends on tagsPartialMatch)
         * @param {boolean} [tagsPartialMatch] If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags
         * @param {Array<number>} [endpointIds] will return only these environments(endpoints)
         * @param {boolean} [provisioned] If true, will return environment(endpoint) that were provisioned
         * @param {Array<string>} [agentVersions] will return only environments with on of these agent versions
         * @param {boolean} [edgeAsync] if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents)
         * @param {boolean} [edgeDeviceUntrusted] if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents)
         * @param {number} [edgeCheckInPassedSeconds] if bigger then zero, show only edge agents that checked-in in the last provided seconds (relevant only for edge agents)
         * @param {boolean} [excludeSnapshots] if true, the snapshot data won&#39;t be retrieved
         * @param {string} [name] will return only environments(endpoints) with this name
         * @param {string} [edgeStackStatus] only applied when edgeStackId exists. Filter the returned environments based on their deployment status in the stack (not the environment status!)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointList(start, limit, order, search, groupIds, status, types, tagIds, tagsPartialMatch, endpointIds, provisioned, agentVersions, edgeAsync, edgeDeviceUntrusted, edgeCheckInPassedSeconds, excludeSnapshots, name, edgeStackStatus, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointList(start, limit, order, search, groupIds, status, types, tagIds, tagsPartialMatch, endpointIds, provisioned, agentVersions, edgeAsync, edgeDeviceUntrusted, edgeCheckInPassedSeconds, excludeSnapshots, name, edgeStackStatus, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all registries based on the current user authorizations in current environment. **Access policy**: authenticated
         * @summary List Registries on environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] required if kubernetes environment, will show registries by namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistriesList(id, namespace, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointRegistriesList(id, namespace, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary update registry access for environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {number} registryId Registry identifier
         * @param {EndpointsRegistryAccessPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistryAccess(id, registryId, body, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointRegistryAccess(id, registryId, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update settings for an environment(endpoint). **Access policy**: authenticated
         * @summary Update settings for an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointSettingsUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSettingsUpdate(id, body, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointSettingsUpdate(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Snapshots an environment(endpoint) **Access policy**: administrator
         * @summary Snapshots an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshot(id, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointSnapshot(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Snapshot all environments(endpoints) **Access policy**: administrator
         * @summary Snapshot all environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshots(options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointSnapshots(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an environment(endpoint). **Access policy**: authenticated
         * @summary Update an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdate(id, body, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointUpdate(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update relations for a list of environments Edge groups, tags and environment group can be updated.  **Access policy**: administrator
         * @summary Update relations for a list of environments
         * @param {EndpointsEndpointUpdateRelationsPayload} body Environment relations data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdateRelations(body, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointUpdateRelations(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload a file under a specific path on the file system of an environment (endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} path The destination path to upload the file to
         * @param {any} file The file to upload
         * @param {string} [volumeID] Optional volume identifier to upload the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdDockerV2BrowsePutPost(id, path, file, volumeID, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointsIdDockerV2BrowsePutPost(id, path, file, volumeID, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id, stackId, options) {
            const localVarFetchArgs = (0, exports.EndpointsApiFetchParamCreator)(configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.EndpointsApiFp = EndpointsApiFp;
/**
 * EndpointsApi - factory interface
 * @export
 */
const EndpointsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * De-association an edge environment(endpoint). **Access policy**: administrator
         * @summary De-association an edge environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointAssociationDelete(id, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointAssociationDelete(id, options)(fetch, basePath);
        },
        /**
         * Create a new environment(endpoint) that will be used to manage an environment(endpoint). **Access policy**: administrator
         * @summary Create a new environment(endpoint)
         * @param {string} name Name that will be used to identify this environment(endpoint) (example: my-environment)
         * @param {number} endpointCreationType Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment)
         * @param {string} edgeTunnelServerAddress URL or IP address that will be used to establish a reverse tunnel
         * @param {string} [URL] URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment)
         * @param {string} [publicURL] URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375)
         * @param {number} [groupID] Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned).
         * @param {boolean} [TLS] Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipVerify] Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipClientVerify] Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {any} [tLSCACertFile] TLS CA certificate file
         * @param {any} [tLSCertFile] TLS client certificate file
         * @param {any} [tLSKeyFile] TLS client key file
         * @param {string} [azureApplicationID] Azure application ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureTenantID] Azure tenant ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureAuthenticationKey] Azure authentication key. Required if environment(endpoint) type is set to 3
         * @param {Array<number>} [tagIds] List of tag identifiers to which this environment(endpoint) is associated
         * @param {number} [edgeCheckinInterval] The check in interval for edge agent (in seconds)
         * @param {string} [gpus] List of GPUs - json stringified array of {name, value} structs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreate(name, endpointCreationType, edgeTunnelServerAddress, URL, publicURL, groupID, TLS, tLSSkipVerify, tLSSkipClientVerify, tLSCACertFile, tLSCertFile, tLSKeyFile, azureApplicationID, azureTenantID, azureAuthenticationKey, tagIds, edgeCheckinInterval, gpus, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointCreate(name, endpointCreationType, edgeTunnelServerAddress, URL, publicURL, groupID, TLS, tLSSkipVerify, tLSSkipClientVerify, tLSCACertFile, tLSCertFile, tLSKeyFile, azureApplicationID, azureTenantID, azureAuthenticationKey, tagIds, edgeCheckinInterval, gpus, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create or retrieve the endpoint for an EdgeID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreateGlobalKey(options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointCreateGlobalKey(options)(fetch, basePath);
        },
        /**
         * Remove an environment(endpoint). **Access policy**: administrator
         * @summary Remove an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDelete(id, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointDelete(id, options)(fetch, basePath);
        },
        /**
         * get docker pull limits for a docker hub registry in the environment **Access policy**:
         * @summary fetch docker pull limits
         * @param {number} id endpoint ID
         * @param {number} registryId registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDockerhubStatus(id, registryId, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointDockerhubStatus(id, registryId, options)(fetch, basePath);
        },
        /**
         * environment(endpoint) for edge agent to check status of environment(endpoint) **Access policy**: restricted only to Edge environments(endpoints)
         * @summary Get environment(endpoint) status
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointEdgeStatusInspect(id, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointEdgeStatusInspect(id, options)(fetch, basePath);
        },
        /**
         * force update a docker service **Access policy**: authenticated
         * @summary force update a docker service
         * @param {number} id endpoint identifier
         * @param {EndpointsForceUpdateServicePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointForceUpdateService(id, body, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointForceUpdateService(id, body, options)(fetch, basePath);
        },
        /**
         * Retrieve details about an environment(endpoint). **Access policy**: restricted
         * @summary Inspect an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointInspect(id, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointInspect(id, options)(fetch, basePath);
        },
        /**
         * List all environments(endpoints) based on the current user authorizations. Will return all environments(endpoints) if using an administrator or team leader account otherwise it will only return authorized environments(endpoints). **Access policy**: restricted
         * @summary List environments(endpoints)
         * @param {number} [start] Start searching from
         * @param {number} [limit] Limit results to this value
         * @param {number} [order] Order sorted results by desc/asc
         * @param {string} [search] Search query
         * @param {Array<number>} [groupIds] List environments(endpoints) of these groups
         * @param {Array<number>} [status] List environments(endpoints) by this status
         * @param {Array<number>} [types] List environments(endpoints) of this type
         * @param {Array<number>} [tagIds] search environments(endpoints) with these tags (depends on tagsPartialMatch)
         * @param {boolean} [tagsPartialMatch] If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags
         * @param {Array<number>} [endpointIds] will return only these environments(endpoints)
         * @param {boolean} [provisioned] If true, will return environment(endpoint) that were provisioned
         * @param {Array<string>} [agentVersions] will return only environments with on of these agent versions
         * @param {boolean} [edgeAsync] if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents)
         * @param {boolean} [edgeDeviceUntrusted] if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents)
         * @param {number} [edgeCheckInPassedSeconds] if bigger then zero, show only edge agents that checked-in in the last provided seconds (relevant only for edge agents)
         * @param {boolean} [excludeSnapshots] if true, the snapshot data won&#39;t be retrieved
         * @param {string} [name] will return only environments(endpoints) with this name
         * @param {string} [edgeStackStatus] only applied when edgeStackId exists. Filter the returned environments based on their deployment status in the stack (not the environment status!)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointList(start, limit, order, search, groupIds, status, types, tagIds, tagsPartialMatch, endpointIds, provisioned, agentVersions, edgeAsync, edgeDeviceUntrusted, edgeCheckInPassedSeconds, excludeSnapshots, name, edgeStackStatus, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointList(start, limit, order, search, groupIds, status, types, tagIds, tagsPartialMatch, endpointIds, provisioned, agentVersions, edgeAsync, edgeDeviceUntrusted, edgeCheckInPassedSeconds, excludeSnapshots, name, edgeStackStatus, options)(fetch, basePath);
        },
        /**
         * List all registries based on the current user authorizations in current environment. **Access policy**: authenticated
         * @summary List Registries on environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] required if kubernetes environment, will show registries by namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistriesList(id, namespace, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointRegistriesList(id, namespace, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary update registry access for environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {number} registryId Registry identifier
         * @param {EndpointsRegistryAccessPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistryAccess(id, registryId, body, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointRegistryAccess(id, registryId, body, options)(fetch, basePath);
        },
        /**
         * Update settings for an environment(endpoint). **Access policy**: authenticated
         * @summary Update settings for an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointSettingsUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSettingsUpdate(id, body, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointSettingsUpdate(id, body, options)(fetch, basePath);
        },
        /**
         * Snapshots an environment(endpoint) **Access policy**: administrator
         * @summary Snapshots an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshot(id, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointSnapshot(id, options)(fetch, basePath);
        },
        /**
         * Snapshot all environments(endpoints) **Access policy**: administrator
         * @summary Snapshot all environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshots(options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointSnapshots(options)(fetch, basePath);
        },
        /**
         * Update an environment(endpoint). **Access policy**: authenticated
         * @summary Update an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdate(id, body, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointUpdate(id, body, options)(fetch, basePath);
        },
        /**
         * Update relations for a list of environments Edge groups, tags and environment group can be updated.  **Access policy**: administrator
         * @summary Update relations for a list of environments
         * @param {EndpointsEndpointUpdateRelationsPayload} body Environment relations data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdateRelations(body, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointUpdateRelations(body, options)(fetch, basePath);
        },
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload a file under a specific path on the file system of an environment (endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} path The destination path to upload the file to
         * @param {any} file The file to upload
         * @param {string} [volumeID] Optional volume identifier to upload the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdDockerV2BrowsePutPost(id, path, file, volumeID, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointsIdDockerV2BrowsePutPost(id, path, file, volumeID, options)(fetch, basePath);
        },
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options)(fetch, basePath);
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id, stackId, options) {
            return (0, exports.EndpointsApiFp)(configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options)(fetch, basePath);
        },
    };
};
exports.EndpointsApiFactory = EndpointsApiFactory;
/**
 * EndpointsApi - object-oriented interface
 * @export
 * @class EndpointsApi
 * @extends {BaseAPI}
 */
class EndpointsApi extends BaseAPI {
    /**
     * De-association an edge environment(endpoint). **Access policy**: administrator
     * @summary De-association an edge environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointAssociationDelete(id, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointAssociationDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new environment(endpoint) that will be used to manage an environment(endpoint). **Access policy**: administrator
     * @summary Create a new environment(endpoint)
     * @param {string} name Name that will be used to identify this environment(endpoint) (example: my-environment)
     * @param {number} endpointCreationType Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment)
     * @param {string} edgeTunnelServerAddress URL or IP address that will be used to establish a reverse tunnel
     * @param {string} [URL] URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment)
     * @param {string} [publicURL] URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375)
     * @param {number} [groupID] Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned).
     * @param {boolean} [TLS] Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment)
     * @param {boolean} [tLSSkipVerify] Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
     * @param {boolean} [tLSSkipClientVerify] Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
     * @param {any} [tLSCACertFile] TLS CA certificate file
     * @param {any} [tLSCertFile] TLS client certificate file
     * @param {any} [tLSKeyFile] TLS client key file
     * @param {string} [azureApplicationID] Azure application ID. Required if environment(endpoint) type is set to 3
     * @param {string} [azureTenantID] Azure tenant ID. Required if environment(endpoint) type is set to 3
     * @param {string} [azureAuthenticationKey] Azure authentication key. Required if environment(endpoint) type is set to 3
     * @param {Array<number>} [tagIds] List of tag identifiers to which this environment(endpoint) is associated
     * @param {number} [edgeCheckinInterval] The check in interval for edge agent (in seconds)
     * @param {string} [gpus] List of GPUs - json stringified array of {name, value} structs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointCreate(name, endpointCreationType, edgeTunnelServerAddress, URL, publicURL, groupID, TLS, tLSSkipVerify, tLSSkipClientVerify, tLSCACertFile, tLSCertFile, tLSKeyFile, azureApplicationID, azureTenantID, azureAuthenticationKey, tagIds, edgeCheckinInterval, gpus, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointCreate(name, endpointCreationType, edgeTunnelServerAddress, URL, publicURL, groupID, TLS, tLSSkipVerify, tLSSkipClientVerify, tLSCACertFile, tLSCertFile, tLSKeyFile, azureApplicationID, azureTenantID, azureAuthenticationKey, tagIds, edgeCheckinInterval, gpus, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create or retrieve the endpoint for an EdgeID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointCreateGlobalKey(options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointCreateGlobalKey(options)(this.fetch, this.basePath);
    }
    /**
     * Remove an environment(endpoint). **Access policy**: administrator
     * @summary Remove an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointDelete(id, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     * get docker pull limits for a docker hub registry in the environment **Access policy**:
     * @summary fetch docker pull limits
     * @param {number} id endpoint ID
     * @param {number} registryId registry ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointDockerhubStatus(id, registryId, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointDockerhubStatus(id, registryId, options)(this.fetch, this.basePath);
    }
    /**
     * environment(endpoint) for edge agent to check status of environment(endpoint) **Access policy**: restricted only to Edge environments(endpoints)
     * @summary Get environment(endpoint) status
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointEdgeStatusInspect(id, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointEdgeStatusInspect(id, options)(this.fetch, this.basePath);
    }
    /**
     * force update a docker service **Access policy**: authenticated
     * @summary force update a docker service
     * @param {number} id endpoint identifier
     * @param {EndpointsForceUpdateServicePayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointForceUpdateService(id, body, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointForceUpdateService(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve details about an environment(endpoint). **Access policy**: restricted
     * @summary Inspect an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointInspect(id, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointInspect(id, options)(this.fetch, this.basePath);
    }
    /**
     * List all environments(endpoints) based on the current user authorizations. Will return all environments(endpoints) if using an administrator or team leader account otherwise it will only return authorized environments(endpoints). **Access policy**: restricted
     * @summary List environments(endpoints)
     * @param {number} [start] Start searching from
     * @param {number} [limit] Limit results to this value
     * @param {number} [order] Order sorted results by desc/asc
     * @param {string} [search] Search query
     * @param {Array<number>} [groupIds] List environments(endpoints) of these groups
     * @param {Array<number>} [status] List environments(endpoints) by this status
     * @param {Array<number>} [types] List environments(endpoints) of this type
     * @param {Array<number>} [tagIds] search environments(endpoints) with these tags (depends on tagsPartialMatch)
     * @param {boolean} [tagsPartialMatch] If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags
     * @param {Array<number>} [endpointIds] will return only these environments(endpoints)
     * @param {boolean} [provisioned] If true, will return environment(endpoint) that were provisioned
     * @param {Array<string>} [agentVersions] will return only environments with on of these agent versions
     * @param {boolean} [edgeAsync] if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents)
     * @param {boolean} [edgeDeviceUntrusted] if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents)
     * @param {number} [edgeCheckInPassedSeconds] if bigger then zero, show only edge agents that checked-in in the last provided seconds (relevant only for edge agents)
     * @param {boolean} [excludeSnapshots] if true, the snapshot data won&#39;t be retrieved
     * @param {string} [name] will return only environments(endpoints) with this name
     * @param {string} [edgeStackStatus] only applied when edgeStackId exists. Filter the returned environments based on their deployment status in the stack (not the environment status!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointList(start, limit, order, search, groupIds, status, types, tagIds, tagsPartialMatch, endpointIds, provisioned, agentVersions, edgeAsync, edgeDeviceUntrusted, edgeCheckInPassedSeconds, excludeSnapshots, name, edgeStackStatus, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointList(start, limit, order, search, groupIds, status, types, tagIds, tagsPartialMatch, endpointIds, provisioned, agentVersions, edgeAsync, edgeDeviceUntrusted, edgeCheckInPassedSeconds, excludeSnapshots, name, edgeStackStatus, options)(this.fetch, this.basePath);
    }
    /**
     * List all registries based on the current user authorizations in current environment. **Access policy**: authenticated
     * @summary List Registries on environment
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} [namespace] required if kubernetes environment, will show registries by namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointRegistriesList(id, namespace, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointRegistriesList(id, namespace, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: authenticated
     * @summary update registry access for environment
     * @param {number} id Environment(Endpoint) identifier
     * @param {number} registryId Registry identifier
     * @param {EndpointsRegistryAccessPayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointRegistryAccess(id, registryId, body, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointRegistryAccess(id, registryId, body, options)(this.fetch, this.basePath);
    }
    /**
     * Update settings for an environment(endpoint). **Access policy**: authenticated
     * @summary Update settings for an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {EndpointsEndpointSettingsUpdatePayload} body Environment(Endpoint) details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointSettingsUpdate(id, body, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointSettingsUpdate(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * Snapshots an environment(endpoint) **Access policy**: administrator
     * @summary Snapshots an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointSnapshot(id, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointSnapshot(id, options)(this.fetch, this.basePath);
    }
    /**
     * Snapshot all environments(endpoints) **Access policy**: administrator
     * @summary Snapshot all environments(endpoints)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointSnapshots(options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointSnapshots(options)(this.fetch, this.basePath);
    }
    /**
     * Update an environment(endpoint). **Access policy**: authenticated
     * @summary Update an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {EndpointsEndpointUpdatePayload} body Environment(Endpoint) details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointUpdate(id, body, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointUpdate(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * Update relations for a list of environments Edge groups, tags and environment group can be updated.  **Access policy**: administrator
     * @summary Update relations for a list of environments
     * @param {EndpointsEndpointUpdateRelationsPayload} body Environment relations data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointUpdateRelations(body, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointUpdateRelations(body, options)(this.fetch, this.basePath);
    }
    /**
     * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
     * @summary Upload a file under a specific path on the file system of an environment (endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} path The destination path to upload the file to
     * @param {any} file The file to upload
     * @param {string} [volumeID] Optional volume identifier to upload the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointsIdDockerV2BrowsePutPost(id, path, file, volumeID, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointsIdDockerV2BrowsePutPost(id, path, file, volumeID, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: public
     * @summary Inspect an EdgeJob Log
     * @param {number} id environment(endpoint) Id
     * @param {number} jobID Job Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: public
     * @summary Inspect an Edge Stack for an Environment(Endpoint)
     * @param {number} id environment(endpoint) Id
     * @param {number} stackId EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    endpointsIdEdgeStacksStackIdGet(id, stackId, options) {
        return (0, exports.EndpointsApiFp)(this.configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options)(this.fetch, this.basePath);
    }
}
exports.EndpointsApi = EndpointsApi;
/**
 * GitopsApi - fetch parameter creator
 * @export
 */
const GitopsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Retrieve the compose file content based on git repository configuration **Access policy**: authenticated
         * @summary preview the content of target file in the git repository
         * @param {GitopsRepositoryFilePreviewPayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitOperationRepoFilePreview(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling gitOperationRepoFilePreview.');
            }
            const localVarPath = `/gitops/repo/file/preview`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("GitopsRepositoryFilePreviewPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.GitopsApiFetchParamCreator = GitopsApiFetchParamCreator;
/**
 * GitopsApi - functional programming interface
 * @export
 */
const GitopsApiFp = function (configuration) {
    return {
        /**
         * Retrieve the compose file content based on git repository configuration **Access policy**: authenticated
         * @summary preview the content of target file in the git repository
         * @param {GitopsRepositoryFilePreviewPayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitOperationRepoFilePreview(body, options) {
            const localVarFetchArgs = (0, exports.GitopsApiFetchParamCreator)(configuration).gitOperationRepoFilePreview(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.GitopsApiFp = GitopsApiFp;
/**
 * GitopsApi - factory interface
 * @export
 */
const GitopsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Retrieve the compose file content based on git repository configuration **Access policy**: authenticated
         * @summary preview the content of target file in the git repository
         * @param {GitopsRepositoryFilePreviewPayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitOperationRepoFilePreview(body, options) {
            return (0, exports.GitopsApiFp)(configuration).gitOperationRepoFilePreview(body, options)(fetch, basePath);
        },
    };
};
exports.GitopsApiFactory = GitopsApiFactory;
/**
 * GitopsApi - object-oriented interface
 * @export
 * @class GitopsApi
 * @extends {BaseAPI}
 */
class GitopsApi extends BaseAPI {
    /**
     * Retrieve the compose file content based on git repository configuration **Access policy**: authenticated
     * @summary preview the content of target file in the git repository
     * @param {GitopsRepositoryFilePreviewPayload} body Template details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitopsApi
     */
    gitOperationRepoFilePreview(body, options) {
        return (0, exports.GitopsApiFp)(this.configuration).gitOperationRepoFilePreview(body, options)(this.fetch, this.basePath);
    }
}
exports.GitopsApi = GitopsApi;
/**
 * HelmApi - fetch parameter creator
 * @export
 */
const HelmApiFetchParamCreator = function (configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary Delete Helm Release
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} release The name of the release/application to uninstall
         * @param {string} [namespace] An optional namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmDelete(id, release, namespace, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling helmDelete.');
            }
            // verify required parameter 'release' is not null or undefined
            if (release === null || release === undefined) {
                throw new RequiredError('release', 'Required parameter release was null or undefined when calling helmDelete.');
            }
            const localVarPath = `/endpoints/{id}/kubernetes/helm/{release}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"release"}}`, encodeURIComponent(String(release)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Install Helm Chart
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmInstallChartPayload} payload Chart details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmInstall(id, payload, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling helmInstall.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload', 'Required parameter payload was null or undefined when calling helmInstall.');
            }
            const localVarPath = `/endpoints/{id}/kubernetes/helm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("HelmInstallChartPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(payload || {}) : (payload || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary List Helm Releases
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] specify an optional namespace
         * @param {string} [filter] specify an optional filter
         * @param {string} [selector] specify an optional selector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmList(id, namespace, filter, selector, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling helmList.');
            }
            const localVarPath = `/endpoints/{id}/kubernetes/helm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }
            if (selector !== undefined) {
                localVarQueryParameter['selector'] = selector;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Search Helm Charts
         * @param {string} repo Helm repository URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmRepoSearch(repo, options = {}) {
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo', 'Required parameter repo was null or undefined when calling helmRepoSearch.');
            }
            const localVarPath = `/templates/helm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (repo !== undefined) {
                localVarQueryParameter['repo'] = repo;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Show Helm Chart Information
         * @param {string} repo Helm repository URL
         * @param {string} chart Chart name
         * @param {string} command chart/values/readme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmShow(repo, chart, command, options = {}) {
            // verify required parameter 'repo' is not null or undefined
            if (repo === null || repo === undefined) {
                throw new RequiredError('repo', 'Required parameter repo was null or undefined when calling helmShow.');
            }
            // verify required parameter 'chart' is not null or undefined
            if (chart === null || chart === undefined) {
                throw new RequiredError('chart', 'Required parameter chart was null or undefined when calling helmShow.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command', 'Required parameter command was null or undefined when calling helmShow.');
            }
            const localVarPath = `/templates/helm/{command}`
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (repo !== undefined) {
                localVarQueryParameter['repo'] = repo;
            }
            if (chart !== undefined) {
                localVarQueryParameter['chart'] = chart;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoriesList(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling helmUserRepositoriesList.');
            }
            const localVarPath = `/users/{id}/helm/repositories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoriesListDeprecated(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling helmUserRepositoriesListDeprecated.');
            }
            const localVarPath = `/endpoints/{id}/kubernetes/helm/repositories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id User identifier
         * @param {UsersAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryCreate(id, payload, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling helmUserRepositoryCreate.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload', 'Required parameter payload was null or undefined when calling helmUserRepositoryCreate.');
            }
            const localVarPath = `/users/{id}/helm/repositories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("UsersAddHelmRepoUrlPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(payload || {}) : (payload || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryCreateDeprecated(id, payload, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling helmUserRepositoryCreateDeprecated.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload', 'Required parameter payload was null or undefined when calling helmUserRepositoryCreateDeprecated.');
            }
            const localVarPath = `/endpoints/{id}/kubernetes/helm/repositories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("HelmAddHelmRepoUrlPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(payload || {}) : (payload || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a users helm repositoryies
         * @param {number} id User identifier
         * @param {number} repositoryID Repository identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryDelete(id, repositoryID, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling helmUserRepositoryDelete.');
            }
            // verify required parameter 'repositoryID' is not null or undefined
            if (repositoryID === null || repositoryID === undefined) {
                throw new RequiredError('repositoryID', 'Required parameter repositoryID was null or undefined when calling helmUserRepositoryDelete.');
            }
            const localVarPath = `/users/{id}/helm/repositories/{repositoryID}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"repositoryID"}}`, encodeURIComponent(String(repositoryID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.HelmApiFetchParamCreator = HelmApiFetchParamCreator;
/**
 * HelmApi - functional programming interface
 * @export
 */
const HelmApiFp = function (configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary Delete Helm Release
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} release The name of the release/application to uninstall
         * @param {string} [namespace] An optional namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmDelete(id, release, namespace, options) {
            const localVarFetchArgs = (0, exports.HelmApiFetchParamCreator)(configuration).helmDelete(id, release, namespace, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Install Helm Chart
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmInstallChartPayload} payload Chart details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmInstall(id, payload, options) {
            const localVarFetchArgs = (0, exports.HelmApiFetchParamCreator)(configuration).helmInstall(id, payload, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary List Helm Releases
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] specify an optional namespace
         * @param {string} [filter] specify an optional filter
         * @param {string} [selector] specify an optional selector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmList(id, namespace, filter, selector, options) {
            const localVarFetchArgs = (0, exports.HelmApiFetchParamCreator)(configuration).helmList(id, namespace, filter, selector, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Search Helm Charts
         * @param {string} repo Helm repository URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmRepoSearch(repo, options) {
            const localVarFetchArgs = (0, exports.HelmApiFetchParamCreator)(configuration).helmRepoSearch(repo, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Show Helm Chart Information
         * @param {string} repo Helm repository URL
         * @param {string} chart Chart name
         * @param {string} command chart/values/readme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmShow(repo, chart, command, options) {
            const localVarFetchArgs = (0, exports.HelmApiFetchParamCreator)(configuration).helmShow(repo, chart, command, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoriesList(id, options) {
            const localVarFetchArgs = (0, exports.HelmApiFetchParamCreator)(configuration).helmUserRepositoriesList(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoriesListDeprecated(id, options) {
            const localVarFetchArgs = (0, exports.HelmApiFetchParamCreator)(configuration).helmUserRepositoriesListDeprecated(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id User identifier
         * @param {UsersAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryCreate(id, payload, options) {
            const localVarFetchArgs = (0, exports.HelmApiFetchParamCreator)(configuration).helmUserRepositoryCreate(id, payload, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryCreateDeprecated(id, payload, options) {
            const localVarFetchArgs = (0, exports.HelmApiFetchParamCreator)(configuration).helmUserRepositoryCreateDeprecated(id, payload, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a users helm repositoryies
         * @param {number} id User identifier
         * @param {number} repositoryID Repository identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryDelete(id, repositoryID, options) {
            const localVarFetchArgs = (0, exports.HelmApiFetchParamCreator)(configuration).helmUserRepositoryDelete(id, repositoryID, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.HelmApiFp = HelmApiFp;
/**
 * HelmApi - factory interface
 * @export
 */
const HelmApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary Delete Helm Release
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} release The name of the release/application to uninstall
         * @param {string} [namespace] An optional namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmDelete(id, release, namespace, options) {
            return (0, exports.HelmApiFp)(configuration).helmDelete(id, release, namespace, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Install Helm Chart
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmInstallChartPayload} payload Chart details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmInstall(id, payload, options) {
            return (0, exports.HelmApiFp)(configuration).helmInstall(id, payload, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary List Helm Releases
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] specify an optional namespace
         * @param {string} [filter] specify an optional filter
         * @param {string} [selector] specify an optional selector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmList(id, namespace, filter, selector, options) {
            return (0, exports.HelmApiFp)(configuration).helmList(id, namespace, filter, selector, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Search Helm Charts
         * @param {string} repo Helm repository URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmRepoSearch(repo, options) {
            return (0, exports.HelmApiFp)(configuration).helmRepoSearch(repo, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Show Helm Chart Information
         * @param {string} repo Helm repository URL
         * @param {string} chart Chart name
         * @param {string} command chart/values/readme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmShow(repo, chart, command, options) {
            return (0, exports.HelmApiFp)(configuration).helmShow(repo, chart, command, options)(fetch, basePath);
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoriesList(id, options) {
            return (0, exports.HelmApiFp)(configuration).helmUserRepositoriesList(id, options)(fetch, basePath);
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoriesListDeprecated(id, options) {
            return (0, exports.HelmApiFp)(configuration).helmUserRepositoriesListDeprecated(id, options)(fetch, basePath);
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id User identifier
         * @param {UsersAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryCreate(id, payload, options) {
            return (0, exports.HelmApiFp)(configuration).helmUserRepositoryCreate(id, payload, options)(fetch, basePath);
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryCreateDeprecated(id, payload, options) {
            return (0, exports.HelmApiFp)(configuration).helmUserRepositoryCreateDeprecated(id, payload, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a users helm repositoryies
         * @param {number} id User identifier
         * @param {number} repositoryID Repository identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryDelete(id, repositoryID, options) {
            return (0, exports.HelmApiFp)(configuration).helmUserRepositoryDelete(id, repositoryID, options)(fetch, basePath);
        },
    };
};
exports.HelmApiFactory = HelmApiFactory;
/**
 * HelmApi - object-oriented interface
 * @export
 * @class HelmApi
 * @extends {BaseAPI}
 */
class HelmApi extends BaseAPI {
    /**
     * **Access policy**: authenticated
     * @summary Delete Helm Release
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} release The name of the release/application to uninstall
     * @param {string} [namespace] An optional namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    helmDelete(id, release, namespace, options) {
        return (0, exports.HelmApiFp)(this.configuration).helmDelete(id, release, namespace, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: authenticated
     * @summary Install Helm Chart
     * @param {number} id Environment(Endpoint) identifier
     * @param {HelmInstallChartPayload} payload Chart details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    helmInstall(id, payload, options) {
        return (0, exports.HelmApiFp)(this.configuration).helmInstall(id, payload, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: authenticated
     * @summary List Helm Releases
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} [namespace] specify an optional namespace
     * @param {string} [filter] specify an optional filter
     * @param {string} [selector] specify an optional selector
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    helmList(id, namespace, filter, selector, options) {
        return (0, exports.HelmApiFp)(this.configuration).helmList(id, namespace, filter, selector, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: authenticated
     * @summary Search Helm Charts
     * @param {string} repo Helm repository URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    helmRepoSearch(repo, options) {
        return (0, exports.HelmApiFp)(this.configuration).helmRepoSearch(repo, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: authenticated
     * @summary Show Helm Chart Information
     * @param {string} repo Helm repository URL
     * @param {string} chart Chart name
     * @param {string} command chart/values/readme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    helmShow(repo, chart, command, options) {
        return (0, exports.HelmApiFp)(this.configuration).helmShow(repo, chart, command, options)(this.fetch, this.basePath);
    }
    /**
     * Inspect a user helm repositories. **Access policy**: authenticated
     * @summary List a users helm repositories
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    helmUserRepositoriesList(id, options) {
        return (0, exports.HelmApiFp)(this.configuration).helmUserRepositoriesList(id, options)(this.fetch, this.basePath);
    }
    /**
     * Inspect a user helm repositories. **Access policy**: authenticated
     * @summary List a users helm repositories
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    helmUserRepositoriesListDeprecated(id, options) {
        return (0, exports.HelmApiFp)(this.configuration).helmUserRepositoriesListDeprecated(id, options)(this.fetch, this.basePath);
    }
    /**
     * Create a user helm repository. **Access policy**: authenticated
     * @summary Create a user helm repository
     * @param {number} id User identifier
     * @param {UsersAddHelmRepoUrlPayload} payload Helm Repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    helmUserRepositoryCreate(id, payload, options) {
        return (0, exports.HelmApiFp)(this.configuration).helmUserRepositoryCreate(id, payload, options)(this.fetch, this.basePath);
    }
    /**
     * Create a user helm repository. **Access policy**: authenticated
     * @summary Create a user helm repository
     * @param {number} id Environment(Endpoint) identifier
     * @param {HelmAddHelmRepoUrlPayload} payload Helm Repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    helmUserRepositoryCreateDeprecated(id, payload, options) {
        return (0, exports.HelmApiFp)(this.configuration).helmUserRepositoryCreateDeprecated(id, payload, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: authenticated
     * @summary Delete a users helm repositoryies
     * @param {number} id User identifier
     * @param {number} repositoryID Repository identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    helmUserRepositoryDelete(id, repositoryID, options) {
        return (0, exports.HelmApiFp)(this.configuration).helmUserRepositoryDelete(id, repositoryID, options)(this.fetch, this.basePath);
    }
}
exports.HelmApi = HelmApi;
/**
 * IntelApi - fetch parameter creator
 * @export
 */
const IntelApiFetchParamCreator = function (configuration) {
    return {
        /**
         * creates a new FDO Profile **Access policy**: administrator
         * @summary creates a new FDO Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(options = {}) {
            const localVarPath = `/fdo/profiles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * deletes a FDO Profile **Access policy**: administrator
         * @summary deletes a FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteProfile.');
            }
            const localVarPath = `/fdo/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute out of band action on an AMT managed device **Access policy**: administrator
         * @summary Execute out of band action on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceActionPayload} body Device Action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAction(id, deviceId, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deviceAction.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId', 'Required parameter deviceId was null or undefined when calling deviceAction.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling deviceAction.');
            }
            const localVarPath = `/open_amt/{id}/devices/{deviceId}/action`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("OpenamtDeviceActionPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable features on an AMT managed device **Access policy**: administrator
         * @summary Enable features on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceFeaturesPayload} body Device Features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceFeatures(id, deviceId, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deviceFeatures.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId', 'Required parameter deviceId was null or undefined when calling deviceFeatures.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling deviceFeatures.');
            }
            const localVarPath = `/open_amt/{id}/devices_features/{deviceId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("OpenamtDeviceFeaturesPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * duplicated an existing FDO Profile **Access policy**: administrator
         * @summary duplicated an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicate(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling duplicate.');
            }
            const localVarPath = `/fdo/profiles/{id}/duplicate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable Portainer's FDO capabilities **Access policy**: administrator
         * @summary Enable Portainer's FDO capabilities
         * @param {FdoFdoConfigurePayload} body FDO Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigure(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling fdoConfigure.');
            }
            const localVarPath = `/fdo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("FdoFdoConfigurePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * configures an FDO device **Access policy**: administrator
         * @summary configures an FDO device
         * @param {number} guid Guid
         * @param {FdoDeviceConfigurePayload} body Device Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigureDevice(guid, body, options = {}) {
            // verify required parameter 'guid' is not null or undefined
            if (guid === null || guid === undefined) {
                throw new RequiredError('guid', 'Required parameter guid was null or undefined when calling fdoConfigureDevice.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling fdoConfigureDevice.');
            }
            const localVarPath = `/fdo/configure/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("FdoDeviceConfigurePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all known FDO vouchers **Access policy**: administrator
         * @summary List all known FDO vouchers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoListAll(options = {}) {
            const localVarPath = `/fdo/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * retrieves a given FDO profile information and content **Access policy**: administrator
         * @summary retrieves a given FDO profile information and content
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileInspect(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling fdoProfileInspect.');
            }
            const localVarPath = `/fdo/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * retrieves all FDO profiles **Access policy**: administrator
         * @summary retrieves all FDO profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileList(options = {}) {
            const localVarPath = `/fdo/profiles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * register an FDO device **Access policy**: administrator
         * @summary register an FDO device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoRegisterDevice(options = {}) {
            const localVarPath = `/fdo/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activate OpenAMT device and associate to agent endpoint **Access policy**: administrator
         * @summary Activate OpenAMT device and associate to agent endpoint
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTActivate(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling openAMTActivate.');
            }
            const localVarPath = `/open_amt/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable Portainer's OpenAMT capabilities **Access policy**: administrator
         * @summary Enable Portainer's OpenAMT capabilities
         * @param {OpenamtOpenAMTConfigurePayload} body OpenAMT Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTConfigure(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling openAMTConfigure.');
            }
            const localVarPath = `/open_amt`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("OpenamtOpenAMTConfigurePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch OpenAMT managed devices information for endpoint **Access policy**: administrator
         * @summary Fetch OpenAMT managed devices information for endpoint
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTDevices(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling openAMTDevices.');
            }
            const localVarPath = `/open_amt/{id}/devices`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request OpenAMT info from a node **Access policy**: administrator
         * @summary Request OpenAMT info from a node
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTHostInfo(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling openAMTHostInfo.');
            }
            const localVarPath = `/open_amt/{id}/info`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * updates an existing FDO Profile **Access policy**: administrator
         * @summary updates an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateProfile.');
            }
            const localVarPath = `/fdo/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.IntelApiFetchParamCreator = IntelApiFetchParamCreator;
/**
 * IntelApi - functional programming interface
 * @export
 */
const IntelApiFp = function (configuration) {
    return {
        /**
         * creates a new FDO Profile **Access policy**: administrator
         * @summary creates a new FDO Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).createProfile(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * deletes a FDO Profile **Access policy**: administrator
         * @summary deletes a FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(id, options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).deleteProfile(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Execute out of band action on an AMT managed device **Access policy**: administrator
         * @summary Execute out of band action on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceActionPayload} body Device Action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAction(id, deviceId, body, options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).deviceAction(id, deviceId, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enable features on an AMT managed device **Access policy**: administrator
         * @summary Enable features on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceFeaturesPayload} body Device Features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceFeatures(id, deviceId, body, options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).deviceFeatures(id, deviceId, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * duplicated an existing FDO Profile **Access policy**: administrator
         * @summary duplicated an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicate(id, options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).duplicate(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enable Portainer's FDO capabilities **Access policy**: administrator
         * @summary Enable Portainer's FDO capabilities
         * @param {FdoFdoConfigurePayload} body FDO Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigure(body, options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).fdoConfigure(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * configures an FDO device **Access policy**: administrator
         * @summary configures an FDO device
         * @param {number} guid Guid
         * @param {FdoDeviceConfigurePayload} body Device Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigureDevice(guid, body, options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).fdoConfigureDevice(guid, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all known FDO vouchers **Access policy**: administrator
         * @summary List all known FDO vouchers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoListAll(options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).fdoListAll(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * retrieves a given FDO profile information and content **Access policy**: administrator
         * @summary retrieves a given FDO profile information and content
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileInspect(id, options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).fdoProfileInspect(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * retrieves all FDO profiles **Access policy**: administrator
         * @summary retrieves all FDO profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileList(options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).fdoProfileList(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * register an FDO device **Access policy**: administrator
         * @summary register an FDO device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoRegisterDevice(options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).fdoRegisterDevice(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Activate OpenAMT device and associate to agent endpoint **Access policy**: administrator
         * @summary Activate OpenAMT device and associate to agent endpoint
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTActivate(id, options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).openAMTActivate(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Enable Portainer's OpenAMT capabilities **Access policy**: administrator
         * @summary Enable Portainer's OpenAMT capabilities
         * @param {OpenamtOpenAMTConfigurePayload} body OpenAMT Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTConfigure(body, options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).openAMTConfigure(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch OpenAMT managed devices information for endpoint **Access policy**: administrator
         * @summary Fetch OpenAMT managed devices information for endpoint
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTDevices(id, options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).openAMTDevices(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Request OpenAMT info from a node **Access policy**: administrator
         * @summary Request OpenAMT info from a node
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTHostInfo(id, options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).openAMTHostInfo(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * updates an existing FDO Profile **Access policy**: administrator
         * @summary updates an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(id, options) {
            const localVarFetchArgs = (0, exports.IntelApiFetchParamCreator)(configuration).updateProfile(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.IntelApiFp = IntelApiFp;
/**
 * IntelApi - factory interface
 * @export
 */
const IntelApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * creates a new FDO Profile **Access policy**: administrator
         * @summary creates a new FDO Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(options) {
            return (0, exports.IntelApiFp)(configuration).createProfile(options)(fetch, basePath);
        },
        /**
         * deletes a FDO Profile **Access policy**: administrator
         * @summary deletes a FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(id, options) {
            return (0, exports.IntelApiFp)(configuration).deleteProfile(id, options)(fetch, basePath);
        },
        /**
         * Execute out of band action on an AMT managed device **Access policy**: administrator
         * @summary Execute out of band action on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceActionPayload} body Device Action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAction(id, deviceId, body, options) {
            return (0, exports.IntelApiFp)(configuration).deviceAction(id, deviceId, body, options)(fetch, basePath);
        },
        /**
         * Enable features on an AMT managed device **Access policy**: administrator
         * @summary Enable features on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceFeaturesPayload} body Device Features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceFeatures(id, deviceId, body, options) {
            return (0, exports.IntelApiFp)(configuration).deviceFeatures(id, deviceId, body, options)(fetch, basePath);
        },
        /**
         * duplicated an existing FDO Profile **Access policy**: administrator
         * @summary duplicated an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicate(id, options) {
            return (0, exports.IntelApiFp)(configuration).duplicate(id, options)(fetch, basePath);
        },
        /**
         * Enable Portainer's FDO capabilities **Access policy**: administrator
         * @summary Enable Portainer's FDO capabilities
         * @param {FdoFdoConfigurePayload} body FDO Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigure(body, options) {
            return (0, exports.IntelApiFp)(configuration).fdoConfigure(body, options)(fetch, basePath);
        },
        /**
         * configures an FDO device **Access policy**: administrator
         * @summary configures an FDO device
         * @param {number} guid Guid
         * @param {FdoDeviceConfigurePayload} body Device Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigureDevice(guid, body, options) {
            return (0, exports.IntelApiFp)(configuration).fdoConfigureDevice(guid, body, options)(fetch, basePath);
        },
        /**
         * List all known FDO vouchers **Access policy**: administrator
         * @summary List all known FDO vouchers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoListAll(options) {
            return (0, exports.IntelApiFp)(configuration).fdoListAll(options)(fetch, basePath);
        },
        /**
         * retrieves a given FDO profile information and content **Access policy**: administrator
         * @summary retrieves a given FDO profile information and content
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileInspect(id, options) {
            return (0, exports.IntelApiFp)(configuration).fdoProfileInspect(id, options)(fetch, basePath);
        },
        /**
         * retrieves all FDO profiles **Access policy**: administrator
         * @summary retrieves all FDO profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileList(options) {
            return (0, exports.IntelApiFp)(configuration).fdoProfileList(options)(fetch, basePath);
        },
        /**
         * register an FDO device **Access policy**: administrator
         * @summary register an FDO device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoRegisterDevice(options) {
            return (0, exports.IntelApiFp)(configuration).fdoRegisterDevice(options)(fetch, basePath);
        },
        /**
         * Activate OpenAMT device and associate to agent endpoint **Access policy**: administrator
         * @summary Activate OpenAMT device and associate to agent endpoint
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTActivate(id, options) {
            return (0, exports.IntelApiFp)(configuration).openAMTActivate(id, options)(fetch, basePath);
        },
        /**
         * Enable Portainer's OpenAMT capabilities **Access policy**: administrator
         * @summary Enable Portainer's OpenAMT capabilities
         * @param {OpenamtOpenAMTConfigurePayload} body OpenAMT Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTConfigure(body, options) {
            return (0, exports.IntelApiFp)(configuration).openAMTConfigure(body, options)(fetch, basePath);
        },
        /**
         * Fetch OpenAMT managed devices information for endpoint **Access policy**: administrator
         * @summary Fetch OpenAMT managed devices information for endpoint
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTDevices(id, options) {
            return (0, exports.IntelApiFp)(configuration).openAMTDevices(id, options)(fetch, basePath);
        },
        /**
         * Request OpenAMT info from a node **Access policy**: administrator
         * @summary Request OpenAMT info from a node
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTHostInfo(id, options) {
            return (0, exports.IntelApiFp)(configuration).openAMTHostInfo(id, options)(fetch, basePath);
        },
        /**
         * updates an existing FDO Profile **Access policy**: administrator
         * @summary updates an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(id, options) {
            return (0, exports.IntelApiFp)(configuration).updateProfile(id, options)(fetch, basePath);
        },
    };
};
exports.IntelApiFactory = IntelApiFactory;
/**
 * IntelApi - object-oriented interface
 * @export
 * @class IntelApi
 * @extends {BaseAPI}
 */
class IntelApi extends BaseAPI {
    /**
     * creates a new FDO Profile **Access policy**: administrator
     * @summary creates a new FDO Profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    createProfile(options) {
        return (0, exports.IntelApiFp)(this.configuration).createProfile(options)(this.fetch, this.basePath);
    }
    /**
     * deletes a FDO Profile **Access policy**: administrator
     * @summary deletes a FDO Profile
     * @param {number} id FDO Profile identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    deleteProfile(id, options) {
        return (0, exports.IntelApiFp)(this.configuration).deleteProfile(id, options)(this.fetch, this.basePath);
    }
    /**
     * Execute out of band action on an AMT managed device **Access policy**: administrator
     * @summary Execute out of band action on an AMT managed device
     * @param {number} id Environment identifier
     * @param {number} deviceId Device identifier
     * @param {OpenamtDeviceActionPayload} body Device Action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    deviceAction(id, deviceId, body, options) {
        return (0, exports.IntelApiFp)(this.configuration).deviceAction(id, deviceId, body, options)(this.fetch, this.basePath);
    }
    /**
     * Enable features on an AMT managed device **Access policy**: administrator
     * @summary Enable features on an AMT managed device
     * @param {number} id Environment identifier
     * @param {number} deviceId Device identifier
     * @param {OpenamtDeviceFeaturesPayload} body Device Features
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    deviceFeatures(id, deviceId, body, options) {
        return (0, exports.IntelApiFp)(this.configuration).deviceFeatures(id, deviceId, body, options)(this.fetch, this.basePath);
    }
    /**
     * duplicated an existing FDO Profile **Access policy**: administrator
     * @summary duplicated an existing FDO Profile
     * @param {number} id FDO Profile identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    duplicate(id, options) {
        return (0, exports.IntelApiFp)(this.configuration).duplicate(id, options)(this.fetch, this.basePath);
    }
    /**
     * Enable Portainer's FDO capabilities **Access policy**: administrator
     * @summary Enable Portainer's FDO capabilities
     * @param {FdoFdoConfigurePayload} body FDO Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    fdoConfigure(body, options) {
        return (0, exports.IntelApiFp)(this.configuration).fdoConfigure(body, options)(this.fetch, this.basePath);
    }
    /**
     * configures an FDO device **Access policy**: administrator
     * @summary configures an FDO device
     * @param {number} guid Guid
     * @param {FdoDeviceConfigurePayload} body Device Configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    fdoConfigureDevice(guid, body, options) {
        return (0, exports.IntelApiFp)(this.configuration).fdoConfigureDevice(guid, body, options)(this.fetch, this.basePath);
    }
    /**
     * List all known FDO vouchers **Access policy**: administrator
     * @summary List all known FDO vouchers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    fdoListAll(options) {
        return (0, exports.IntelApiFp)(this.configuration).fdoListAll(options)(this.fetch, this.basePath);
    }
    /**
     * retrieves a given FDO profile information and content **Access policy**: administrator
     * @summary retrieves a given FDO profile information and content
     * @param {number} id FDO Profile identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    fdoProfileInspect(id, options) {
        return (0, exports.IntelApiFp)(this.configuration).fdoProfileInspect(id, options)(this.fetch, this.basePath);
    }
    /**
     * retrieves all FDO profiles **Access policy**: administrator
     * @summary retrieves all FDO profiles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    fdoProfileList(options) {
        return (0, exports.IntelApiFp)(this.configuration).fdoProfileList(options)(this.fetch, this.basePath);
    }
    /**
     * register an FDO device **Access policy**: administrator
     * @summary register an FDO device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    fdoRegisterDevice(options) {
        return (0, exports.IntelApiFp)(this.configuration).fdoRegisterDevice(options)(this.fetch, this.basePath);
    }
    /**
     * Activate OpenAMT device and associate to agent endpoint **Access policy**: administrator
     * @summary Activate OpenAMT device and associate to agent endpoint
     * @param {number} id Environment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    openAMTActivate(id, options) {
        return (0, exports.IntelApiFp)(this.configuration).openAMTActivate(id, options)(this.fetch, this.basePath);
    }
    /**
     * Enable Portainer's OpenAMT capabilities **Access policy**: administrator
     * @summary Enable Portainer's OpenAMT capabilities
     * @param {OpenamtOpenAMTConfigurePayload} body OpenAMT Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    openAMTConfigure(body, options) {
        return (0, exports.IntelApiFp)(this.configuration).openAMTConfigure(body, options)(this.fetch, this.basePath);
    }
    /**
     * Fetch OpenAMT managed devices information for endpoint **Access policy**: administrator
     * @summary Fetch OpenAMT managed devices information for endpoint
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    openAMTDevices(id, options) {
        return (0, exports.IntelApiFp)(this.configuration).openAMTDevices(id, options)(this.fetch, this.basePath);
    }
    /**
     * Request OpenAMT info from a node **Access policy**: administrator
     * @summary Request OpenAMT info from a node
     * @param {number} id Environment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    openAMTHostInfo(id, options) {
        return (0, exports.IntelApiFp)(this.configuration).openAMTHostInfo(id, options)(this.fetch, this.basePath);
    }
    /**
     * updates an existing FDO Profile **Access policy**: administrator
     * @summary updates an existing FDO Profile
     * @param {number} id FDO Profile identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    updateProfile(id, options) {
        return (0, exports.IntelApiFp)(this.configuration).updateProfile(id, options)(this.fetch, this.basePath);
    }
}
exports.IntelApi = IntelApi;
/**
 * KubernetesApi - fetch parameter creator
 * @export
 */
const KubernetesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Create a kubernetes ingress by namespace for the provided environment **Access policy**: authenticated
         * @summary Create a kubernetes ingress by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesIngress(id, namespace, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling createKubernetesIngress.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling createKubernetesIngress.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createKubernetesIngress.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("KubernetesK8sIngressInfo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Create a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sNamespaceDetails} body Namespace configuration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesNamespace(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling createKubernetesNamespace.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createKubernetesNamespace.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("KubernetesK8sNamespaceDetails" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Create a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesService(id, namespace, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling createKubernetesService.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling createKubernetesService.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createKubernetesService.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/services`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("KubernetesK8sServiceInfo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete kubernetes ingresses for the provided environment **Access policy**: authenticated
         * @summary Delete kubernetes ingresses
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sIngressDeleteRequests} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesIngresses(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteKubernetesIngresses.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling deleteKubernetesIngresses.');
            }
            const localVarPath = `/kubernetes/{id}/ingresses/delete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("KubernetesK8sIngressDeleteRequests" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Delete kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesNamespace(id, namespace, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteKubernetesNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling deleteKubernetesNamespace.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the provided list of kubernetes services **Access policy**: authenticated
         * @summary Delete kubernetes services
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sServiceDeleteRequests} body A map where the key is the namespace and the value is an array of services to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesServices(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteKubernetesServices.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling deleteKubernetesServices.');
            }
            const localVarPath = `/kubernetes/{id}/services/delete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("KubernetesK8sServiceDeleteRequests" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a kubeconfig file enabling client communication with k8s api server **Access policy**: authenticated
         * @summary Generate a kubeconfig file enabling client communication with k8s api server
         * @param {Array<number>} [ids] will include only these environments(endpoints)
         * @param {Array<number>} [excludeIds] will exclude these environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesConfig(ids, excludeIds, options = {}) {
            const localVarPath = `/kubernetes/config`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }
            if (excludeIds) {
                localVarQueryParameter['excludeIds'] = excludeIds;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all ConfigMaps and Secrets for a given namespace **Access policy**: authenticated
         * @summary Get ConfigMaps and Secrets
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesConfigMapsAndSecrets(id, namespace, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getKubernetesConfigMapsAndSecrets.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling getKubernetesConfigMapsAndSecrets.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/configuration`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of ingress controllers for the given environment **Access policy**: authenticated
         * @summary Get a list of ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {boolean} [allowedOnly] Only return allowed ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllers(id, allowedOnly, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getKubernetesIngressControllers.');
            }
            const localVarPath = `/kubernetes/{id}/ingresscontrollers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (allowedOnly !== undefined) {
                localVarQueryParameter['allowedOnly'] = allowedOnly;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of ingress controllers for the given environment in the provided namespace **Access policy**: authenticated
         * @summary Get a list ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllersByNamespace(id, namespace, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getKubernetesIngressControllersByNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling getKubernetesIngressControllersByNamespace.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresscontrollers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get kubernetes ingresses by namespace for the provided environment **Access policy**: authenticated
         * @summary Get kubernetes ingresses by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<KubernetesK8sIngressInfo>} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngresses(id, namespace, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getKubernetesIngresses.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling getKubernetesIngresses.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling getKubernetesIngresses.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;KubernetesK8sIngressInfo&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of nodes with their live metrics **Access policy**: authenticated
         * @summary Get a list of nodes with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllNodes(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getKubernetesMetricsForAllNodes.');
            }
            const localVarPath = `/kubernetes/{id}/metrics/nodes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of pods with their live metrics **Access policy**: authenticated
         * @summary Get a list of pods with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllPods(id, namespace, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getKubernetesMetricsForAllPods.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling getKubernetesMetricsForAllPods.');
            }
            const localVarPath = `/kubernetes/{id}/metrics/pods/{namespace}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get live metrics for a node **Access policy**: authenticated
         * @summary Get live metrics for a node
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} name Node identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForNode(id, name, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getKubernetesMetricsForNode.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling getKubernetesMetricsForNode.');
            }
            const localVarPath = `/kubernetes/{id}/metrics/nodes/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get live metrics for a pod **Access policy**: authenticated
         * @summary Get live metrics for a pod
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {string} name Pod identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForPod(id, namespace, name, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getKubernetesMetricsForPod.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling getKubernetesMetricsForPod.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling getKubernetesMetricsForPod.');
            }
            const localVarPath = `/kubernetes/{id}/metrics/pods/{namespace}/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get kubernetes namespace details for the provided namespace within the given environment **Access policy**: authenticated
         * @summary Get kubernetes namespace details
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespace(id, namespace, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getKubernetesNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling getKubernetesNamespace.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all kubernetes namespaces in the cluster **Access policy**: authenticated
         * @summary Get a list of kubernetes namespaces
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespaces(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getKubernetesNamespaces.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CPU and memory limits of all nodes within k8s cluster **Access policy**: authenticated
         * @summary Get CPU and memory limits of all nodes within k8s cluster
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNodesLimits(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getKubernetesNodesLimits.');
            }
            const localVarPath = `/kubernetes/{id}/nodes_limits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of kubernetes services for a given namespace **Access policy**: authenticated
         * @summary Get a list of kubernetes services for a given namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {boolean} [lookupapplications] Lookup applications associated with each service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesServices(id, namespace, lookupapplications, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getKubernetesServices.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling getKubernetesServices.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/services`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (lookupapplications !== undefined) {
                localVarQueryParameter['lookupapplications'] = lookupapplications;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Toggle the system state for a namespace **Access policy**: administrator or environment(endpoint) admin
         * @summary Toggle the system state for a namespace
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesNamespacesToggleSystemPayload} body Update details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kubernetesNamespacesToggleSystem(id, namespace, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling kubernetesNamespacesToggleSystem.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling kubernetesNamespacesToggleSystem.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling kubernetesNamespacesToggleSystem.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/system`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("KubernetesNamespacesToggleSystemPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update kubernetes ingress rule for the provided environment **Access policy**: authenticated
         * @summary Update kubernetes ingress rule
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngress(id, namespace, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateKubernetesIngress.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling updateKubernetesIngress.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateKubernetesIngress.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("KubernetesK8sIngressInfo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update (block/unblock) ingress controllers **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllers(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateKubernetesIngressControllers.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateKubernetesIngressControllers.');
            }
            const localVarPath = `/kubernetes/{id}/ingresscontrollers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;Array&lt;KubernetesK8sIngressController&gt;&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update (block/unblock) ingress controllers by namespace for the provided environment **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllersByNamespace(id, namespace, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateKubernetesIngressControllersByNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling updateKubernetesIngressControllersByNamespace.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateKubernetesIngressControllersByNamespace.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresscontrollers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;Array&lt;KubernetesK8sIngressController&gt;&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Updates a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {KubernetesK8sNamespaceDetails} body Namespace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesNamespace(id, namespace, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateKubernetesNamespace.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling updateKubernetesNamespace.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateKubernetesNamespace.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("KubernetesK8sNamespaceDetails" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Update a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesService(id, namespace, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateKubernetesService.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling updateKubernetesService.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateKubernetesService.');
            }
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/services`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("KubernetesK8sServiceInfo" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.KubernetesApiFetchParamCreator = KubernetesApiFetchParamCreator;
/**
 * KubernetesApi - functional programming interface
 * @export
 */
const KubernetesApiFp = function (configuration) {
    return {
        /**
         * Create a kubernetes ingress by namespace for the provided environment **Access policy**: authenticated
         * @summary Create a kubernetes ingress by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesIngress(id, namespace, body, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).createKubernetesIngress(id, namespace, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Create a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sNamespaceDetails} body Namespace configuration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesNamespace(id, body, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).createKubernetesNamespace(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Create a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesService(id, namespace, body, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).createKubernetesService(id, namespace, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete kubernetes ingresses for the provided environment **Access policy**: authenticated
         * @summary Delete kubernetes ingresses
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sIngressDeleteRequests} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesIngresses(id, body, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).deleteKubernetesIngresses(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Delete kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesNamespace(id, namespace, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).deleteKubernetesNamespace(id, namespace, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete the provided list of kubernetes services **Access policy**: authenticated
         * @summary Delete kubernetes services
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sServiceDeleteRequests} body A map where the key is the namespace and the value is an array of services to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesServices(id, body, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).deleteKubernetesServices(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Generate a kubeconfig file enabling client communication with k8s api server **Access policy**: authenticated
         * @summary Generate a kubeconfig file enabling client communication with k8s api server
         * @param {Array<number>} [ids] will include only these environments(endpoints)
         * @param {Array<number>} [excludeIds] will exclude these environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesConfig(ids, excludeIds, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).getKubernetesConfig(ids, excludeIds, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all ConfigMaps and Secrets for a given namespace **Access policy**: authenticated
         * @summary Get ConfigMaps and Secrets
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesConfigMapsAndSecrets(id, namespace, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).getKubernetesConfigMapsAndSecrets(id, namespace, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of ingress controllers for the given environment **Access policy**: authenticated
         * @summary Get a list of ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {boolean} [allowedOnly] Only return allowed ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllers(id, allowedOnly, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).getKubernetesIngressControllers(id, allowedOnly, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of ingress controllers for the given environment in the provided namespace **Access policy**: authenticated
         * @summary Get a list ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllersByNamespace(id, namespace, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).getKubernetesIngressControllersByNamespace(id, namespace, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get kubernetes ingresses by namespace for the provided environment **Access policy**: authenticated
         * @summary Get kubernetes ingresses by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<KubernetesK8sIngressInfo>} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngresses(id, namespace, body, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).getKubernetesIngresses(id, namespace, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of nodes with their live metrics **Access policy**: authenticated
         * @summary Get a list of nodes with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllNodes(id, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).getKubernetesMetricsForAllNodes(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of pods with their live metrics **Access policy**: authenticated
         * @summary Get a list of pods with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllPods(id, namespace, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).getKubernetesMetricsForAllPods(id, namespace, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get live metrics for a node **Access policy**: authenticated
         * @summary Get live metrics for a node
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} name Node identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForNode(id, name, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).getKubernetesMetricsForNode(id, name, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get live metrics for a pod **Access policy**: authenticated
         * @summary Get live metrics for a pod
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {string} name Pod identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForPod(id, namespace, name, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).getKubernetesMetricsForPod(id, namespace, name, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get kubernetes namespace details for the provided namespace within the given environment **Access policy**: authenticated
         * @summary Get kubernetes namespace details
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespace(id, namespace, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).getKubernetesNamespace(id, namespace, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of all kubernetes namespaces in the cluster **Access policy**: authenticated
         * @summary Get a list of kubernetes namespaces
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespaces(id, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).getKubernetesNamespaces(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get CPU and memory limits of all nodes within k8s cluster **Access policy**: authenticated
         * @summary Get CPU and memory limits of all nodes within k8s cluster
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNodesLimits(id, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).getKubernetesNodesLimits(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of kubernetes services for a given namespace **Access policy**: authenticated
         * @summary Get a list of kubernetes services for a given namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {boolean} [lookupapplications] Lookup applications associated with each service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesServices(id, namespace, lookupapplications, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).getKubernetesServices(id, namespace, lookupapplications, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Toggle the system state for a namespace **Access policy**: administrator or environment(endpoint) admin
         * @summary Toggle the system state for a namespace
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesNamespacesToggleSystemPayload} body Update details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kubernetesNamespacesToggleSystem(id, namespace, body, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).kubernetesNamespacesToggleSystem(id, namespace, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update kubernetes ingress rule for the provided environment **Access policy**: authenticated
         * @summary Update kubernetes ingress rule
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngress(id, namespace, body, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).updateKubernetesIngress(id, namespace, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update (block/unblock) ingress controllers **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllers(id, body, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).updateKubernetesIngressControllers(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update (block/unblock) ingress controllers by namespace for the provided environment **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllersByNamespace(id, namespace, body, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).updateKubernetesIngressControllersByNamespace(id, namespace, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Updates a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {KubernetesK8sNamespaceDetails} body Namespace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesNamespace(id, namespace, body, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).updateKubernetesNamespace(id, namespace, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Update a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesService(id, namespace, body, options) {
            const localVarFetchArgs = (0, exports.KubernetesApiFetchParamCreator)(configuration).updateKubernetesService(id, namespace, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.KubernetesApiFp = KubernetesApiFp;
/**
 * KubernetesApi - factory interface
 * @export
 */
const KubernetesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Create a kubernetes ingress by namespace for the provided environment **Access policy**: authenticated
         * @summary Create a kubernetes ingress by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesIngress(id, namespace, body, options) {
            return (0, exports.KubernetesApiFp)(configuration).createKubernetesIngress(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Create a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Create a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sNamespaceDetails} body Namespace configuration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesNamespace(id, body, options) {
            return (0, exports.KubernetesApiFp)(configuration).createKubernetesNamespace(id, body, options)(fetch, basePath);
        },
        /**
         * Create a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Create a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesService(id, namespace, body, options) {
            return (0, exports.KubernetesApiFp)(configuration).createKubernetesService(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Delete kubernetes ingresses for the provided environment **Access policy**: authenticated
         * @summary Delete kubernetes ingresses
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sIngressDeleteRequests} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesIngresses(id, body, options) {
            return (0, exports.KubernetesApiFp)(configuration).deleteKubernetesIngresses(id, body, options)(fetch, basePath);
        },
        /**
         * Delete a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Delete kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesNamespace(id, namespace, options) {
            return (0, exports.KubernetesApiFp)(configuration).deleteKubernetesNamespace(id, namespace, options)(fetch, basePath);
        },
        /**
         * Delete the provided list of kubernetes services **Access policy**: authenticated
         * @summary Delete kubernetes services
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sServiceDeleteRequests} body A map where the key is the namespace and the value is an array of services to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesServices(id, body, options) {
            return (0, exports.KubernetesApiFp)(configuration).deleteKubernetesServices(id, body, options)(fetch, basePath);
        },
        /**
         * Generate a kubeconfig file enabling client communication with k8s api server **Access policy**: authenticated
         * @summary Generate a kubeconfig file enabling client communication with k8s api server
         * @param {Array<number>} [ids] will include only these environments(endpoints)
         * @param {Array<number>} [excludeIds] will exclude these environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesConfig(ids, excludeIds, options) {
            return (0, exports.KubernetesApiFp)(configuration).getKubernetesConfig(ids, excludeIds, options)(fetch, basePath);
        },
        /**
         * Get all ConfigMaps and Secrets for a given namespace **Access policy**: authenticated
         * @summary Get ConfigMaps and Secrets
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesConfigMapsAndSecrets(id, namespace, options) {
            return (0, exports.KubernetesApiFp)(configuration).getKubernetesConfigMapsAndSecrets(id, namespace, options)(fetch, basePath);
        },
        /**
         * Get a list of ingress controllers for the given environment **Access policy**: authenticated
         * @summary Get a list of ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {boolean} [allowedOnly] Only return allowed ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllers(id, allowedOnly, options) {
            return (0, exports.KubernetesApiFp)(configuration).getKubernetesIngressControllers(id, allowedOnly, options)(fetch, basePath);
        },
        /**
         * Get a list of ingress controllers for the given environment in the provided namespace **Access policy**: authenticated
         * @summary Get a list ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllersByNamespace(id, namespace, options) {
            return (0, exports.KubernetesApiFp)(configuration).getKubernetesIngressControllersByNamespace(id, namespace, options)(fetch, basePath);
        },
        /**
         * Get kubernetes ingresses by namespace for the provided environment **Access policy**: authenticated
         * @summary Get kubernetes ingresses by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<KubernetesK8sIngressInfo>} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngresses(id, namespace, body, options) {
            return (0, exports.KubernetesApiFp)(configuration).getKubernetesIngresses(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Get a list of nodes with their live metrics **Access policy**: authenticated
         * @summary Get a list of nodes with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllNodes(id, options) {
            return (0, exports.KubernetesApiFp)(configuration).getKubernetesMetricsForAllNodes(id, options)(fetch, basePath);
        },
        /**
         * Get a list of pods with their live metrics **Access policy**: authenticated
         * @summary Get a list of pods with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllPods(id, namespace, options) {
            return (0, exports.KubernetesApiFp)(configuration).getKubernetesMetricsForAllPods(id, namespace, options)(fetch, basePath);
        },
        /**
         * Get live metrics for a node **Access policy**: authenticated
         * @summary Get live metrics for a node
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} name Node identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForNode(id, name, options) {
            return (0, exports.KubernetesApiFp)(configuration).getKubernetesMetricsForNode(id, name, options)(fetch, basePath);
        },
        /**
         * Get live metrics for a pod **Access policy**: authenticated
         * @summary Get live metrics for a pod
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {string} name Pod identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForPod(id, namespace, name, options) {
            return (0, exports.KubernetesApiFp)(configuration).getKubernetesMetricsForPod(id, namespace, name, options)(fetch, basePath);
        },
        /**
         * Get kubernetes namespace details for the provided namespace within the given environment **Access policy**: authenticated
         * @summary Get kubernetes namespace details
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespace(id, namespace, options) {
            return (0, exports.KubernetesApiFp)(configuration).getKubernetesNamespace(id, namespace, options)(fetch, basePath);
        },
        /**
         * Get a list of all kubernetes namespaces in the cluster **Access policy**: authenticated
         * @summary Get a list of kubernetes namespaces
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespaces(id, options) {
            return (0, exports.KubernetesApiFp)(configuration).getKubernetesNamespaces(id, options)(fetch, basePath);
        },
        /**
         * Get CPU and memory limits of all nodes within k8s cluster **Access policy**: authenticated
         * @summary Get CPU and memory limits of all nodes within k8s cluster
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNodesLimits(id, options) {
            return (0, exports.KubernetesApiFp)(configuration).getKubernetesNodesLimits(id, options)(fetch, basePath);
        },
        /**
         * Get a list of kubernetes services for a given namespace **Access policy**: authenticated
         * @summary Get a list of kubernetes services for a given namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {boolean} [lookupapplications] Lookup applications associated with each service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesServices(id, namespace, lookupapplications, options) {
            return (0, exports.KubernetesApiFp)(configuration).getKubernetesServices(id, namespace, lookupapplications, options)(fetch, basePath);
        },
        /**
         * Toggle the system state for a namespace **Access policy**: administrator or environment(endpoint) admin
         * @summary Toggle the system state for a namespace
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesNamespacesToggleSystemPayload} body Update details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kubernetesNamespacesToggleSystem(id, namespace, body, options) {
            return (0, exports.KubernetesApiFp)(configuration).kubernetesNamespacesToggleSystem(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Update kubernetes ingress rule for the provided environment **Access policy**: authenticated
         * @summary Update kubernetes ingress rule
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngress(id, namespace, body, options) {
            return (0, exports.KubernetesApiFp)(configuration).updateKubernetesIngress(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Update (block/unblock) ingress controllers **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllers(id, body, options) {
            return (0, exports.KubernetesApiFp)(configuration).updateKubernetesIngressControllers(id, body, options)(fetch, basePath);
        },
        /**
         * Update (block/unblock) ingress controllers by namespace for the provided environment **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllersByNamespace(id, namespace, body, options) {
            return (0, exports.KubernetesApiFp)(configuration).updateKubernetesIngressControllersByNamespace(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Update a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Updates a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {KubernetesK8sNamespaceDetails} body Namespace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesNamespace(id, namespace, body, options) {
            return (0, exports.KubernetesApiFp)(configuration).updateKubernetesNamespace(id, namespace, body, options)(fetch, basePath);
        },
        /**
         * Update a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Update a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesService(id, namespace, body, options) {
            return (0, exports.KubernetesApiFp)(configuration).updateKubernetesService(id, namespace, body, options)(fetch, basePath);
        },
    };
};
exports.KubernetesApiFactory = KubernetesApiFactory;
/**
 * KubernetesApi - object-oriented interface
 * @export
 * @class KubernetesApi
 * @extends {BaseAPI}
 */
class KubernetesApi extends BaseAPI {
    /**
     * Create a kubernetes ingress by namespace for the provided environment **Access policy**: authenticated
     * @summary Create a kubernetes ingress by namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesK8sIngressInfo} body Ingress details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    createKubernetesIngress(id, namespace, body, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).createKubernetesIngress(id, namespace, body, options)(this.fetch, this.basePath);
    }
    /**
     * Create a kubernetes namespace within the given environment **Access policy**: authenticated
     * @summary Create a kubernetes namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {KubernetesK8sNamespaceDetails} body Namespace configuration details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    createKubernetesNamespace(id, body, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).createKubernetesNamespace(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * Create a kubernetes service within a given namespace **Access policy**: authenticated
     * @summary Create a kubernetes service
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesK8sServiceInfo} body Service definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    createKubernetesService(id, namespace, body, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).createKubernetesService(id, namespace, body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete kubernetes ingresses for the provided environment **Access policy**: authenticated
     * @summary Delete kubernetes ingresses
     * @param {number} id Environment (Endpoint) identifier
     * @param {KubernetesK8sIngressDeleteRequests} body Ingress details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    deleteKubernetesIngresses(id, body, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).deleteKubernetesIngresses(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete a kubernetes namespace within the given environment **Access policy**: authenticated
     * @summary Delete kubernetes namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    deleteKubernetesNamespace(id, namespace, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).deleteKubernetesNamespace(id, namespace, options)(this.fetch, this.basePath);
    }
    /**
     * Delete the provided list of kubernetes services **Access policy**: authenticated
     * @summary Delete kubernetes services
     * @param {number} id Environment (Endpoint) identifier
     * @param {KubernetesK8sServiceDeleteRequests} body A map where the key is the namespace and the value is an array of services to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    deleteKubernetesServices(id, body, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).deleteKubernetesServices(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * Generate a kubeconfig file enabling client communication with k8s api server **Access policy**: authenticated
     * @summary Generate a kubeconfig file enabling client communication with k8s api server
     * @param {Array<number>} [ids] will include only these environments(endpoints)
     * @param {Array<number>} [excludeIds] will exclude these environments(endpoints)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    getKubernetesConfig(ids, excludeIds, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).getKubernetesConfig(ids, excludeIds, options)(this.fetch, this.basePath);
    }
    /**
     * Get all ConfigMaps and Secrets for a given namespace **Access policy**: authenticated
     * @summary Get ConfigMaps and Secrets
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    getKubernetesConfigMapsAndSecrets(id, namespace, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).getKubernetesConfigMapsAndSecrets(id, namespace, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of ingress controllers for the given environment **Access policy**: authenticated
     * @summary Get a list of ingress controllers
     * @param {number} id Environment (Endpoint) identifier
     * @param {boolean} [allowedOnly] Only return allowed ingress controllers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    getKubernetesIngressControllers(id, allowedOnly, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).getKubernetesIngressControllers(id, allowedOnly, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of ingress controllers for the given environment in the provided namespace **Access policy**: authenticated
     * @summary Get a list ingress controllers by namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    getKubernetesIngressControllersByNamespace(id, namespace, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).getKubernetesIngressControllersByNamespace(id, namespace, options)(this.fetch, this.basePath);
    }
    /**
     * Get kubernetes ingresses by namespace for the provided environment **Access policy**: authenticated
     * @summary Get kubernetes ingresses by namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {Array<KubernetesK8sIngressInfo>} body Ingress details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    getKubernetesIngresses(id, namespace, body, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).getKubernetesIngresses(id, namespace, body, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of nodes with their live metrics **Access policy**: authenticated
     * @summary Get a list of nodes with their live metrics
     * @param {number} id Environment (Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    getKubernetesMetricsForAllNodes(id, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).getKubernetesMetricsForAllNodes(id, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of pods with their live metrics **Access policy**: authenticated
     * @summary Get a list of pods with their live metrics
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    getKubernetesMetricsForAllPods(id, namespace, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).getKubernetesMetricsForAllPods(id, namespace, options)(this.fetch, this.basePath);
    }
    /**
     * Get live metrics for a node **Access policy**: authenticated
     * @summary Get live metrics for a node
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} name Node identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    getKubernetesMetricsForNode(id, name, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).getKubernetesMetricsForNode(id, name, options)(this.fetch, this.basePath);
    }
    /**
     * Get live metrics for a pod **Access policy**: authenticated
     * @summary Get live metrics for a pod
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {string} name Pod identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    getKubernetesMetricsForPod(id, namespace, name, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).getKubernetesMetricsForPod(id, namespace, name, options)(this.fetch, this.basePath);
    }
    /**
     * Get kubernetes namespace details for the provided namespace within the given environment **Access policy**: authenticated
     * @summary Get kubernetes namespace details
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    getKubernetesNamespace(id, namespace, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).getKubernetesNamespace(id, namespace, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of all kubernetes namespaces in the cluster **Access policy**: authenticated
     * @summary Get a list of kubernetes namespaces
     * @param {number} id Environment (Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    getKubernetesNamespaces(id, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).getKubernetesNamespaces(id, options)(this.fetch, this.basePath);
    }
    /**
     * Get CPU and memory limits of all nodes within k8s cluster **Access policy**: authenticated
     * @summary Get CPU and memory limits of all nodes within k8s cluster
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    getKubernetesNodesLimits(id, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).getKubernetesNodesLimits(id, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of kubernetes services for a given namespace **Access policy**: authenticated
     * @summary Get a list of kubernetes services for a given namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {boolean} [lookupapplications] Lookup applications associated with each service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    getKubernetesServices(id, namespace, lookupapplications, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).getKubernetesServices(id, namespace, lookupapplications, options)(this.fetch, this.basePath);
    }
    /**
     * Toggle the system state for a namespace **Access policy**: administrator or environment(endpoint) admin
     * @summary Toggle the system state for a namespace
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesNamespacesToggleSystemPayload} body Update details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    kubernetesNamespacesToggleSystem(id, namespace, body, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).kubernetesNamespacesToggleSystem(id, namespace, body, options)(this.fetch, this.basePath);
    }
    /**
     * Update kubernetes ingress rule for the provided environment **Access policy**: authenticated
     * @summary Update kubernetes ingress rule
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesK8sIngressInfo} body Ingress details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    updateKubernetesIngress(id, namespace, body, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).updateKubernetesIngress(id, namespace, body, options)(this.fetch, this.basePath);
    }
    /**
     * Update (block/unblock) ingress controllers **Access policy**: authenticated
     * @summary Update (block/unblock) ingress controllers
     * @param {number} id Environment (Endpoint) identifier
     * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    updateKubernetesIngressControllers(id, body, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).updateKubernetesIngressControllers(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * Update (block/unblock) ingress controllers by namespace for the provided environment **Access policy**: authenticated
     * @summary Update (block/unblock) ingress controllers by namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    updateKubernetesIngressControllersByNamespace(id, namespace, body, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).updateKubernetesIngressControllersByNamespace(id, namespace, body, options)(this.fetch, this.basePath);
    }
    /**
     * Update a kubernetes namespace within the given environment **Access policy**: authenticated
     * @summary Updates a kubernetes namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {KubernetesK8sNamespaceDetails} body Namespace details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    updateKubernetesNamespace(id, namespace, body, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).updateKubernetesNamespace(id, namespace, body, options)(this.fetch, this.basePath);
    }
    /**
     * Update a kubernetes service within a given namespace **Access policy**: authenticated
     * @summary Update a kubernetes service
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesK8sServiceInfo} body Service definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    updateKubernetesService(id, namespace, body, options) {
        return (0, exports.KubernetesApiFp)(this.configuration).updateKubernetesService(id, namespace, body, options)(this.fetch, this.basePath);
    }
}
exports.KubernetesApi = KubernetesApi;
/**
 * LdapApi - fetch parameter creator
 * @export
 */
const LdapApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Test LDAP connectivity using LDAP details **Access policy**: administrator
         * @summary Test LDAP connectivity
         * @param {LdapCheckPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lDAPCheck(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling lDAPCheck.');
            }
            const localVarPath = `/ldap/check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("LdapCheckPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.LdapApiFetchParamCreator = LdapApiFetchParamCreator;
/**
 * LdapApi - functional programming interface
 * @export
 */
const LdapApiFp = function (configuration) {
    return {
        /**
         * Test LDAP connectivity using LDAP details **Access policy**: administrator
         * @summary Test LDAP connectivity
         * @param {LdapCheckPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lDAPCheck(body, options) {
            const localVarFetchArgs = (0, exports.LdapApiFetchParamCreator)(configuration).lDAPCheck(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.LdapApiFp = LdapApiFp;
/**
 * LdapApi - factory interface
 * @export
 */
const LdapApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Test LDAP connectivity using LDAP details **Access policy**: administrator
         * @summary Test LDAP connectivity
         * @param {LdapCheckPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lDAPCheck(body, options) {
            return (0, exports.LdapApiFp)(configuration).lDAPCheck(body, options)(fetch, basePath);
        },
    };
};
exports.LdapApiFactory = LdapApiFactory;
/**
 * LdapApi - object-oriented interface
 * @export
 * @class LdapApi
 * @extends {BaseAPI}
 */
class LdapApi extends BaseAPI {
    /**
     * Test LDAP connectivity using LDAP details **Access policy**: administrator
     * @summary Test LDAP connectivity
     * @param {LdapCheckPayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LdapApi
     */
    lDAPCheck(body, options) {
        return (0, exports.LdapApiFp)(this.configuration).lDAPCheck(body, options)(this.fetch, this.basePath);
    }
}
exports.LdapApi = LdapApi;
/**
 * MotdApi - fetch parameter creator
 * @export
 */
const MotdApiFetchParamCreator = function (configuration) {
    return {
        /**
         * **Access policy**: restricted
         * @summary fetches the message of the day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mOTD(options = {}) {
            const localVarPath = `/motd`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.MotdApiFetchParamCreator = MotdApiFetchParamCreator;
/**
 * MotdApi - functional programming interface
 * @export
 */
const MotdApiFp = function (configuration) {
    return {
        /**
         * **Access policy**: restricted
         * @summary fetches the message of the day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mOTD(options) {
            const localVarFetchArgs = (0, exports.MotdApiFetchParamCreator)(configuration).mOTD(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.MotdApiFp = MotdApiFp;
/**
 * MotdApi - factory interface
 * @export
 */
const MotdApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * **Access policy**: restricted
         * @summary fetches the message of the day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mOTD(options) {
            return (0, exports.MotdApiFp)(configuration).mOTD(options)(fetch, basePath);
        },
    };
};
exports.MotdApiFactory = MotdApiFactory;
/**
 * MotdApi - object-oriented interface
 * @export
 * @class MotdApi
 * @extends {BaseAPI}
 */
class MotdApi extends BaseAPI {
    /**
     * **Access policy**: restricted
     * @summary fetches the message of the day
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotdApi
     */
    mOTD(options) {
        return (0, exports.MotdApiFp)(this.configuration).mOTD(options)(this.fetch, this.basePath);
    }
}
exports.MotdApi = MotdApi;
/**
 * RbacEnabledApi - fetch parameter creator
 * @export
 */
const RbacEnabledApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Check if RBAC is enabled in the current Kubernetes cluster. **Access policy**: administrator
         * @summary Check if RBAC is enabled
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRBACEnabled(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling isRBACEnabled.');
            }
            const localVarPath = `/kubernetes/{id}/rbac_enabled`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.RbacEnabledApiFetchParamCreator = RbacEnabledApiFetchParamCreator;
/**
 * RbacEnabledApi - functional programming interface
 * @export
 */
const RbacEnabledApiFp = function (configuration) {
    return {
        /**
         * Check if RBAC is enabled in the current Kubernetes cluster. **Access policy**: administrator
         * @summary Check if RBAC is enabled
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRBACEnabled(id, options) {
            const localVarFetchArgs = (0, exports.RbacEnabledApiFetchParamCreator)(configuration).isRBACEnabled(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.RbacEnabledApiFp = RbacEnabledApiFp;
/**
 * RbacEnabledApi - factory interface
 * @export
 */
const RbacEnabledApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Check if RBAC is enabled in the current Kubernetes cluster. **Access policy**: administrator
         * @summary Check if RBAC is enabled
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRBACEnabled(id, options) {
            return (0, exports.RbacEnabledApiFp)(configuration).isRBACEnabled(id, options)(fetch, basePath);
        },
    };
};
exports.RbacEnabledApiFactory = RbacEnabledApiFactory;
/**
 * RbacEnabledApi - object-oriented interface
 * @export
 * @class RbacEnabledApi
 * @extends {BaseAPI}
 */
class RbacEnabledApi extends BaseAPI {
    /**
     * Check if RBAC is enabled in the current Kubernetes cluster. **Access policy**: administrator
     * @summary Check if RBAC is enabled
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacEnabledApi
     */
    isRBACEnabled(id, options) {
        return (0, exports.RbacEnabledApiFp)(this.configuration).isRBACEnabled(id, options)(this.fetch, this.basePath);
    }
}
exports.RbacEnabledApi = RbacEnabledApi;
/**
 * RegistriesApi - fetch parameter creator
 * @export
 */
const RegistriesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Configures a registry. **Access policy**: restricted
         * @summary Configures a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryConfigurePayload} body Registry configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryConfigure(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling registryConfigure.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling registryConfigure.');
            }
            const localVarPath = `/registries/{id}/configure`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("RegistriesRegistryConfigurePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new registry. **Access policy**: restricted
         * @summary Create a new registry
         * @param {RegistriesRegistryCreatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryCreate(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling registryCreate.');
            }
            const localVarPath = `/registries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("RegistriesRegistryCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a registry **Access policy**: restricted
         * @summary Remove a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling registryDelete.');
            }
            const localVarPath = `/registries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a registry. **Access policy**: restricted
         * @summary Inspect a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryInspect(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling registryInspect.');
            }
            const localVarPath = `/registries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all registries based on the current user authorizations. Will return all registries if using an administrator account otherwise it will only return authorized registries. **Access policy**: restricted
         * @summary List Registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryList(options = {}) {
            const localVarPath = `/registries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a registry **Access policy**: restricted
         * @summary Update a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryUpdatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryUpdate(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling registryUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling registryUpdate.');
            }
            const localVarPath = `/registries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("RegistriesRegistryUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.RegistriesApiFetchParamCreator = RegistriesApiFetchParamCreator;
/**
 * RegistriesApi - functional programming interface
 * @export
 */
const RegistriesApiFp = function (configuration) {
    return {
        /**
         * Configures a registry. **Access policy**: restricted
         * @summary Configures a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryConfigurePayload} body Registry configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryConfigure(id, body, options) {
            const localVarFetchArgs = (0, exports.RegistriesApiFetchParamCreator)(configuration).registryConfigure(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new registry. **Access policy**: restricted
         * @summary Create a new registry
         * @param {RegistriesRegistryCreatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryCreate(body, options) {
            const localVarFetchArgs = (0, exports.RegistriesApiFetchParamCreator)(configuration).registryCreate(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a registry **Access policy**: restricted
         * @summary Remove a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryDelete(id, options) {
            const localVarFetchArgs = (0, exports.RegistriesApiFetchParamCreator)(configuration).registryDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details about a registry. **Access policy**: restricted
         * @summary Inspect a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryInspect(id, options) {
            const localVarFetchArgs = (0, exports.RegistriesApiFetchParamCreator)(configuration).registryInspect(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all registries based on the current user authorizations. Will return all registries if using an administrator account otherwise it will only return authorized registries. **Access policy**: restricted
         * @summary List Registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryList(options) {
            const localVarFetchArgs = (0, exports.RegistriesApiFetchParamCreator)(configuration).registryList(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a registry **Access policy**: restricted
         * @summary Update a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryUpdatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryUpdate(id, body, options) {
            const localVarFetchArgs = (0, exports.RegistriesApiFetchParamCreator)(configuration).registryUpdate(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.RegistriesApiFp = RegistriesApiFp;
/**
 * RegistriesApi - factory interface
 * @export
 */
const RegistriesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Configures a registry. **Access policy**: restricted
         * @summary Configures a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryConfigurePayload} body Registry configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryConfigure(id, body, options) {
            return (0, exports.RegistriesApiFp)(configuration).registryConfigure(id, body, options)(fetch, basePath);
        },
        /**
         * Create a new registry. **Access policy**: restricted
         * @summary Create a new registry
         * @param {RegistriesRegistryCreatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryCreate(body, options) {
            return (0, exports.RegistriesApiFp)(configuration).registryCreate(body, options)(fetch, basePath);
        },
        /**
         * Remove a registry **Access policy**: restricted
         * @summary Remove a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryDelete(id, options) {
            return (0, exports.RegistriesApiFp)(configuration).registryDelete(id, options)(fetch, basePath);
        },
        /**
         * Retrieve details about a registry. **Access policy**: restricted
         * @summary Inspect a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryInspect(id, options) {
            return (0, exports.RegistriesApiFp)(configuration).registryInspect(id, options)(fetch, basePath);
        },
        /**
         * List all registries based on the current user authorizations. Will return all registries if using an administrator account otherwise it will only return authorized registries. **Access policy**: restricted
         * @summary List Registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryList(options) {
            return (0, exports.RegistriesApiFp)(configuration).registryList(options)(fetch, basePath);
        },
        /**
         * Update a registry **Access policy**: restricted
         * @summary Update a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryUpdatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryUpdate(id, body, options) {
            return (0, exports.RegistriesApiFp)(configuration).registryUpdate(id, body, options)(fetch, basePath);
        },
    };
};
exports.RegistriesApiFactory = RegistriesApiFactory;
/**
 * RegistriesApi - object-oriented interface
 * @export
 * @class RegistriesApi
 * @extends {BaseAPI}
 */
class RegistriesApi extends BaseAPI {
    /**
     * Configures a registry. **Access policy**: restricted
     * @summary Configures a registry
     * @param {number} id Registry identifier
     * @param {RegistriesRegistryConfigurePayload} body Registry configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    registryConfigure(id, body, options) {
        return (0, exports.RegistriesApiFp)(this.configuration).registryConfigure(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new registry. **Access policy**: restricted
     * @summary Create a new registry
     * @param {RegistriesRegistryCreatePayload} body Registry details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    registryCreate(body, options) {
        return (0, exports.RegistriesApiFp)(this.configuration).registryCreate(body, options)(this.fetch, this.basePath);
    }
    /**
     * Remove a registry **Access policy**: restricted
     * @summary Remove a registry
     * @param {number} id Registry identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    registryDelete(id, options) {
        return (0, exports.RegistriesApiFp)(this.configuration).registryDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve details about a registry. **Access policy**: restricted
     * @summary Inspect a registry
     * @param {number} id Registry identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    registryInspect(id, options) {
        return (0, exports.RegistriesApiFp)(this.configuration).registryInspect(id, options)(this.fetch, this.basePath);
    }
    /**
     * List all registries based on the current user authorizations. Will return all registries if using an administrator account otherwise it will only return authorized registries. **Access policy**: restricted
     * @summary List Registries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    registryList(options) {
        return (0, exports.RegistriesApiFp)(this.configuration).registryList(options)(this.fetch, this.basePath);
    }
    /**
     * Update a registry **Access policy**: restricted
     * @summary Update a registry
     * @param {number} id Registry identifier
     * @param {RegistriesRegistryUpdatePayload} body Registry details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    registryUpdate(id, body, options) {
        return (0, exports.RegistriesApiFp)(this.configuration).registryUpdate(id, body, options)(this.fetch, this.basePath);
    }
}
exports.RegistriesApi = RegistriesApi;
/**
 * ResourceControlsApi - fetch parameter creator
 * @export
 */
const ResourceControlsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Create a new resource control to restrict access to a Docker resource. **Access policy**: administrator
         * @summary Create a new resource control
         * @param {ResourcecontrolsResourceControlCreatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlCreate(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling resourceControlCreate.');
            }
            const localVarPath = `/resource_controls`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("ResourcecontrolsResourceControlCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a resource control. **Access policy**: administrator
         * @summary Remove a resource control
         * @param {number} id Resource control identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling resourceControlDelete.');
            }
            const localVarPath = `/resource_controls/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a resource control **Access policy**: authenticated
         * @summary Update a resource control
         * @param {number} id Resource control identifier
         * @param {ResourcecontrolsResourceControlUpdatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlUpdate(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling resourceControlUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling resourceControlUpdate.');
            }
            const localVarPath = `/resource_controls/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("ResourcecontrolsResourceControlUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ResourceControlsApiFetchParamCreator = ResourceControlsApiFetchParamCreator;
/**
 * ResourceControlsApi - functional programming interface
 * @export
 */
const ResourceControlsApiFp = function (configuration) {
    return {
        /**
         * Create a new resource control to restrict access to a Docker resource. **Access policy**: administrator
         * @summary Create a new resource control
         * @param {ResourcecontrolsResourceControlCreatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlCreate(body, options) {
            const localVarFetchArgs = (0, exports.ResourceControlsApiFetchParamCreator)(configuration).resourceControlCreate(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a resource control. **Access policy**: administrator
         * @summary Remove a resource control
         * @param {number} id Resource control identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlDelete(id, options) {
            const localVarFetchArgs = (0, exports.ResourceControlsApiFetchParamCreator)(configuration).resourceControlDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a resource control **Access policy**: authenticated
         * @summary Update a resource control
         * @param {number} id Resource control identifier
         * @param {ResourcecontrolsResourceControlUpdatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlUpdate(id, body, options) {
            const localVarFetchArgs = (0, exports.ResourceControlsApiFetchParamCreator)(configuration).resourceControlUpdate(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.ResourceControlsApiFp = ResourceControlsApiFp;
/**
 * ResourceControlsApi - factory interface
 * @export
 */
const ResourceControlsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Create a new resource control to restrict access to a Docker resource. **Access policy**: administrator
         * @summary Create a new resource control
         * @param {ResourcecontrolsResourceControlCreatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlCreate(body, options) {
            return (0, exports.ResourceControlsApiFp)(configuration).resourceControlCreate(body, options)(fetch, basePath);
        },
        /**
         * Remove a resource control. **Access policy**: administrator
         * @summary Remove a resource control
         * @param {number} id Resource control identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlDelete(id, options) {
            return (0, exports.ResourceControlsApiFp)(configuration).resourceControlDelete(id, options)(fetch, basePath);
        },
        /**
         * Update a resource control **Access policy**: authenticated
         * @summary Update a resource control
         * @param {number} id Resource control identifier
         * @param {ResourcecontrolsResourceControlUpdatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlUpdate(id, body, options) {
            return (0, exports.ResourceControlsApiFp)(configuration).resourceControlUpdate(id, body, options)(fetch, basePath);
        },
    };
};
exports.ResourceControlsApiFactory = ResourceControlsApiFactory;
/**
 * ResourceControlsApi - object-oriented interface
 * @export
 * @class ResourceControlsApi
 * @extends {BaseAPI}
 */
class ResourceControlsApi extends BaseAPI {
    /**
     * Create a new resource control to restrict access to a Docker resource. **Access policy**: administrator
     * @summary Create a new resource control
     * @param {ResourcecontrolsResourceControlCreatePayload} body Resource control details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceControlsApi
     */
    resourceControlCreate(body, options) {
        return (0, exports.ResourceControlsApiFp)(this.configuration).resourceControlCreate(body, options)(this.fetch, this.basePath);
    }
    /**
     * Remove a resource control. **Access policy**: administrator
     * @summary Remove a resource control
     * @param {number} id Resource control identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceControlsApi
     */
    resourceControlDelete(id, options) {
        return (0, exports.ResourceControlsApiFp)(this.configuration).resourceControlDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     * Update a resource control **Access policy**: authenticated
     * @summary Update a resource control
     * @param {number} id Resource control identifier
     * @param {ResourcecontrolsResourceControlUpdatePayload} body Resource control details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceControlsApi
     */
    resourceControlUpdate(id, body, options) {
        return (0, exports.ResourceControlsApiFp)(this.configuration).resourceControlUpdate(id, body, options)(this.fetch, this.basePath);
    }
}
exports.ResourceControlsApi = ResourceControlsApi;
/**
 * RolesApi - fetch parameter creator
 * @export
 */
const RolesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * List all roles available for use **Access policy**: administrator
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleList(options = {}) {
            const localVarPath = `/roles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.RolesApiFetchParamCreator = RolesApiFetchParamCreator;
/**
 * RolesApi - functional programming interface
 * @export
 */
const RolesApiFp = function (configuration) {
    return {
        /**
         * List all roles available for use **Access policy**: administrator
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleList(options) {
            const localVarFetchArgs = (0, exports.RolesApiFetchParamCreator)(configuration).roleList(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.RolesApiFp = RolesApiFp;
/**
 * RolesApi - factory interface
 * @export
 */
const RolesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * List all roles available for use **Access policy**: administrator
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleList(options) {
            return (0, exports.RolesApiFp)(configuration).roleList(options)(fetch, basePath);
        },
    };
};
exports.RolesApiFactory = RolesApiFactory;
/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
class RolesApi extends BaseAPI {
    /**
     * List all roles available for use **Access policy**: administrator
     * @summary List roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    roleList(options) {
        return (0, exports.RolesApiFp)(this.configuration).roleList(options)(this.fetch, this.basePath);
    }
}
exports.RolesApi = RolesApi;
/**
 * SettingsApi - fetch parameter creator
 * @export
 */
const SettingsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Retrieve Portainer settings. **Access policy**: administrator
         * @summary Retrieve Portainer settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsInspect(options = {}) {
            const localVarPath = `/settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve public settings. Returns a small set of settings that are not reserved to administrators only. **Access policy**: public
         * @summary Retrieve Portainer public settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPublic(options = {}) {
            const localVarPath = `/settings/public`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Portainer settings. **Access policy**: administrator
         * @summary Update Portainer settings
         * @param {SettingsSettingsUpdatePayload} body New settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsUpdate(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling settingsUpdate.');
            }
            const localVarPath = `/settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("SettingsSettingsUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SettingsApiFetchParamCreator = SettingsApiFetchParamCreator;
/**
 * SettingsApi - functional programming interface
 * @export
 */
const SettingsApiFp = function (configuration) {
    return {
        /**
         * Retrieve Portainer settings. **Access policy**: administrator
         * @summary Retrieve Portainer settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsInspect(options) {
            const localVarFetchArgs = (0, exports.SettingsApiFetchParamCreator)(configuration).settingsInspect(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve public settings. Returns a small set of settings that are not reserved to administrators only. **Access policy**: public
         * @summary Retrieve Portainer public settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPublic(options) {
            const localVarFetchArgs = (0, exports.SettingsApiFetchParamCreator)(configuration).settingsPublic(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update Portainer settings. **Access policy**: administrator
         * @summary Update Portainer settings
         * @param {SettingsSettingsUpdatePayload} body New settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsUpdate(body, options) {
            const localVarFetchArgs = (0, exports.SettingsApiFetchParamCreator)(configuration).settingsUpdate(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.SettingsApiFp = SettingsApiFp;
/**
 * SettingsApi - factory interface
 * @export
 */
const SettingsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Retrieve Portainer settings. **Access policy**: administrator
         * @summary Retrieve Portainer settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsInspect(options) {
            return (0, exports.SettingsApiFp)(configuration).settingsInspect(options)(fetch, basePath);
        },
        /**
         * Retrieve public settings. Returns a small set of settings that are not reserved to administrators only. **Access policy**: public
         * @summary Retrieve Portainer public settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPublic(options) {
            return (0, exports.SettingsApiFp)(configuration).settingsPublic(options)(fetch, basePath);
        },
        /**
         * Update Portainer settings. **Access policy**: administrator
         * @summary Update Portainer settings
         * @param {SettingsSettingsUpdatePayload} body New settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsUpdate(body, options) {
            return (0, exports.SettingsApiFp)(configuration).settingsUpdate(body, options)(fetch, basePath);
        },
    };
};
exports.SettingsApiFactory = SettingsApiFactory;
/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
class SettingsApi extends BaseAPI {
    /**
     * Retrieve Portainer settings. **Access policy**: administrator
     * @summary Retrieve Portainer settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    settingsInspect(options) {
        return (0, exports.SettingsApiFp)(this.configuration).settingsInspect(options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve public settings. Returns a small set of settings that are not reserved to administrators only. **Access policy**: public
     * @summary Retrieve Portainer public settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    settingsPublic(options) {
        return (0, exports.SettingsApiFp)(this.configuration).settingsPublic(options)(this.fetch, this.basePath);
    }
    /**
     * Update Portainer settings. **Access policy**: administrator
     * @summary Update Portainer settings
     * @param {SettingsSettingsUpdatePayload} body New settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    settingsUpdate(body, options) {
        return (0, exports.SettingsApiFp)(this.configuration).settingsUpdate(body, options)(this.fetch, this.basePath);
    }
}
exports.SettingsApi = SettingsApi;
/**
 * SslApi - fetch parameter creator
 * @export
 */
const SslApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Retrieve the ssl settings. **Access policy**: administrator
         * @summary Inspect the ssl settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLInspect(options = {}) {
            const localVarPath = `/ssl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the ssl settings. **Access policy**: administrator
         * @summary Update the ssl settings
         * @param {SslSslUpdatePayload} body SSL Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLUpdate(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling sSLUpdate.');
            }
            const localVarPath = `/ssl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("SslSslUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SslApiFetchParamCreator = SslApiFetchParamCreator;
/**
 * SslApi - functional programming interface
 * @export
 */
const SslApiFp = function (configuration) {
    return {
        /**
         * Retrieve the ssl settings. **Access policy**: administrator
         * @summary Inspect the ssl settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLInspect(options) {
            const localVarFetchArgs = (0, exports.SslApiFetchParamCreator)(configuration).sSLInspect(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the ssl settings. **Access policy**: administrator
         * @summary Update the ssl settings
         * @param {SslSslUpdatePayload} body SSL Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLUpdate(body, options) {
            const localVarFetchArgs = (0, exports.SslApiFetchParamCreator)(configuration).sSLUpdate(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.SslApiFp = SslApiFp;
/**
 * SslApi - factory interface
 * @export
 */
const SslApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Retrieve the ssl settings. **Access policy**: administrator
         * @summary Inspect the ssl settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLInspect(options) {
            return (0, exports.SslApiFp)(configuration).sSLInspect(options)(fetch, basePath);
        },
        /**
         * Update the ssl settings. **Access policy**: administrator
         * @summary Update the ssl settings
         * @param {SslSslUpdatePayload} body SSL Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLUpdate(body, options) {
            return (0, exports.SslApiFp)(configuration).sSLUpdate(body, options)(fetch, basePath);
        },
    };
};
exports.SslApiFactory = SslApiFactory;
/**
 * SslApi - object-oriented interface
 * @export
 * @class SslApi
 * @extends {BaseAPI}
 */
class SslApi extends BaseAPI {
    /**
     * Retrieve the ssl settings. **Access policy**: administrator
     * @summary Inspect the ssl settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SslApi
     */
    sSLInspect(options) {
        return (0, exports.SslApiFp)(this.configuration).sSLInspect(options)(this.fetch, this.basePath);
    }
    /**
     * Update the ssl settings. **Access policy**: administrator
     * @summary Update the ssl settings
     * @param {SslSslUpdatePayload} body SSL Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SslApi
     */
    sSLUpdate(body, options) {
        return (0, exports.SslApiFp)(this.configuration).sSLUpdate(body, options)(this.fetch, this.basePath);
    }
}
exports.SslApi = SslApi;
/**
 * StacksApi - fetch parameter creator
 * @export
 */
const StacksApiFetchParamCreator = function (configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Associate an orphaned stack to a new environment(endpoint)
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {number} swarmId Swarm identifier
         * @param {boolean} orphanedRunning Indicates whether the stack is orphaned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackAssociate(id, endpointId, swarmId, orphanedRunning, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling stackAssociate.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackAssociate.');
            }
            // verify required parameter 'swarmId' is not null or undefined
            if (swarmId === null || swarmId === undefined) {
                throw new RequiredError('swarmId', 'Required parameter swarmId was null or undefined when calling stackAssociate.');
            }
            // verify required parameter 'orphanedRunning' is not null or undefined
            if (orphanedRunning === null || orphanedRunning === undefined) {
                throw new RequiredError('orphanedRunning', 'Required parameter orphanedRunning was null or undefined when calling stackAssociate.');
            }
            const localVarPath = `/stacks/{id}/associate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            if (swarmId !== undefined) {
                localVarQueryParameter['swarmId'] = swarmId;
            }
            if (orphanedRunning !== undefined) {
                localVarQueryParameter['orphanedRunning'] = orphanedRunning;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment(endpoint) specified via the environment(endpoint) identifier. **Access policy**: authenticated
         * @summary Deploy a new stack
         * @param {number} type Stack deployment type. Possible values: 1 (Swarm stack), 2 (Compose stack) or 3 (Kubernetes stack).
         * @param {'string' | 'file' | 'repository' | 'url'} method Stack deployment method. Possible values: file, string, repository or url.
         * @param {number} endpointId Identifier of the environment(endpoint) that will be used to deploy the stack
         * @param {any} body for body documentation see the relevant /stacks/create/{type}/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreate(type, method, endpointId, body, options = {}) {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type', 'Required parameter type was null or undefined when calling stackCreate.');
            }
            // verify required parameter 'method' is not null or undefined
            if (method === null || method === undefined) {
                throw new RequiredError('method', 'Required parameter method was null or undefined when calling stackCreate.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackCreate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling stackCreate.');
            }
            const localVarPath = `/stacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("any" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a file
         * @param {string} name Name of the stack
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}].
         * @param {any} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneFile(name, endpointId, env, file, options = {}) {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling stackCreateDockerStandaloneFile.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackCreateDockerStandaloneFile.');
            }
            const localVarPath = `/stacks/create/standalone/file`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            if (name !== undefined) {
                localVarFormParams.set('Name', name);
            }
            if (env !== undefined) {
                localVarFormParams.set('Env', env);
            }
            if (file !== undefined) {
                localVarFormParams.set('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksComposeStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneRepository(endpointId, body, options = {}) {
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackCreateDockerStandaloneRepository.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling stackCreateDockerStandaloneRepository.');
            }
            const localVarPath = `/stacks/create/standalone/repository`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("StacksComposeStackFromGitRepositoryPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a text
         * @param {StacksComposeStackFromFileContentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneString(body, endpointId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling stackCreateDockerStandaloneString.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackCreateDockerStandaloneString.');
            }
            const localVarPath = `/stacks/create/standalone/string`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("StacksComposeStackFromFileContentPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [name] Name of the stack
         * @param {string} [swarmID] Swarm cluster identifier.
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}]. Optional
         * @param {any} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmFile(endpointId, name, swarmID, env, file, options = {}) {
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackCreateDockerSwarmFile.');
            }
            const localVarPath = `/stacks/create/swarm/file`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            if (name !== undefined) {
                localVarFormParams.set('Name', name);
            }
            if (swarmID !== undefined) {
                localVarFormParams.set('SwarmID', swarmID);
            }
            if (env !== undefined) {
                localVarFormParams.set('Env', env);
            }
            if (file !== undefined) {
                localVarFormParams.set('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a git repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksSwarmStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmRepository(endpointId, body, options = {}) {
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackCreateDockerSwarmRepository.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling stackCreateDockerSwarmRepository.');
            }
            const localVarPath = `/stacks/create/swarm/repository`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("StacksSwarmStackFromGitRepositoryPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a text
         * @param {StacksSwarmStackFromFileContentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmString(body, endpointId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling stackCreateDockerSwarmString.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackCreateDockerSwarmString.');
            }
            const localVarPath = `/stacks/create/swarm/string`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("StacksSwarmStackFromFileContentPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a file
         * @param {StacksKubernetesStringDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesFile(body, endpointId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling stackCreateKubernetesFile.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackCreateKubernetesFile.');
            }
            const localVarPath = `/stacks/create/kubernetes/string`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("StacksKubernetesStringDeploymentPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a git repository
         * @param {StacksKubernetesGitDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesGit(body, endpointId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling stackCreateKubernetesGit.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackCreateKubernetesGit.');
            }
            const localVarPath = `/stacks/create/kubernetes/repository`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("StacksKubernetesGitDeploymentPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a url
         * @param {StacksKubernetesManifestURLDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesUrl(body, endpointId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling stackCreateKubernetesUrl.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackCreateKubernetesUrl.');
            }
            const localVarPath = `/stacks/create/kubernetes/url`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("StacksKubernetesManifestURLDeploymentPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackDelete(id, endpointId, external, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling stackDelete.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackDelete.');
            }
            const localVarPath = `/stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (external !== undefined) {
                localVarQueryParameter['external'] = external;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove Kubernetes stacks by name
         * @param {string} name Stack name
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackDeleteKubernetesByName(name, endpointId, external, options = {}) {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling stackDeleteKubernetesByName.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackDeleteKubernetesByName.');
            }
            const localVarPath = `/stacks/name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (external !== undefined) {
                localVarQueryParameter['external'] = external;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Stack file content. **Access policy**: restricted
         * @summary Retrieve the content of the Stack file for the specified stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackFileInspect(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling stackFileInspect.');
            }
            const localVarPath = `/stacks/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pull and redeploy a stack via Git **Access policy**: authenticated
         * @summary Redeploy a stack
         * @param {number} id Stack identifier
         * @param {StacksStackGitRedployPayload} body Git configs for pull and redeploy of a stack. **StackName** may only be populated for Kuberenetes stacks, and if specified with a blank string, it will be set to blank
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackGitRedeploy(id, body, endpointId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling stackGitRedeploy.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling stackGitRedeploy.');
            }
            const localVarPath = `/stacks/{id}/git/redeploy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("StacksStackGitRedployPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a stack. **Access policy**: restricted
         * @summary Inspect a stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackInspect(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling stackInspect.');
            }
            const localVarPath = `/stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all stacks based on the current user authorizations. Will return all stacks if using an administrator account otherwise it will only return the list of stacks the user have access to. Limited stacks will not be returned by this endpoint. **Access policy**: authenticated
         * @summary List stacks
         * @param {string} [filters] Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {&#39;SwarmID&#39;: &#39;jpofkc0i9uo9wtx1zesuk649w&#39;} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackList(filters, options = {}) {
            const localVarPath = `/stacks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack. **Access policy**: authenticated
         * @summary Migrate a stack to another environment(endpoint)
         * @param {number} id Stack identifier
         * @param {StacksStackMigratePayload} body Stack migration details
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackMigrate(id, body, endpointId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling stackMigrate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling stackMigrate.');
            }
            const localVarPath = `/stacks/{id}/migrate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("StacksStackMigratePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a stopped Stack. **Access policy**: authenticated
         * @summary Starts a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStart(id, endpointId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling stackStart.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackStart.');
            }
            const localVarPath = `/stacks/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stops a stopped Stack. **Access policy**: authenticated
         * @summary Stops a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStop(id, endpointId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling stackStop.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackStop.');
            }
            const localVarPath = `/stacks/{id}/stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a stack, only for file based stacks. **Access policy**: authenticated
         * @summary Update a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {StacksUpdateSwarmStackPayload} body Stack details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdate(id, endpointId, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling stackUpdate.');
            }
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling stackUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling stackUpdate.');
            }
            const localVarPath = `/stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("StacksUpdateSwarmStackPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate **Access policy**: authenticated
         * @summary Update a stack's Git configs
         * @param {number} id Stack identifier
         * @param {StacksStackGitUpdatePayload} body Git configs for pull and redeploy a stack
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdateGit(id, body, endpointId, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling stackUpdateGit.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling stackUpdateGit.');
            }
            const localVarPath = `/stacks/{id}/git`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("StacksStackGitUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Webhook for triggering stack updates from git
         * @param {string} webhookID Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookInvoke(webhookID, options = {}) {
            // verify required parameter 'webhookID' is not null or undefined
            if (webhookID === null || webhookID === undefined) {
                throw new RequiredError('webhookID', 'Required parameter webhookID was null or undefined when calling webhookInvoke.');
            }
            const localVarPath = `/stacks/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.StacksApiFetchParamCreator = StacksApiFetchParamCreator;
/**
 * StacksApi - functional programming interface
 * @export
 */
const StacksApiFp = function (configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Associate an orphaned stack to a new environment(endpoint)
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {number} swarmId Swarm identifier
         * @param {boolean} orphanedRunning Indicates whether the stack is orphaned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackAssociate(id, endpointId, swarmId, orphanedRunning, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackAssociate(id, endpointId, swarmId, orphanedRunning, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment(endpoint) specified via the environment(endpoint) identifier. **Access policy**: authenticated
         * @summary Deploy a new stack
         * @param {number} type Stack deployment type. Possible values: 1 (Swarm stack), 2 (Compose stack) or 3 (Kubernetes stack).
         * @param {'string' | 'file' | 'repository' | 'url'} method Stack deployment method. Possible values: file, string, repository or url.
         * @param {number} endpointId Identifier of the environment(endpoint) that will be used to deploy the stack
         * @param {any} body for body documentation see the relevant /stacks/create/{type}/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreate(type, method, endpointId, body, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackCreate(type, method, endpointId, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a file
         * @param {string} name Name of the stack
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}].
         * @param {any} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneFile(name, endpointId, env, file, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackCreateDockerStandaloneFile(name, endpointId, env, file, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksComposeStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneRepository(endpointId, body, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackCreateDockerStandaloneRepository(endpointId, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a text
         * @param {StacksComposeStackFromFileContentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneString(body, endpointId, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackCreateDockerStandaloneString(body, endpointId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [name] Name of the stack
         * @param {string} [swarmID] Swarm cluster identifier.
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}]. Optional
         * @param {any} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmFile(endpointId, name, swarmID, env, file, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackCreateDockerSwarmFile(endpointId, name, swarmID, env, file, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a git repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksSwarmStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmRepository(endpointId, body, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackCreateDockerSwarmRepository(endpointId, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a text
         * @param {StacksSwarmStackFromFileContentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmString(body, endpointId, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackCreateDockerSwarmString(body, endpointId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a file
         * @param {StacksKubernetesStringDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesFile(body, endpointId, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackCreateKubernetesFile(body, endpointId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a git repository
         * @param {StacksKubernetesGitDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesGit(body, endpointId, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackCreateKubernetesGit(body, endpointId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a url
         * @param {StacksKubernetesManifestURLDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesUrl(body, endpointId, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackCreateKubernetesUrl(body, endpointId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackDelete(id, endpointId, external, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackDelete(id, endpointId, external, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove Kubernetes stacks by name
         * @param {string} name Stack name
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackDeleteKubernetesByName(name, endpointId, external, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackDeleteKubernetesByName(name, endpointId, external, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Stack file content. **Access policy**: restricted
         * @summary Retrieve the content of the Stack file for the specified stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackFileInspect(id, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackFileInspect(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Pull and redeploy a stack via Git **Access policy**: authenticated
         * @summary Redeploy a stack
         * @param {number} id Stack identifier
         * @param {StacksStackGitRedployPayload} body Git configs for pull and redeploy of a stack. **StackName** may only be populated for Kuberenetes stacks, and if specified with a blank string, it will be set to blank
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackGitRedeploy(id, body, endpointId, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackGitRedeploy(id, body, endpointId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details about a stack. **Access policy**: restricted
         * @summary Inspect a stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackInspect(id, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackInspect(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all stacks based on the current user authorizations. Will return all stacks if using an administrator account otherwise it will only return the list of stacks the user have access to. Limited stacks will not be returned by this endpoint. **Access policy**: authenticated
         * @summary List stacks
         * @param {string} [filters] Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {&#39;SwarmID&#39;: &#39;jpofkc0i9uo9wtx1zesuk649w&#39;} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackList(filters, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackList(filters, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack. **Access policy**: authenticated
         * @summary Migrate a stack to another environment(endpoint)
         * @param {number} id Stack identifier
         * @param {StacksStackMigratePayload} body Stack migration details
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackMigrate(id, body, endpointId, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackMigrate(id, body, endpointId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Starts a stopped Stack. **Access policy**: authenticated
         * @summary Starts a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStart(id, endpointId, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackStart(id, endpointId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Stops a stopped Stack. **Access policy**: authenticated
         * @summary Stops a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStop(id, endpointId, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackStop(id, endpointId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a stack, only for file based stacks. **Access policy**: authenticated
         * @summary Update a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {StacksUpdateSwarmStackPayload} body Stack details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdate(id, endpointId, body, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackUpdate(id, endpointId, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate **Access policy**: authenticated
         * @summary Update a stack's Git configs
         * @param {number} id Stack identifier
         * @param {StacksStackGitUpdatePayload} body Git configs for pull and redeploy a stack
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdateGit(id, body, endpointId, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).stackUpdateGit(id, body, endpointId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: public
         * @summary Webhook for triggering stack updates from git
         * @param {string} webhookID Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookInvoke(webhookID, options) {
            const localVarFetchArgs = (0, exports.StacksApiFetchParamCreator)(configuration).webhookInvoke(webhookID, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.StacksApiFp = StacksApiFp;
/**
 * StacksApi - factory interface
 * @export
 */
const StacksApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Associate an orphaned stack to a new environment(endpoint)
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {number} swarmId Swarm identifier
         * @param {boolean} orphanedRunning Indicates whether the stack is orphaned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackAssociate(id, endpointId, swarmId, orphanedRunning, options) {
            return (0, exports.StacksApiFp)(configuration).stackAssociate(id, endpointId, swarmId, orphanedRunning, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment(endpoint) specified via the environment(endpoint) identifier. **Access policy**: authenticated
         * @summary Deploy a new stack
         * @param {number} type Stack deployment type. Possible values: 1 (Swarm stack), 2 (Compose stack) or 3 (Kubernetes stack).
         * @param {'string' | 'file' | 'repository' | 'url'} method Stack deployment method. Possible values: file, string, repository or url.
         * @param {number} endpointId Identifier of the environment(endpoint) that will be used to deploy the stack
         * @param {any} body for body documentation see the relevant /stacks/create/{type}/{method} endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreate(type, method, endpointId, body, options) {
            return (0, exports.StacksApiFp)(configuration).stackCreate(type, method, endpointId, body, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a file
         * @param {string} name Name of the stack
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}].
         * @param {any} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneFile(name, endpointId, env, file, options) {
            return (0, exports.StacksApiFp)(configuration).stackCreateDockerStandaloneFile(name, endpointId, env, file, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksComposeStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneRepository(endpointId, body, options) {
            return (0, exports.StacksApiFp)(configuration).stackCreateDockerStandaloneRepository(endpointId, body, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a text
         * @param {StacksComposeStackFromFileContentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneString(body, endpointId, options) {
            return (0, exports.StacksApiFp)(configuration).stackCreateDockerStandaloneString(body, endpointId, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [name] Name of the stack
         * @param {string} [swarmID] Swarm cluster identifier.
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}]. Optional
         * @param {any} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmFile(endpointId, name, swarmID, env, file, options) {
            return (0, exports.StacksApiFp)(configuration).stackCreateDockerSwarmFile(endpointId, name, swarmID, env, file, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a git repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksSwarmStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmRepository(endpointId, body, options) {
            return (0, exports.StacksApiFp)(configuration).stackCreateDockerSwarmRepository(endpointId, body, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a text
         * @param {StacksSwarmStackFromFileContentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmString(body, endpointId, options) {
            return (0, exports.StacksApiFp)(configuration).stackCreateDockerSwarmString(body, endpointId, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a file
         * @param {StacksKubernetesStringDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesFile(body, endpointId, options) {
            return (0, exports.StacksApiFp)(configuration).stackCreateKubernetesFile(body, endpointId, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a git repository
         * @param {StacksKubernetesGitDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesGit(body, endpointId, options) {
            return (0, exports.StacksApiFp)(configuration).stackCreateKubernetesGit(body, endpointId, options)(fetch, basePath);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a url
         * @param {StacksKubernetesManifestURLDeploymentPayload} body stack config
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesUrl(body, endpointId, options) {
            return (0, exports.StacksApiFp)(configuration).stackCreateKubernetesUrl(body, endpointId, options)(fetch, basePath);
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackDelete(id, endpointId, external, options) {
            return (0, exports.StacksApiFp)(configuration).stackDelete(id, endpointId, external, options)(fetch, basePath);
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove Kubernetes stacks by name
         * @param {string} name Stack name
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackDeleteKubernetesByName(name, endpointId, external, options) {
            return (0, exports.StacksApiFp)(configuration).stackDeleteKubernetesByName(name, endpointId, external, options)(fetch, basePath);
        },
        /**
         * Get Stack file content. **Access policy**: restricted
         * @summary Retrieve the content of the Stack file for the specified stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackFileInspect(id, options) {
            return (0, exports.StacksApiFp)(configuration).stackFileInspect(id, options)(fetch, basePath);
        },
        /**
         * Pull and redeploy a stack via Git **Access policy**: authenticated
         * @summary Redeploy a stack
         * @param {number} id Stack identifier
         * @param {StacksStackGitRedployPayload} body Git configs for pull and redeploy of a stack. **StackName** may only be populated for Kuberenetes stacks, and if specified with a blank string, it will be set to blank
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackGitRedeploy(id, body, endpointId, options) {
            return (0, exports.StacksApiFp)(configuration).stackGitRedeploy(id, body, endpointId, options)(fetch, basePath);
        },
        /**
         * Retrieve details about a stack. **Access policy**: restricted
         * @summary Inspect a stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackInspect(id, options) {
            return (0, exports.StacksApiFp)(configuration).stackInspect(id, options)(fetch, basePath);
        },
        /**
         * List all stacks based on the current user authorizations. Will return all stacks if using an administrator account otherwise it will only return the list of stacks the user have access to. Limited stacks will not be returned by this endpoint. **Access policy**: authenticated
         * @summary List stacks
         * @param {string} [filters] Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {&#39;SwarmID&#39;: &#39;jpofkc0i9uo9wtx1zesuk649w&#39;} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackList(filters, options) {
            return (0, exports.StacksApiFp)(configuration).stackList(filters, options)(fetch, basePath);
        },
        /**
         * Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack. **Access policy**: authenticated
         * @summary Migrate a stack to another environment(endpoint)
         * @param {number} id Stack identifier
         * @param {StacksStackMigratePayload} body Stack migration details
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackMigrate(id, body, endpointId, options) {
            return (0, exports.StacksApiFp)(configuration).stackMigrate(id, body, endpointId, options)(fetch, basePath);
        },
        /**
         * Starts a stopped Stack. **Access policy**: authenticated
         * @summary Starts a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStart(id, endpointId, options) {
            return (0, exports.StacksApiFp)(configuration).stackStart(id, endpointId, options)(fetch, basePath);
        },
        /**
         * Stops a stopped Stack. **Access policy**: authenticated
         * @summary Stops a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStop(id, endpointId, options) {
            return (0, exports.StacksApiFp)(configuration).stackStop(id, endpointId, options)(fetch, basePath);
        },
        /**
         * Update a stack, only for file based stacks. **Access policy**: authenticated
         * @summary Update a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {StacksUpdateSwarmStackPayload} body Stack details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdate(id, endpointId, body, options) {
            return (0, exports.StacksApiFp)(configuration).stackUpdate(id, endpointId, body, options)(fetch, basePath);
        },
        /**
         * Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate **Access policy**: authenticated
         * @summary Update a stack's Git configs
         * @param {number} id Stack identifier
         * @param {StacksStackGitUpdatePayload} body Git configs for pull and redeploy a stack
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdateGit(id, body, endpointId, options) {
            return (0, exports.StacksApiFp)(configuration).stackUpdateGit(id, body, endpointId, options)(fetch, basePath);
        },
        /**
         * **Access policy**: public
         * @summary Webhook for triggering stack updates from git
         * @param {string} webhookID Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookInvoke(webhookID, options) {
            return (0, exports.StacksApiFp)(configuration).webhookInvoke(webhookID, options)(fetch, basePath);
        },
    };
};
exports.StacksApiFactory = StacksApiFactory;
/**
 * StacksApi - object-oriented interface
 * @export
 * @class StacksApi
 * @extends {BaseAPI}
 */
class StacksApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Associate an orphaned stack to a new environment(endpoint)
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {number} swarmId Swarm identifier
     * @param {boolean} orphanedRunning Indicates whether the stack is orphaned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackAssociate(id, endpointId, swarmId, orphanedRunning, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackAssociate(id, endpointId, swarmId, orphanedRunning, options)(this.fetch, this.basePath);
    }
    /**
     * Deploy a new stack into a Docker environment(endpoint) specified via the environment(endpoint) identifier. **Access policy**: authenticated
     * @summary Deploy a new stack
     * @param {number} type Stack deployment type. Possible values: 1 (Swarm stack), 2 (Compose stack) or 3 (Kubernetes stack).
     * @param {'string' | 'file' | 'repository' | 'url'} method Stack deployment method. Possible values: file, string, repository or url.
     * @param {number} endpointId Identifier of the environment(endpoint) that will be used to deploy the stack
     * @param {any} body for body documentation see the relevant /stacks/create/{type}/{method} endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackCreate(type, method, endpointId, body, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackCreate(type, method, endpointId, body, options)(this.fetch, this.basePath);
    }
    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new compose stack from a file
     * @param {string} name Name of the stack
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}].
     * @param {any} [file] Stack file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackCreateDockerStandaloneFile(name, endpointId, env, file, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackCreateDockerStandaloneFile(name, endpointId, env, file, options)(this.fetch, this.basePath);
    }
    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new compose stack from repository
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {StacksComposeStackFromGitRepositoryPayload} body stack config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackCreateDockerStandaloneRepository(endpointId, body, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackCreateDockerStandaloneRepository(endpointId, body, options)(this.fetch, this.basePath);
    }
    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new compose stack from a text
     * @param {StacksComposeStackFromFileContentPayload} body stack config
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackCreateDockerStandaloneString(body, endpointId, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackCreateDockerStandaloneString(body, endpointId, options)(this.fetch, this.basePath);
    }
    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new swarm stack from a file
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {string} [name] Name of the stack
     * @param {string} [swarmID] Swarm cluster identifier.
     * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{&#39;name&#39;: &#39;name&#39;, &#39;value&#39;: &#39;value&#39;}]. Optional
     * @param {any} [file] Stack file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackCreateDockerSwarmFile(endpointId, name, swarmID, env, file, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackCreateDockerSwarmFile(endpointId, name, swarmID, env, file, options)(this.fetch, this.basePath);
    }
    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new swarm stack from a git repository
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {StacksSwarmStackFromGitRepositoryPayload} body stack config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackCreateDockerSwarmRepository(endpointId, body, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackCreateDockerSwarmRepository(endpointId, body, options)(this.fetch, this.basePath);
    }
    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new swarm stack from a text
     * @param {StacksSwarmStackFromFileContentPayload} body stack config
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackCreateDockerSwarmString(body, endpointId, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackCreateDockerSwarmString(body, endpointId, options)(this.fetch, this.basePath);
    }
    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new kubernetes stack from a file
     * @param {StacksKubernetesStringDeploymentPayload} body stack config
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackCreateKubernetesFile(body, endpointId, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackCreateKubernetesFile(body, endpointId, options)(this.fetch, this.basePath);
    }
    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new kubernetes stack from a git repository
     * @param {StacksKubernetesGitDeploymentPayload} body stack config
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackCreateKubernetesGit(body, endpointId, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackCreateKubernetesGit(body, endpointId, options)(this.fetch, this.basePath);
    }
    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new kubernetes stack from a url
     * @param {StacksKubernetesManifestURLDeploymentPayload} body stack config
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackCreateKubernetesUrl(body, endpointId, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackCreateKubernetesUrl(body, endpointId, options)(this.fetch, this.basePath);
    }
    /**
     * Remove a stack. **Access policy**: restricted
     * @summary Remove a stack
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackDelete(id, endpointId, external, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackDelete(id, endpointId, external, options)(this.fetch, this.basePath);
    }
    /**
     * Remove a stack. **Access policy**: restricted
     * @summary Remove Kubernetes stacks by name
     * @param {string} name Stack name
     * @param {number} endpointId Environment identifier
     * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackDeleteKubernetesByName(name, endpointId, external, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackDeleteKubernetesByName(name, endpointId, external, options)(this.fetch, this.basePath);
    }
    /**
     * Get Stack file content. **Access policy**: restricted
     * @summary Retrieve the content of the Stack file for the specified stack
     * @param {number} id Stack identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackFileInspect(id, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackFileInspect(id, options)(this.fetch, this.basePath);
    }
    /**
     * Pull and redeploy a stack via Git **Access policy**: authenticated
     * @summary Redeploy a stack
     * @param {number} id Stack identifier
     * @param {StacksStackGitRedployPayload} body Git configs for pull and redeploy of a stack. **StackName** may only be populated for Kuberenetes stacks, and if specified with a blank string, it will be set to blank
     * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackGitRedeploy(id, body, endpointId, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackGitRedeploy(id, body, endpointId, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve details about a stack. **Access policy**: restricted
     * @summary Inspect a stack
     * @param {number} id Stack identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackInspect(id, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackInspect(id, options)(this.fetch, this.basePath);
    }
    /**
     * List all stacks based on the current user authorizations. Will return all stacks if using an administrator account otherwise it will only return the list of stacks the user have access to. Limited stacks will not be returned by this endpoint. **Access policy**: authenticated
     * @summary List stacks
     * @param {string} [filters] Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {&#39;SwarmID&#39;: &#39;jpofkc0i9uo9wtx1zesuk649w&#39;} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackList(filters, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackList(filters, options)(this.fetch, this.basePath);
    }
    /**
     * Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack. **Access policy**: authenticated
     * @summary Migrate a stack to another environment(endpoint)
     * @param {number} id Stack identifier
     * @param {StacksStackMigratePayload} body Stack migration details
     * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackMigrate(id, body, endpointId, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackMigrate(id, body, endpointId, options)(this.fetch, this.basePath);
    }
    /**
     * Starts a stopped Stack. **Access policy**: authenticated
     * @summary Starts a stopped Stack
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackStart(id, endpointId, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackStart(id, endpointId, options)(this.fetch, this.basePath);
    }
    /**
     * Stops a stopped Stack. **Access policy**: authenticated
     * @summary Stops a stopped Stack
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackStop(id, endpointId, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackStop(id, endpointId, options)(this.fetch, this.basePath);
    }
    /**
     * Update a stack, only for file based stacks. **Access policy**: authenticated
     * @summary Update a stack
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {StacksUpdateSwarmStackPayload} body Stack details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackUpdate(id, endpointId, body, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackUpdate(id, endpointId, body, options)(this.fetch, this.basePath);
    }
    /**
     * Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate **Access policy**: authenticated
     * @summary Update a stack's Git configs
     * @param {number} id Stack identifier
     * @param {StacksStackGitUpdatePayload} body Git configs for pull and redeploy a stack
     * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    stackUpdateGit(id, body, endpointId, options) {
        return (0, exports.StacksApiFp)(this.configuration).stackUpdateGit(id, body, endpointId, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: public
     * @summary Webhook for triggering stack updates from git
     * @param {string} webhookID Stack identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    webhookInvoke(webhookID, options) {
        return (0, exports.StacksApiFp)(this.configuration).webhookInvoke(webhookID, options)(this.fetch, this.basePath);
    }
}
exports.StacksApi = StacksApi;
/**
 * StatusApi - fetch parameter creator
 * @export
 */
const StatusApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Deprecated: use the `/system/status` endpoint instead. Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusInspect(options = {}) {
            const localVarPath = `/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deprecated: use the `/system/nodes` endpoint instead. **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusNodesCount(options = {}) {
            const localVarPath = `/status/nodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deprecated: use the `/system/version` endpoint instead. Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options = {}) {
            const localVarPath = `/status/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.StatusApiFetchParamCreator = StatusApiFetchParamCreator;
/**
 * StatusApi - functional programming interface
 * @export
 */
const StatusApiFp = function (configuration) {
    return {
        /**
         * Deprecated: use the `/system/status` endpoint instead. Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusInspect(options) {
            const localVarFetchArgs = (0, exports.StatusApiFetchParamCreator)(configuration).statusInspect(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deprecated: use the `/system/nodes` endpoint instead. **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusNodesCount(options) {
            const localVarFetchArgs = (0, exports.StatusApiFetchParamCreator)(configuration).statusNodesCount(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deprecated: use the `/system/version` endpoint instead. Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options) {
            const localVarFetchArgs = (0, exports.StatusApiFetchParamCreator)(configuration).version(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.StatusApiFp = StatusApiFp;
/**
 * StatusApi - factory interface
 * @export
 */
const StatusApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Deprecated: use the `/system/status` endpoint instead. Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusInspect(options) {
            return (0, exports.StatusApiFp)(configuration).statusInspect(options)(fetch, basePath);
        },
        /**
         * Deprecated: use the `/system/nodes` endpoint instead. **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusNodesCount(options) {
            return (0, exports.StatusApiFp)(configuration).statusNodesCount(options)(fetch, basePath);
        },
        /**
         * Deprecated: use the `/system/version` endpoint instead. Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        version(options) {
            return (0, exports.StatusApiFp)(configuration).version(options)(fetch, basePath);
        },
    };
};
exports.StatusApiFactory = StatusApiFactory;
/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
class StatusApi extends BaseAPI {
    /**
     * Deprecated: use the `/system/status` endpoint instead. Retrieve Portainer status **Access policy**: public
     * @summary Check Portainer status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    statusInspect(options) {
        return (0, exports.StatusApiFp)(this.configuration).statusInspect(options)(this.fetch, this.basePath);
    }
    /**
     * Deprecated: use the `/system/nodes` endpoint instead. **Access policy**: authenticated
     * @summary Retrieve the count of nodes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    statusNodesCount(options) {
        return (0, exports.StatusApiFp)(this.configuration).statusNodesCount(options)(this.fetch, this.basePath);
    }
    /**
     * Deprecated: use the `/system/version` endpoint instead. Check if portainer has an update available **Access policy**: authenticated
     * @summary Check for portainer updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    version(options) {
        return (0, exports.StatusApiFp)(this.configuration).version(options)(this.fetch, this.basePath);
    }
}
exports.StatusApi = StatusApi;
/**
 * SystemApi - fetch parameter creator
 * @export
 */
const SystemApiFetchParamCreator = function (configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary Retrieve system info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfo(options = {}) {
            const localVarPath = `/system/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemNodesCount(options = {}) {
            const localVarPath = `/system/nodes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemStatus(options = {}) {
            const localVarPath = `/system/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upgrade Portainer to BE **Access policy**: administrator
         * @summary Upgrade Portainer to BE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUpgrade(options = {}) {
            const localVarPath = `/system/upgrade`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemVersion(options = {}) {
            const localVarPath = `/system/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SystemApiFetchParamCreator = SystemApiFetchParamCreator;
/**
 * SystemApi - functional programming interface
 * @export
 */
const SystemApiFp = function (configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary Retrieve system info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfo(options) {
            const localVarFetchArgs = (0, exports.SystemApiFetchParamCreator)(configuration).systemInfo(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemNodesCount(options) {
            const localVarFetchArgs = (0, exports.SystemApiFetchParamCreator)(configuration).systemNodesCount(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemStatus(options) {
            const localVarFetchArgs = (0, exports.SystemApiFetchParamCreator)(configuration).systemStatus(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Upgrade Portainer to BE **Access policy**: administrator
         * @summary Upgrade Portainer to BE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUpgrade(options) {
            const localVarFetchArgs = (0, exports.SystemApiFetchParamCreator)(configuration).systemUpgrade(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemVersion(options) {
            const localVarFetchArgs = (0, exports.SystemApiFetchParamCreator)(configuration).systemVersion(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.SystemApiFp = SystemApiFp;
/**
 * SystemApi - factory interface
 * @export
 */
const SystemApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary Retrieve system info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfo(options) {
            return (0, exports.SystemApiFp)(configuration).systemInfo(options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemNodesCount(options) {
            return (0, exports.SystemApiFp)(configuration).systemNodesCount(options)(fetch, basePath);
        },
        /**
         * Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemStatus(options) {
            return (0, exports.SystemApiFp)(configuration).systemStatus(options)(fetch, basePath);
        },
        /**
         * Upgrade Portainer to BE **Access policy**: administrator
         * @summary Upgrade Portainer to BE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUpgrade(options) {
            return (0, exports.SystemApiFp)(configuration).systemUpgrade(options)(fetch, basePath);
        },
        /**
         * Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemVersion(options) {
            return (0, exports.SystemApiFp)(configuration).systemVersion(options)(fetch, basePath);
        },
    };
};
exports.SystemApiFactory = SystemApiFactory;
/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
class SystemApi extends BaseAPI {
    /**
     * **Access policy**: authenticated
     * @summary Retrieve system info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    systemInfo(options) {
        return (0, exports.SystemApiFp)(this.configuration).systemInfo(options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: authenticated
     * @summary Retrieve the count of nodes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    systemNodesCount(options) {
        return (0, exports.SystemApiFp)(this.configuration).systemNodesCount(options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve Portainer status **Access policy**: public
     * @summary Check Portainer status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    systemStatus(options) {
        return (0, exports.SystemApiFp)(this.configuration).systemStatus(options)(this.fetch, this.basePath);
    }
    /**
     * Upgrade Portainer to BE **Access policy**: administrator
     * @summary Upgrade Portainer to BE
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    systemUpgrade(options) {
        return (0, exports.SystemApiFp)(this.configuration).systemUpgrade(options)(this.fetch, this.basePath);
    }
    /**
     * Check if portainer has an update available **Access policy**: authenticated
     * @summary Check for portainer updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    systemVersion(options) {
        return (0, exports.SystemApiFp)(this.configuration).systemVersion(options)(this.fetch, this.basePath);
    }
}
exports.SystemApi = SystemApi;
/**
 * TagsApi - fetch parameter creator
 * @export
 */
const TagsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Create a new tag. **Access policy**: administrator
         * @summary Create a new tag
         * @param {TagsTagCreatePayload} body Tag details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagCreate(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling tagCreate.');
            }
            const localVarPath = `/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("TagsTagCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag. **Access policy**: administrator
         * @summary Remove a tag
         * @param {number} id Tag identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling tagDelete.');
            }
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List tags. **Access policy**: authenticated
         * @summary List tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagList(options = {}) {
            const localVarPath = `/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TagsApiFetchParamCreator = TagsApiFetchParamCreator;
/**
 * TagsApi - functional programming interface
 * @export
 */
const TagsApiFp = function (configuration) {
    return {
        /**
         * Create a new tag. **Access policy**: administrator
         * @summary Create a new tag
         * @param {TagsTagCreatePayload} body Tag details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagCreate(body, options) {
            const localVarFetchArgs = (0, exports.TagsApiFetchParamCreator)(configuration).tagCreate(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a tag. **Access policy**: administrator
         * @summary Remove a tag
         * @param {number} id Tag identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDelete(id, options) {
            const localVarFetchArgs = (0, exports.TagsApiFetchParamCreator)(configuration).tagDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List tags. **Access policy**: authenticated
         * @summary List tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagList(options) {
            const localVarFetchArgs = (0, exports.TagsApiFetchParamCreator)(configuration).tagList(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.TagsApiFp = TagsApiFp;
/**
 * TagsApi - factory interface
 * @export
 */
const TagsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Create a new tag. **Access policy**: administrator
         * @summary Create a new tag
         * @param {TagsTagCreatePayload} body Tag details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagCreate(body, options) {
            return (0, exports.TagsApiFp)(configuration).tagCreate(body, options)(fetch, basePath);
        },
        /**
         * Remove a tag. **Access policy**: administrator
         * @summary Remove a tag
         * @param {number} id Tag identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDelete(id, options) {
            return (0, exports.TagsApiFp)(configuration).tagDelete(id, options)(fetch, basePath);
        },
        /**
         * List tags. **Access policy**: authenticated
         * @summary List tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagList(options) {
            return (0, exports.TagsApiFp)(configuration).tagList(options)(fetch, basePath);
        },
    };
};
exports.TagsApiFactory = TagsApiFactory;
/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
class TagsApi extends BaseAPI {
    /**
     * Create a new tag. **Access policy**: administrator
     * @summary Create a new tag
     * @param {TagsTagCreatePayload} body Tag details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    tagCreate(body, options) {
        return (0, exports.TagsApiFp)(this.configuration).tagCreate(body, options)(this.fetch, this.basePath);
    }
    /**
     * Remove a tag. **Access policy**: administrator
     * @summary Remove a tag
     * @param {number} id Tag identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    tagDelete(id, options) {
        return (0, exports.TagsApiFp)(this.configuration).tagDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     * List tags. **Access policy**: authenticated
     * @summary List tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    tagList(options) {
        return (0, exports.TagsApiFp)(this.configuration).tagList(options)(this.fetch, this.basePath);
    }
}
exports.TagsApi = TagsApi;
/**
 * TeamMembershipsApi - fetch parameter creator
 * @export
 */
const TeamMembershipsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Create a new team memberships. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Create a new team membership
         * @param {TeammembershipsTeamMembershipCreatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipCreate(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling teamMembershipCreate.');
            }
            const localVarPath = `/team_memberships`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("TeammembershipsTeamMembershipCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a team membership. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Remove a team membership
         * @param {number} id TeamMembership identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling teamMembershipDelete.');
            }
            const localVarPath = `/team_memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: administrator
         * @summary List team memberships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipList(options = {}) {
            const localVarPath = `/team_memberships`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a team membership. Access is only available to administrators or leaders of the associated team. **Access policy**: administrator or leaders of the associated team
         * @summary Update a team membership
         * @param {number} id Team membership identifier
         * @param {TeammembershipsTeamMembershipUpdatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipUpdate(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling teamMembershipUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling teamMembershipUpdate.');
            }
            const localVarPath = `/team_memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("TeammembershipsTeamMembershipUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: restricted
         * @summary List team memberships
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberships(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling teamMemberships.');
            }
            const localVarPath = `/teams/{id}/memberships`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TeamMembershipsApiFetchParamCreator = TeamMembershipsApiFetchParamCreator;
/**
 * TeamMembershipsApi - functional programming interface
 * @export
 */
const TeamMembershipsApiFp = function (configuration) {
    return {
        /**
         * Create a new team memberships. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Create a new team membership
         * @param {TeammembershipsTeamMembershipCreatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipCreate(body, options) {
            const localVarFetchArgs = (0, exports.TeamMembershipsApiFetchParamCreator)(configuration).teamMembershipCreate(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a team membership. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Remove a team membership
         * @param {number} id TeamMembership identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipDelete(id, options) {
            const localVarFetchArgs = (0, exports.TeamMembershipsApiFetchParamCreator)(configuration).teamMembershipDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: administrator
         * @summary List team memberships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipList(options) {
            const localVarFetchArgs = (0, exports.TeamMembershipsApiFetchParamCreator)(configuration).teamMembershipList(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a team membership. Access is only available to administrators or leaders of the associated team. **Access policy**: administrator or leaders of the associated team
         * @summary Update a team membership
         * @param {number} id Team membership identifier
         * @param {TeammembershipsTeamMembershipUpdatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipUpdate(id, body, options) {
            const localVarFetchArgs = (0, exports.TeamMembershipsApiFetchParamCreator)(configuration).teamMembershipUpdate(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: restricted
         * @summary List team memberships
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberships(id, options) {
            const localVarFetchArgs = (0, exports.TeamMembershipsApiFetchParamCreator)(configuration).teamMemberships(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.TeamMembershipsApiFp = TeamMembershipsApiFp;
/**
 * TeamMembershipsApi - factory interface
 * @export
 */
const TeamMembershipsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Create a new team memberships. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Create a new team membership
         * @param {TeammembershipsTeamMembershipCreatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipCreate(body, options) {
            return (0, exports.TeamMembershipsApiFp)(configuration).teamMembershipCreate(body, options)(fetch, basePath);
        },
        /**
         * Remove a team membership. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Remove a team membership
         * @param {number} id TeamMembership identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipDelete(id, options) {
            return (0, exports.TeamMembershipsApiFp)(configuration).teamMembershipDelete(id, options)(fetch, basePath);
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: administrator
         * @summary List team memberships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipList(options) {
            return (0, exports.TeamMembershipsApiFp)(configuration).teamMembershipList(options)(fetch, basePath);
        },
        /**
         * Update a team membership. Access is only available to administrators or leaders of the associated team. **Access policy**: administrator or leaders of the associated team
         * @summary Update a team membership
         * @param {number} id Team membership identifier
         * @param {TeammembershipsTeamMembershipUpdatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipUpdate(id, body, options) {
            return (0, exports.TeamMembershipsApiFp)(configuration).teamMembershipUpdate(id, body, options)(fetch, basePath);
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: restricted
         * @summary List team memberships
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberships(id, options) {
            return (0, exports.TeamMembershipsApiFp)(configuration).teamMemberships(id, options)(fetch, basePath);
        },
    };
};
exports.TeamMembershipsApiFactory = TeamMembershipsApiFactory;
/**
 * TeamMembershipsApi - object-oriented interface
 * @export
 * @class TeamMembershipsApi
 * @extends {BaseAPI}
 */
class TeamMembershipsApi extends BaseAPI {
    /**
     * Create a new team memberships. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
     * @summary Create a new team membership
     * @param {TeammembershipsTeamMembershipCreatePayload} body Team membership details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    teamMembershipCreate(body, options) {
        return (0, exports.TeamMembershipsApiFp)(this.configuration).teamMembershipCreate(body, options)(this.fetch, this.basePath);
    }
    /**
     * Remove a team membership. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
     * @summary Remove a team membership
     * @param {number} id TeamMembership identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    teamMembershipDelete(id, options) {
        return (0, exports.TeamMembershipsApiFp)(this.configuration).teamMembershipDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     * List team memberships. Access is only available to administrators and team leaders. **Access policy**: administrator
     * @summary List team memberships
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    teamMembershipList(options) {
        return (0, exports.TeamMembershipsApiFp)(this.configuration).teamMembershipList(options)(this.fetch, this.basePath);
    }
    /**
     * Update a team membership. Access is only available to administrators or leaders of the associated team. **Access policy**: administrator or leaders of the associated team
     * @summary Update a team membership
     * @param {number} id Team membership identifier
     * @param {TeammembershipsTeamMembershipUpdatePayload} body Team membership details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    teamMembershipUpdate(id, body, options) {
        return (0, exports.TeamMembershipsApiFp)(this.configuration).teamMembershipUpdate(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * List team memberships. Access is only available to administrators and team leaders. **Access policy**: restricted
     * @summary List team memberships
     * @param {number} id Team Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    teamMemberships(id, options) {
        return (0, exports.TeamMembershipsApiFp)(this.configuration).teamMemberships(id, options)(this.fetch, this.basePath);
    }
}
exports.TeamMembershipsApi = TeamMembershipsApi;
/**
 * TeamsApi - fetch parameter creator
 * @export
 */
const TeamsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Create a new team. **Access policy**: administrator
         * @summary Create a new team
         * @param {TeamsTeamCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamCreate(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling teamCreate.');
            }
            const localVarPath = `/teams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("TeamsTeamCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a team. **Access policy**: administrator
         * @summary Remove a team
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling teamDelete.');
            }
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a team. Access is only available for administrator and leaders of that team. **Access policy**: administrator
         * @summary Inspect a team
         * @param {number} id Team identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamInspect(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling teamInspect.');
            }
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List teams. For non-administrator users, will only list the teams they are member of. **Access policy**: restricted
         * @summary List teams
         * @param {boolean} [onlyLedTeams] Only list teams that the user is leader of
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamList(onlyLedTeams, environmentId, options = {}) {
            const localVarPath = `/teams`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (onlyLedTeams !== undefined) {
                localVarQueryParameter['onlyLedTeams'] = onlyLedTeams;
            }
            if (environmentId !== undefined) {
                localVarQueryParameter['environmentId'] = environmentId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a team. **Access policy**: administrator
         * @summary Update a team
         * @param {number} id Team identifier
         * @param {TeamsTeamUpdatePayload} body Team details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamUpdate(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling teamUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling teamUpdate.');
            }
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("TeamsTeamUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TeamsApiFetchParamCreator = TeamsApiFetchParamCreator;
/**
 * TeamsApi - functional programming interface
 * @export
 */
const TeamsApiFp = function (configuration) {
    return {
        /**
         * Create a new team. **Access policy**: administrator
         * @summary Create a new team
         * @param {TeamsTeamCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamCreate(body, options) {
            const localVarFetchArgs = (0, exports.TeamsApiFetchParamCreator)(configuration).teamCreate(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a team. **Access policy**: administrator
         * @summary Remove a team
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDelete(id, options) {
            const localVarFetchArgs = (0, exports.TeamsApiFetchParamCreator)(configuration).teamDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details about a team. Access is only available for administrator and leaders of that team. **Access policy**: administrator
         * @summary Inspect a team
         * @param {number} id Team identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamInspect(id, options) {
            const localVarFetchArgs = (0, exports.TeamsApiFetchParamCreator)(configuration).teamInspect(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List teams. For non-administrator users, will only list the teams they are member of. **Access policy**: restricted
         * @summary List teams
         * @param {boolean} [onlyLedTeams] Only list teams that the user is leader of
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamList(onlyLedTeams, environmentId, options) {
            const localVarFetchArgs = (0, exports.TeamsApiFetchParamCreator)(configuration).teamList(onlyLedTeams, environmentId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a team. **Access policy**: administrator
         * @summary Update a team
         * @param {number} id Team identifier
         * @param {TeamsTeamUpdatePayload} body Team details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamUpdate(id, body, options) {
            const localVarFetchArgs = (0, exports.TeamsApiFetchParamCreator)(configuration).teamUpdate(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.TeamsApiFp = TeamsApiFp;
/**
 * TeamsApi - factory interface
 * @export
 */
const TeamsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Create a new team. **Access policy**: administrator
         * @summary Create a new team
         * @param {TeamsTeamCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamCreate(body, options) {
            return (0, exports.TeamsApiFp)(configuration).teamCreate(body, options)(fetch, basePath);
        },
        /**
         * Remove a team. **Access policy**: administrator
         * @summary Remove a team
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDelete(id, options) {
            return (0, exports.TeamsApiFp)(configuration).teamDelete(id, options)(fetch, basePath);
        },
        /**
         * Retrieve details about a team. Access is only available for administrator and leaders of that team. **Access policy**: administrator
         * @summary Inspect a team
         * @param {number} id Team identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamInspect(id, options) {
            return (0, exports.TeamsApiFp)(configuration).teamInspect(id, options)(fetch, basePath);
        },
        /**
         * List teams. For non-administrator users, will only list the teams they are member of. **Access policy**: restricted
         * @summary List teams
         * @param {boolean} [onlyLedTeams] Only list teams that the user is leader of
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamList(onlyLedTeams, environmentId, options) {
            return (0, exports.TeamsApiFp)(configuration).teamList(onlyLedTeams, environmentId, options)(fetch, basePath);
        },
        /**
         * Update a team. **Access policy**: administrator
         * @summary Update a team
         * @param {number} id Team identifier
         * @param {TeamsTeamUpdatePayload} body Team details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamUpdate(id, body, options) {
            return (0, exports.TeamsApiFp)(configuration).teamUpdate(id, body, options)(fetch, basePath);
        },
    };
};
exports.TeamsApiFactory = TeamsApiFactory;
/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
class TeamsApi extends BaseAPI {
    /**
     * Create a new team. **Access policy**: administrator
     * @summary Create a new team
     * @param {TeamsTeamCreatePayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    teamCreate(body, options) {
        return (0, exports.TeamsApiFp)(this.configuration).teamCreate(body, options)(this.fetch, this.basePath);
    }
    /**
     * Remove a team. **Access policy**: administrator
     * @summary Remove a team
     * @param {number} id Team Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    teamDelete(id, options) {
        return (0, exports.TeamsApiFp)(this.configuration).teamDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve details about a team. Access is only available for administrator and leaders of that team. **Access policy**: administrator
     * @summary Inspect a team
     * @param {number} id Team identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    teamInspect(id, options) {
        return (0, exports.TeamsApiFp)(this.configuration).teamInspect(id, options)(this.fetch, this.basePath);
    }
    /**
     * List teams. For non-administrator users, will only list the teams they are member of. **Access policy**: restricted
     * @summary List teams
     * @param {boolean} [onlyLedTeams] Only list teams that the user is leader of
     * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized teams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    teamList(onlyLedTeams, environmentId, options) {
        return (0, exports.TeamsApiFp)(this.configuration).teamList(onlyLedTeams, environmentId, options)(this.fetch, this.basePath);
    }
    /**
     * Update a team. **Access policy**: administrator
     * @summary Update a team
     * @param {number} id Team identifier
     * @param {TeamsTeamUpdatePayload} body Team details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    teamUpdate(id, body, options) {
        return (0, exports.TeamsApiFp)(this.configuration).teamUpdate(id, body, options)(this.fetch, this.basePath);
    }
}
exports.TeamsApi = TeamsApi;
/**
 * TemplatesApi - fetch parameter creator
 * @export
 */
const TemplatesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Get a template's file **Access policy**: authenticated
         * @summary Get a template's file
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateFile(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling templateFile.');
            }
            const localVarPath = `/templates/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a template's file **Access policy**: authenticated
         * @summary Get a template's file
         * @param {TemplatesFilePayload} body File details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateFileOld(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling templateFileOld.');
            }
            const localVarPath = `/templates/file`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("TemplatesFilePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available templates. **Access policy**: authenticated
         * @summary List available templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateList(options = {}) {
            const localVarPath = `/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TemplatesApiFetchParamCreator = TemplatesApiFetchParamCreator;
/**
 * TemplatesApi - functional programming interface
 * @export
 */
const TemplatesApiFp = function (configuration) {
    return {
        /**
         * Get a template's file **Access policy**: authenticated
         * @summary Get a template's file
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateFile(id, options) {
            const localVarFetchArgs = (0, exports.TemplatesApiFetchParamCreator)(configuration).templateFile(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a template's file **Access policy**: authenticated
         * @summary Get a template's file
         * @param {TemplatesFilePayload} body File details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateFileOld(body, options) {
            const localVarFetchArgs = (0, exports.TemplatesApiFetchParamCreator)(configuration).templateFileOld(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List available templates. **Access policy**: authenticated
         * @summary List available templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateList(options) {
            const localVarFetchArgs = (0, exports.TemplatesApiFetchParamCreator)(configuration).templateList(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.TemplatesApiFp = TemplatesApiFp;
/**
 * TemplatesApi - factory interface
 * @export
 */
const TemplatesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Get a template's file **Access policy**: authenticated
         * @summary Get a template's file
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateFile(id, options) {
            return (0, exports.TemplatesApiFp)(configuration).templateFile(id, options)(fetch, basePath);
        },
        /**
         * Get a template's file **Access policy**: authenticated
         * @summary Get a template's file
         * @param {TemplatesFilePayload} body File details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateFileOld(body, options) {
            return (0, exports.TemplatesApiFp)(configuration).templateFileOld(body, options)(fetch, basePath);
        },
        /**
         * List available templates. **Access policy**: authenticated
         * @summary List available templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateList(options) {
            return (0, exports.TemplatesApiFp)(configuration).templateList(options)(fetch, basePath);
        },
    };
};
exports.TemplatesApiFactory = TemplatesApiFactory;
/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
class TemplatesApi extends BaseAPI {
    /**
     * Get a template's file **Access policy**: authenticated
     * @summary Get a template's file
     * @param {number} id Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    templateFile(id, options) {
        return (0, exports.TemplatesApiFp)(this.configuration).templateFile(id, options)(this.fetch, this.basePath);
    }
    /**
     * Get a template's file **Access policy**: authenticated
     * @summary Get a template's file
     * @param {TemplatesFilePayload} body File details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    templateFileOld(body, options) {
        return (0, exports.TemplatesApiFp)(this.configuration).templateFileOld(body, options)(this.fetch, this.basePath);
    }
    /**
     * List available templates. **Access policy**: authenticated
     * @summary List available templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    templateList(options) {
        return (0, exports.TemplatesApiFp)(this.configuration).templateList(options)(this.fetch, this.basePath);
    }
}
exports.TemplatesApi = TemplatesApi;
/**
 * UploadApi - fetch parameter creator
 * @export
 */
const UploadApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload TLS files
         * @param {'ca' | 'cert' | 'key'} certificate TLS file type. Valid values are &#39;ca&#39;, &#39;cert&#39; or &#39;key&#39;.
         * @param {string} folder Folder where the TLS file will be stored. Will be created if not existing
         * @param {any} file The file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTLS(certificate, folder, file, options = {}) {
            // verify required parameter 'certificate' is not null or undefined
            if (certificate === null || certificate === undefined) {
                throw new RequiredError('certificate', 'Required parameter certificate was null or undefined when calling uploadTLS.');
            }
            // verify required parameter 'folder' is not null or undefined
            if (folder === null || folder === undefined) {
                throw new RequiredError('folder', 'Required parameter folder was null or undefined when calling uploadTLS.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling uploadTLS.');
            }
            const localVarPath = `/upload/tls/{certificate}`
                .replace(`{${"certificate"}}`, encodeURIComponent(String(certificate)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (folder !== undefined) {
                localVarFormParams.set('folder', folder);
            }
            if (file !== undefined) {
                localVarFormParams.set('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.UploadApiFetchParamCreator = UploadApiFetchParamCreator;
/**
 * UploadApi - functional programming interface
 * @export
 */
const UploadApiFp = function (configuration) {
    return {
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload TLS files
         * @param {'ca' | 'cert' | 'key'} certificate TLS file type. Valid values are &#39;ca&#39;, &#39;cert&#39; or &#39;key&#39;.
         * @param {string} folder Folder where the TLS file will be stored. Will be created if not existing
         * @param {any} file The file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTLS(certificate, folder, file, options) {
            const localVarFetchArgs = (0, exports.UploadApiFetchParamCreator)(configuration).uploadTLS(certificate, folder, file, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.UploadApiFp = UploadApiFp;
/**
 * UploadApi - factory interface
 * @export
 */
const UploadApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload TLS files
         * @param {'ca' | 'cert' | 'key'} certificate TLS file type. Valid values are &#39;ca&#39;, &#39;cert&#39; or &#39;key&#39;.
         * @param {string} folder Folder where the TLS file will be stored. Will be created if not existing
         * @param {any} file The file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTLS(certificate, folder, file, options) {
            return (0, exports.UploadApiFp)(configuration).uploadTLS(certificate, folder, file, options)(fetch, basePath);
        },
    };
};
exports.UploadApiFactory = UploadApiFactory;
/**
 * UploadApi - object-oriented interface
 * @export
 * @class UploadApi
 * @extends {BaseAPI}
 */
class UploadApi extends BaseAPI {
    /**
     * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
     * @summary Upload TLS files
     * @param {'ca' | 'cert' | 'key'} certificate TLS file type. Valid values are &#39;ca&#39;, &#39;cert&#39; or &#39;key&#39;.
     * @param {string} folder Folder where the TLS file will be stored. Will be created if not existing
     * @param {any} file The file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    uploadTLS(certificate, folder, file, options) {
        return (0, exports.UploadApiFp)(this.configuration).uploadTLS(certificate, folder, file, options)(this.fetch, this.basePath);
    }
}
exports.UploadApi = UploadApi;
/**
 * UsersApi - fetch parameter creator
 * @export
 */
const UsersApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Retrieve details about the current  user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect the current user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserInspect(options = {}) {
            const localVarPath = `/users/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if an administrator account exists in the database. **Access policy**: public
         * @summary Check administrator account existence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminCheck(options = {}) {
            const localVarPath = `/users/admin/check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initialize the 'admin' user account. **Access policy**: public
         * @summary Initialize administrator account
         * @param {UsersAdminInitPayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminInit(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userAdminInit.');
            }
            const localVarPath = `/users/admin/init`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("UsersAdminInitPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Portainer user. Only administrators can create users. **Access policy**: restricted
         * @summary Create a new user
         * @param {UsersUserCreatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userCreate.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("UsersUserCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a user. **Access policy**: administrator
         * @summary Remove a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userDelete.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an API key for a user. Only the calling user can generate a token for themselves. Password is required only for internal authentication. **Access policy**: restricted
         * @summary Generate an API key for a user
         * @param {number} id User identifier
         * @param {UsersUserAccessTokenCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGenerateAPIKey(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userGenerateAPIKey.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userGenerateAPIKey.');
            }
            const localVarPath = `/users/{id}/tokens`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("UsersUserAccessTokenCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all API keys for a user. Only the calling user or admin can retrieve api-keys. **Access policy**: authenticated
         * @summary Get all API keys for a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetAPIKeys(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userGetAPIKeys.');
            }
            const localVarPath = `/users/{id}/tokens`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInspect(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userInspect.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Portainer users. Non-administrator users will only be able to list other non-administrator user accounts. User passwords are filtered out, and should never be accessible. **Access policy**: restricted
         * @summary List users
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userList(environmentId, options = {}) {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (environmentId !== undefined) {
                localVarQueryParameter['environmentId'] = environmentId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inspect a user memberships. **Access policy**: restricted
         * @summary Inspect a user memberships
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMembershipsInspect(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userMembershipsInspect.');
            }
            const localVarPath = `/users/{id}/memberships`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an api-key associated to a user.. Only the calling user or admin can remove api-key. **Access policy**: authenticated
         * @summary Remove an api-key associated to a user
         * @param {number} id User identifier
         * @param {number} keyID Api Key identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRemoveAPIKey(id, keyID, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userRemoveAPIKey.');
            }
            // verify required parameter 'keyID' is not null or undefined
            if (keyID === null || keyID === undefined) {
                throw new RequiredError('keyID', 'Required parameter keyID was null or undefined when calling userRemoveAPIKey.');
            }
            const localVarPath = `/users/{id}/tokens/{keyID}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"keyID"}}`, encodeURIComponent(String(keyID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user details. A regular user account can only update his details. A regular user account cannot change their username or role. **Access policy**: authenticated
         * @summary Update a user
         * @param {number} id User identifier
         * @param {UsersUserUpdatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdate(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userUpdate.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userUpdate.');
            }
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("UsersUserUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update password for the specified user. **Access policy**: authenticated
         * @summary Update password for a user
         * @param {number} id identifier
         * @param {UsersUserUpdatePasswordPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdatePassword(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling userUpdatePassword.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling userUpdatePassword.');
            }
            const localVarPath = `/users/{id}/passwd`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("UsersUserUpdatePasswordPayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.UsersApiFetchParamCreator = UsersApiFetchParamCreator;
/**
 * UsersApi - functional programming interface
 * @export
 */
const UsersApiFp = function (configuration) {
    return {
        /**
         * Retrieve details about the current  user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect the current user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserInspect(options) {
            const localVarFetchArgs = (0, exports.UsersApiFetchParamCreator)(configuration).currentUserInspect(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Check if an administrator account exists in the database. **Access policy**: public
         * @summary Check administrator account existence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminCheck(options) {
            const localVarFetchArgs = (0, exports.UsersApiFetchParamCreator)(configuration).userAdminCheck(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Initialize the 'admin' user account. **Access policy**: public
         * @summary Initialize administrator account
         * @param {UsersAdminInitPayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminInit(body, options) {
            const localVarFetchArgs = (0, exports.UsersApiFetchParamCreator)(configuration).userAdminInit(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Portainer user. Only administrators can create users. **Access policy**: restricted
         * @summary Create a new user
         * @param {UsersUserCreatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate(body, options) {
            const localVarFetchArgs = (0, exports.UsersApiFetchParamCreator)(configuration).userCreate(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a user. **Access policy**: administrator
         * @summary Remove a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDelete(id, options) {
            const localVarFetchArgs = (0, exports.UsersApiFetchParamCreator)(configuration).userDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Generates an API key for a user. Only the calling user can generate a token for themselves. Password is required only for internal authentication. **Access policy**: restricted
         * @summary Generate an API key for a user
         * @param {number} id User identifier
         * @param {UsersUserAccessTokenCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGenerateAPIKey(id, body, options) {
            const localVarFetchArgs = (0, exports.UsersApiFetchParamCreator)(configuration).userGenerateAPIKey(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets all API keys for a user. Only the calling user or admin can retrieve api-keys. **Access policy**: authenticated
         * @summary Get all API keys for a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetAPIKeys(id, options) {
            const localVarFetchArgs = (0, exports.UsersApiFetchParamCreator)(configuration).userGetAPIKeys(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve details about a user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInspect(id, options) {
            const localVarFetchArgs = (0, exports.UsersApiFetchParamCreator)(configuration).userInspect(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List Portainer users. Non-administrator users will only be able to list other non-administrator user accounts. User passwords are filtered out, and should never be accessible. **Access policy**: restricted
         * @summary List users
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userList(environmentId, options) {
            const localVarFetchArgs = (0, exports.UsersApiFetchParamCreator)(configuration).userList(environmentId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Inspect a user memberships. **Access policy**: restricted
         * @summary Inspect a user memberships
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMembershipsInspect(id, options) {
            const localVarFetchArgs = (0, exports.UsersApiFetchParamCreator)(configuration).userMembershipsInspect(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove an api-key associated to a user.. Only the calling user or admin can remove api-key. **Access policy**: authenticated
         * @summary Remove an api-key associated to a user
         * @param {number} id User identifier
         * @param {number} keyID Api Key identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRemoveAPIKey(id, keyID, options) {
            const localVarFetchArgs = (0, exports.UsersApiFetchParamCreator)(configuration).userRemoveAPIKey(id, keyID, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update user details. A regular user account can only update his details. A regular user account cannot change their username or role. **Access policy**: authenticated
         * @summary Update a user
         * @param {number} id User identifier
         * @param {UsersUserUpdatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdate(id, body, options) {
            const localVarFetchArgs = (0, exports.UsersApiFetchParamCreator)(configuration).userUpdate(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update password for the specified user. **Access policy**: authenticated
         * @summary Update password for a user
         * @param {number} id identifier
         * @param {UsersUserUpdatePasswordPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdatePassword(id, body, options) {
            const localVarFetchArgs = (0, exports.UsersApiFetchParamCreator)(configuration).userUpdatePassword(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.UsersApiFp = UsersApiFp;
/**
 * UsersApi - factory interface
 * @export
 */
const UsersApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Retrieve details about the current  user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect the current user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserInspect(options) {
            return (0, exports.UsersApiFp)(configuration).currentUserInspect(options)(fetch, basePath);
        },
        /**
         * Check if an administrator account exists in the database. **Access policy**: public
         * @summary Check administrator account existence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminCheck(options) {
            return (0, exports.UsersApiFp)(configuration).userAdminCheck(options)(fetch, basePath);
        },
        /**
         * Initialize the 'admin' user account. **Access policy**: public
         * @summary Initialize administrator account
         * @param {UsersAdminInitPayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminInit(body, options) {
            return (0, exports.UsersApiFp)(configuration).userAdminInit(body, options)(fetch, basePath);
        },
        /**
         * Create a new Portainer user. Only administrators can create users. **Access policy**: restricted
         * @summary Create a new user
         * @param {UsersUserCreatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate(body, options) {
            return (0, exports.UsersApiFp)(configuration).userCreate(body, options)(fetch, basePath);
        },
        /**
         * Remove a user. **Access policy**: administrator
         * @summary Remove a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDelete(id, options) {
            return (0, exports.UsersApiFp)(configuration).userDelete(id, options)(fetch, basePath);
        },
        /**
         * Generates an API key for a user. Only the calling user can generate a token for themselves. Password is required only for internal authentication. **Access policy**: restricted
         * @summary Generate an API key for a user
         * @param {number} id User identifier
         * @param {UsersUserAccessTokenCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGenerateAPIKey(id, body, options) {
            return (0, exports.UsersApiFp)(configuration).userGenerateAPIKey(id, body, options)(fetch, basePath);
        },
        /**
         * Gets all API keys for a user. Only the calling user or admin can retrieve api-keys. **Access policy**: authenticated
         * @summary Get all API keys for a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetAPIKeys(id, options) {
            return (0, exports.UsersApiFp)(configuration).userGetAPIKeys(id, options)(fetch, basePath);
        },
        /**
         * Retrieve details about a user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInspect(id, options) {
            return (0, exports.UsersApiFp)(configuration).userInspect(id, options)(fetch, basePath);
        },
        /**
         * List Portainer users. Non-administrator users will only be able to list other non-administrator user accounts. User passwords are filtered out, and should never be accessible. **Access policy**: restricted
         * @summary List users
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userList(environmentId, options) {
            return (0, exports.UsersApiFp)(configuration).userList(environmentId, options)(fetch, basePath);
        },
        /**
         * Inspect a user memberships. **Access policy**: restricted
         * @summary Inspect a user memberships
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMembershipsInspect(id, options) {
            return (0, exports.UsersApiFp)(configuration).userMembershipsInspect(id, options)(fetch, basePath);
        },
        /**
         * Remove an api-key associated to a user.. Only the calling user or admin can remove api-key. **Access policy**: authenticated
         * @summary Remove an api-key associated to a user
         * @param {number} id User identifier
         * @param {number} keyID Api Key identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRemoveAPIKey(id, keyID, options) {
            return (0, exports.UsersApiFp)(configuration).userRemoveAPIKey(id, keyID, options)(fetch, basePath);
        },
        /**
         * Update user details. A regular user account can only update his details. A regular user account cannot change their username or role. **Access policy**: authenticated
         * @summary Update a user
         * @param {number} id User identifier
         * @param {UsersUserUpdatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdate(id, body, options) {
            return (0, exports.UsersApiFp)(configuration).userUpdate(id, body, options)(fetch, basePath);
        },
        /**
         * Update password for the specified user. **Access policy**: authenticated
         * @summary Update password for a user
         * @param {number} id identifier
         * @param {UsersUserUpdatePasswordPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdatePassword(id, body, options) {
            return (0, exports.UsersApiFp)(configuration).userUpdatePassword(id, body, options)(fetch, basePath);
        },
    };
};
exports.UsersApiFactory = UsersApiFactory;
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
class UsersApi extends BaseAPI {
    /**
     * Retrieve details about the current  user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
     * @summary Inspect the current user user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    currentUserInspect(options) {
        return (0, exports.UsersApiFp)(this.configuration).currentUserInspect(options)(this.fetch, this.basePath);
    }
    /**
     * Check if an administrator account exists in the database. **Access policy**: public
     * @summary Check administrator account existence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    userAdminCheck(options) {
        return (0, exports.UsersApiFp)(this.configuration).userAdminCheck(options)(this.fetch, this.basePath);
    }
    /**
     * Initialize the 'admin' user account. **Access policy**: public
     * @summary Initialize administrator account
     * @param {UsersAdminInitPayload} body User details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    userAdminInit(body, options) {
        return (0, exports.UsersApiFp)(this.configuration).userAdminInit(body, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new Portainer user. Only administrators can create users. **Access policy**: restricted
     * @summary Create a new user
     * @param {UsersUserCreatePayload} body User details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    userCreate(body, options) {
        return (0, exports.UsersApiFp)(this.configuration).userCreate(body, options)(this.fetch, this.basePath);
    }
    /**
     * Remove a user. **Access policy**: administrator
     * @summary Remove a user
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    userDelete(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).userDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     * Generates an API key for a user. Only the calling user can generate a token for themselves. Password is required only for internal authentication. **Access policy**: restricted
     * @summary Generate an API key for a user
     * @param {number} id User identifier
     * @param {UsersUserAccessTokenCreatePayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    userGenerateAPIKey(id, body, options) {
        return (0, exports.UsersApiFp)(this.configuration).userGenerateAPIKey(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * Gets all API keys for a user. Only the calling user or admin can retrieve api-keys. **Access policy**: authenticated
     * @summary Get all API keys for a user
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    userGetAPIKeys(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).userGetAPIKeys(id, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve details about a user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
     * @summary Inspect a user
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    userInspect(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).userInspect(id, options)(this.fetch, this.basePath);
    }
    /**
     * List Portainer users. Non-administrator users will only be able to list other non-administrator user accounts. User passwords are filtered out, and should never be accessible. **Access policy**: restricted
     * @summary List users
     * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    userList(environmentId, options) {
        return (0, exports.UsersApiFp)(this.configuration).userList(environmentId, options)(this.fetch, this.basePath);
    }
    /**
     * Inspect a user memberships. **Access policy**: restricted
     * @summary Inspect a user memberships
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    userMembershipsInspect(id, options) {
        return (0, exports.UsersApiFp)(this.configuration).userMembershipsInspect(id, options)(this.fetch, this.basePath);
    }
    /**
     * Remove an api-key associated to a user.. Only the calling user or admin can remove api-key. **Access policy**: authenticated
     * @summary Remove an api-key associated to a user
     * @param {number} id User identifier
     * @param {number} keyID Api Key identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    userRemoveAPIKey(id, keyID, options) {
        return (0, exports.UsersApiFp)(this.configuration).userRemoveAPIKey(id, keyID, options)(this.fetch, this.basePath);
    }
    /**
     * Update user details. A regular user account can only update his details. A regular user account cannot change their username or role. **Access policy**: authenticated
     * @summary Update a user
     * @param {number} id User identifier
     * @param {UsersUserUpdatePayload} body User details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    userUpdate(id, body, options) {
        return (0, exports.UsersApiFp)(this.configuration).userUpdate(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * Update password for the specified user. **Access policy**: authenticated
     * @summary Update password for a user
     * @param {number} id identifier
     * @param {UsersUserUpdatePasswordPayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    userUpdatePassword(id, body, options) {
        return (0, exports.UsersApiFp)(this.configuration).userUpdatePassword(id, body, options)(this.fetch, this.basePath);
    }
}
exports.UsersApi = UsersApi;
/**
 * WebhooksApi - fetch parameter creator
 * @export
 */
const WebhooksApiFetchParamCreator = function (configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary List webhooks
         * @param {string} [filters] Filters (json-string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet(filters, options = {}) {
            const localVarPath = `/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a webhook
         * @param {number} id Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdDelete(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling webhooksIdDelete.');
            }
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Acts on a passed in token UUID to restart the docker service **Access policy**: public
         * @summary Execute a webhook
         * @param {string} id Webhook token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPost(id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling webhooksIdPost.');
            }
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Update a webhook
         * @param {number} id Webhook id
         * @param {WebhooksWebhookUpdatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPut(id, body, options = {}) {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling webhooksIdPut.');
            }
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling webhooksIdPut.');
            }
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("WebhooksWebhookUpdatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Create a webhook
         * @param {WebhooksWebhookCreatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling webhooksPost.');
            }
            const localVarPath = `/webhooks`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("WebhooksWebhookCreatePayload" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.WebhooksApiFetchParamCreator = WebhooksApiFetchParamCreator;
/**
 * WebhooksApi - functional programming interface
 * @export
 */
const WebhooksApiFp = function (configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary List webhooks
         * @param {string} [filters] Filters (json-string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet(filters, options) {
            const localVarFetchArgs = (0, exports.WebhooksApiFetchParamCreator)(configuration).webhooksGet(filters, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a webhook
         * @param {number} id Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdDelete(id, options) {
            const localVarFetchArgs = (0, exports.WebhooksApiFetchParamCreator)(configuration).webhooksIdDelete(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Acts on a passed in token UUID to restart the docker service **Access policy**: public
         * @summary Execute a webhook
         * @param {string} id Webhook token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPost(id, options) {
            const localVarFetchArgs = (0, exports.WebhooksApiFetchParamCreator)(configuration).webhooksIdPost(id, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Update a webhook
         * @param {number} id Webhook id
         * @param {WebhooksWebhookUpdatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPut(id, body, options) {
            const localVarFetchArgs = (0, exports.WebhooksApiFetchParamCreator)(configuration).webhooksIdPut(id, body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Create a webhook
         * @param {WebhooksWebhookCreatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost(body, options) {
            const localVarFetchArgs = (0, exports.WebhooksApiFetchParamCreator)(configuration).webhooksPost(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.WebhooksApiFp = WebhooksApiFp;
/**
 * WebhooksApi - factory interface
 * @export
 */
const WebhooksApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary List webhooks
         * @param {string} [filters] Filters (json-string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet(filters, options) {
            return (0, exports.WebhooksApiFp)(configuration).webhooksGet(filters, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a webhook
         * @param {number} id Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdDelete(id, options) {
            return (0, exports.WebhooksApiFp)(configuration).webhooksIdDelete(id, options)(fetch, basePath);
        },
        /**
         * Acts on a passed in token UUID to restart the docker service **Access policy**: public
         * @summary Execute a webhook
         * @param {string} id Webhook token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPost(id, options) {
            return (0, exports.WebhooksApiFp)(configuration).webhooksIdPost(id, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Update a webhook
         * @param {number} id Webhook id
         * @param {WebhooksWebhookUpdatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPut(id, body, options) {
            return (0, exports.WebhooksApiFp)(configuration).webhooksIdPut(id, body, options)(fetch, basePath);
        },
        /**
         * **Access policy**: authenticated
         * @summary Create a webhook
         * @param {WebhooksWebhookCreatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost(body, options) {
            return (0, exports.WebhooksApiFp)(configuration).webhooksPost(body, options)(fetch, basePath);
        },
    };
};
exports.WebhooksApiFactory = WebhooksApiFactory;
/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
class WebhooksApi extends BaseAPI {
    /**
     * **Access policy**: authenticated
     * @summary List webhooks
     * @param {string} [filters] Filters (json-string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    webhooksGet(filters, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).webhooksGet(filters, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: authenticated
     * @summary Delete a webhook
     * @param {number} id Webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    webhooksIdDelete(id, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).webhooksIdDelete(id, options)(this.fetch, this.basePath);
    }
    /**
     * Acts on a passed in token UUID to restart the docker service **Access policy**: public
     * @summary Execute a webhook
     * @param {string} id Webhook token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    webhooksIdPost(id, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).webhooksIdPost(id, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: authenticated
     * @summary Update a webhook
     * @param {number} id Webhook id
     * @param {WebhooksWebhookUpdatePayload} body Webhook data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    webhooksIdPut(id, body, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).webhooksIdPut(id, body, options)(this.fetch, this.basePath);
    }
    /**
     * **Access policy**: authenticated
     * @summary Create a webhook
     * @param {WebhooksWebhookCreatePayload} body Webhook data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    webhooksPost(body, options) {
        return (0, exports.WebhooksApiFp)(this.configuration).webhooksPost(body, options)(this.fetch, this.basePath);
    }
}
exports.WebhooksApi = WebhooksApi;
/**
 * WebsocketApi - fetch parameter creator
 * @export
 */
const WebsocketApiFetchParamCreator = function (configuration) {
    return {
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an AttachStart operation HTTP request will be created and hijacked. **Access policy**: authenticated
         * @summary Attach a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketAttachGet(endpointId, token, nodeName, options = {}) {
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling websocketAttachGet.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token', 'Required parameter token was null or undefined when calling websocketAttachGet.');
            }
            const localVarPath = `/websocket/attach`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            if (nodeName !== undefined) {
                localVarQueryParameter['nodeName'] = nodeName;
            }
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an ExecStart operation HTTP request will be created and hijacked.
         * @summary Execute a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketExecGet(endpointId, token, nodeName, options = {}) {
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling websocketExecGet.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token', 'Required parameter token was null or undefined when calling websocketExecGet.');
            }
            const localVarPath = `/websocket/exec`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            if (nodeName !== undefined) {
                localVarQueryParameter['nodeName'] = nodeName;
            }
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection. **Access policy**: authenticated
         * @summary Execute a websocket on kubectl shell pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketKubernetesShellGet(endpointId, token, options = {}) {
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling websocketKubernetesShellGet.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token', 'Required parameter token was null or undefined when calling websocketKubernetesShellGet.');
            }
            const localVarPath = `/websocket/kubernetes-shell`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The request will be upgraded to the websocket protocol. **Access policy**: authenticated
         * @summary Execute a websocket on pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} namespace namespace where the container is located
         * @param {string} podName name of the pod containing the container
         * @param {string} containerName name of the container
         * @param {string} command command to execute in the container
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketPodGet(endpointId, namespace, podName, containerName, command, token, options = {}) {
            // verify required parameter 'endpointId' is not null or undefined
            if (endpointId === null || endpointId === undefined) {
                throw new RequiredError('endpointId', 'Required parameter endpointId was null or undefined when calling websocketPodGet.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace', 'Required parameter namespace was null or undefined when calling websocketPodGet.');
            }
            // verify required parameter 'podName' is not null or undefined
            if (podName === null || podName === undefined) {
                throw new RequiredError('podName', 'Required parameter podName was null or undefined when calling websocketPodGet.');
            }
            // verify required parameter 'containerName' is not null or undefined
            if (containerName === null || containerName === undefined) {
                throw new RequiredError('containerName', 'Required parameter containerName was null or undefined when calling websocketPodGet.');
            }
            // verify required parameter 'command' is not null or undefined
            if (command === null || command === undefined) {
                throw new RequiredError('command', 'Required parameter command was null or undefined when calling websocketPodGet.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token', 'Required parameter token was null or undefined when calling websocketPodGet.');
            }
            const localVarPath = `/websocket/pod`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("X-API-KEY")
                    : configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }
            // authentication jwt required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("Authorization")
                    : configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (podName !== undefined) {
                localVarQueryParameter['podName'] = podName;
            }
            if (containerName !== undefined) {
                localVarQueryParameter['containerName'] = containerName;
            }
            if (command !== undefined) {
                localVarQueryParameter['command'] = command;
            }
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.WebsocketApiFetchParamCreator = WebsocketApiFetchParamCreator;
/**
 * WebsocketApi - functional programming interface
 * @export
 */
const WebsocketApiFp = function (configuration) {
    return {
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an AttachStart operation HTTP request will be created and hijacked. **Access policy**: authenticated
         * @summary Attach a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketAttachGet(endpointId, token, nodeName, options) {
            const localVarFetchArgs = (0, exports.WebsocketApiFetchParamCreator)(configuration).websocketAttachGet(endpointId, token, nodeName, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an ExecStart operation HTTP request will be created and hijacked.
         * @summary Execute a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketExecGet(endpointId, token, nodeName, options) {
            const localVarFetchArgs = (0, exports.WebsocketApiFetchParamCreator)(configuration).websocketExecGet(endpointId, token, nodeName, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection. **Access policy**: authenticated
         * @summary Execute a websocket on kubectl shell pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketKubernetesShellGet(endpointId, token, options) {
            const localVarFetchArgs = (0, exports.WebsocketApiFetchParamCreator)(configuration).websocketKubernetesShellGet(endpointId, token, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The request will be upgraded to the websocket protocol. **Access policy**: authenticated
         * @summary Execute a websocket on pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} namespace namespace where the container is located
         * @param {string} podName name of the pod containing the container
         * @param {string} containerName name of the container
         * @param {string} command command to execute in the container
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketPodGet(endpointId, namespace, podName, containerName, command, token, options) {
            const localVarFetchArgs = (0, exports.WebsocketApiFetchParamCreator)(configuration).websocketPodGet(endpointId, namespace, podName, containerName, command, token, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.WebsocketApiFp = WebsocketApiFp;
/**
 * WebsocketApi - factory interface
 * @export
 */
const WebsocketApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an AttachStart operation HTTP request will be created and hijacked. **Access policy**: authenticated
         * @summary Attach a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketAttachGet(endpointId, token, nodeName, options) {
            return (0, exports.WebsocketApiFp)(configuration).websocketAttachGet(endpointId, token, nodeName, options)(fetch, basePath);
        },
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an ExecStart operation HTTP request will be created and hijacked.
         * @summary Execute a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketExecGet(endpointId, token, nodeName, options) {
            return (0, exports.WebsocketApiFp)(configuration).websocketExecGet(endpointId, token, nodeName, options)(fetch, basePath);
        },
        /**
         * The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection. **Access policy**: authenticated
         * @summary Execute a websocket on kubectl shell pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketKubernetesShellGet(endpointId, token, options) {
            return (0, exports.WebsocketApiFp)(configuration).websocketKubernetesShellGet(endpointId, token, options)(fetch, basePath);
        },
        /**
         * The request will be upgraded to the websocket protocol. **Access policy**: authenticated
         * @summary Execute a websocket on pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} namespace namespace where the container is located
         * @param {string} podName name of the pod containing the container
         * @param {string} containerName name of the container
         * @param {string} command command to execute in the container
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketPodGet(endpointId, namespace, podName, containerName, command, token, options) {
            return (0, exports.WebsocketApiFp)(configuration).websocketPodGet(endpointId, namespace, podName, containerName, command, token, options)(fetch, basePath);
        },
    };
};
exports.WebsocketApiFactory = WebsocketApiFactory;
/**
 * WebsocketApi - object-oriented interface
 * @export
 * @class WebsocketApi
 * @extends {BaseAPI}
 */
class WebsocketApi extends BaseAPI {
    /**
     * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an AttachStart operation HTTP request will be created and hijacked. **Access policy**: authenticated
     * @summary Attach a websocket
     * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
     * @param {string} token JWT token used for authentication against this environment(endpoint)
     * @param {string} [nodeName] node name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    websocketAttachGet(endpointId, token, nodeName, options) {
        return (0, exports.WebsocketApiFp)(this.configuration).websocketAttachGet(endpointId, token, nodeName, options)(this.fetch, this.basePath);
    }
    /**
     * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an ExecStart operation HTTP request will be created and hijacked.
     * @summary Execute a websocket
     * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
     * @param {string} token JWT token used for authentication against this environment(endpoint)
     * @param {string} [nodeName] node name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    websocketExecGet(endpointId, token, nodeName, options) {
        return (0, exports.WebsocketApiFp)(this.configuration).websocketExecGet(endpointId, token, nodeName, options)(this.fetch, this.basePath);
    }
    /**
     * The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection. **Access policy**: authenticated
     * @summary Execute a websocket on kubectl shell pod
     * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
     * @param {string} token JWT token used for authentication against this environment(endpoint)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    websocketKubernetesShellGet(endpointId, token, options) {
        return (0, exports.WebsocketApiFp)(this.configuration).websocketKubernetesShellGet(endpointId, token, options)(this.fetch, this.basePath);
    }
    /**
     * The request will be upgraded to the websocket protocol. **Access policy**: authenticated
     * @summary Execute a websocket on pod
     * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
     * @param {string} namespace namespace where the container is located
     * @param {string} podName name of the pod containing the container
     * @param {string} containerName name of the container
     * @param {string} command command to execute in the container
     * @param {string} token JWT token used for authentication against this environment(endpoint)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    websocketPodGet(endpointId, namespace, podName, containerName, command, token, options) {
        return (0, exports.WebsocketApiFp)(this.configuration).websocketPodGet(endpointId, namespace, podName, containerName, command, token, options)(this.fetch, this.basePath);
    }
}
exports.WebsocketApi = WebsocketApi;
