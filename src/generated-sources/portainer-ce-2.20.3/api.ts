/* tslint:disable */
/* eslint-disable */
/**
 * PortainerCE API
 * Portainer API is an HTTP API served by Portainer. It is used by the Portainer UI and everything you can do with the UI can be done using the HTTP API. Examples are available at https://documentation.portainer.io/api/api-examples/ You can find out more about Portainer at [http://portainer.io](http://portainer.io) and get some support on [Slack](http://portainer.io/slack/).  # Authentication  Most of the API environments(endpoints) require to be authenticated as well as some level of authorization to be used. Portainer API uses JSON Web Token to manage authentication and thus requires you to provide a token in the **Authorization** header of each request with the **Bearer** authentication mechanism.  Example:  ``` Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiIsInJvbGUiOjEsImV4cCI6MTQ5OTM3NjE1NH0.NJ6vE8FY1WG6jsRQzfMqeatJ4vh2TWAeeYfDhP71YEE ```  # Security  Each API environment(endpoint) has an associated access policy, it is documented in the description of each environment(endpoint).  Different access policies are available:  - Public access - Authenticated access - Restricted access - Administrator access  ### Public access  No authentication is required to access the environments(endpoints) with this access policy.  ### Authenticated access  Authentication is required to access the environments(endpoints) with this access policy.  ### Restricted access  Authentication is required to access the environments(endpoints) with this access policy. Extra-checks might be added to ensure access to the resource is granted. Returned data might also be filtered.  ### Administrator access  Authentication as well as an administrator role are required to access the environments(endpoints) with this access policy.  # Execute Docker requests  Portainer **DO NOT** expose specific environments(endpoints) to manage your Docker resources (create a container, remove a volume, etc...).  Instead, it acts as a reverse-proxy to the Docker HTTP API. This means that you can execute Docker requests **via** the Portainer HTTP API.  To do so, you can use the `/endpoints/{id}/docker` Portainer API environment(endpoint) (which is not documented below due to Swagger limitations). This environment(endpoint) has a restricted access policy so you still need to be authenticated to be able to query this environment(endpoint). Any query on this environment(endpoint) will be proxied to the Docker API of the associated environment(endpoint) (requests and responses objects are the same as documented in the Docker API).  # Private Registry  Using private registry, you will need to pass a based64 encoded JSON string ‘{\"registryId\":\\<registryID value\\>}’ inside the Request Header. The parameter name is \"X-Registry-Auth\". \\<registryID value\\> - The registry ID where the repository was created.  Example:  ``` eyJyZWdpc3RyeUlkIjoxfQ== ```  **NOTE**: You can find more information on how to query the Docker API in the [Docker official documentation](https://docs.docker.com/engine/api/v1.30/) as well as in [this Portainer example](https://documentation.portainer.io/api/api-examples/). 
 *
 * The version of the OpenAPI document: 2.20.3
 * Contact: info@portainer.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthAuthenticatePayload
 */
export interface AuthAuthenticatePayload {
    /**
     * Password
     * @type {string}
     * @memberof AuthAuthenticatePayload
     */
    'password': string;
    /**
     * Username
     * @type {string}
     * @memberof AuthAuthenticatePayload
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface AuthAuthenticateResponse
 */
export interface AuthAuthenticateResponse {
    /**
     * JWT token used to authenticate against the API
     * @type {string}
     * @memberof AuthAuthenticateResponse
     */
    'jwt'?: string;
}
/**
 * 
 * @export
 * @interface AuthOauthPayload
 */
export interface AuthOauthPayload {
    /**
     * OAuth code returned from OAuth Provided
     * @type {string}
     * @memberof AuthOauthPayload
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface BackupBackupPayload
 */
export interface BackupBackupPayload {
    /**
     * 
     * @type {string}
     * @memberof BackupBackupPayload
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface BackupRestorePayload
 */
export interface BackupRestorePayload {
    /**
     * 
     * @type {Array<number>}
     * @memberof BackupRestorePayload
     */
    'fileContent'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof BackupRestorePayload
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BackupRestorePayload
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface ContainersContainerGpusResponse
 */
export interface ContainersContainerGpusResponse {
    /**
     * 
     * @type {string}
     * @memberof ContainersContainerGpusResponse
     */
    'gpus'?: string;
}
/**
 * 
 * @export
 * @interface CustomtemplatesCustomTemplateFromFileContentPayload
 */
export interface CustomtemplatesCustomTemplateFromFileContentPayload {
    /**
     * Description of the template
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    'description': string;
    /**
     * EdgeTemplate indicates if this template purpose for Edge Stack
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    'edgeTemplate'?: boolean;
    /**
     * Content of stack file
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    'fileContent': string;
    /**
     * URL of the template\'s logo
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    'logo'?: string;
    /**
     * A note that will be displayed in the UI. Supports HTML content
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    'note'?: string;
    /**
     * Platform associated to the template. Valid values are: 1 - \'linux\', 2 - \'windows\' Required for Docker stacks
     * @type {number}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    'platform'?: number;
    /**
     * Title of the template
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    'title': string;
    /**
     * Type of created stack: * 1 - swarm * 2 - compose * 3 - kubernetes
     * @type {number}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    'type': number;
    /**
     * Definitions of variables in the stack file
     * @type {Array<PortainerCustomTemplateVariableDefinition>}
     * @memberof CustomtemplatesCustomTemplateFromFileContentPayload
     */
    'variables'?: Array<PortainerCustomTemplateVariableDefinition>;
}
/**
 * 
 * @export
 * @interface CustomtemplatesCustomTemplateFromGitRepositoryPayload
 */
export interface CustomtemplatesCustomTemplateFromGitRepositoryPayload {
    /**
     * Path to the Stack file inside the Git repository
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'composeFilePathInRepository'?: string;
    /**
     * Description of the template
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'description': string;
    /**
     * EdgeTemplate indicates if this template purpose for Edge Stack
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'edgeTemplate'?: boolean;
    /**
     * IsComposeFormat indicates if the Kubernetes template is created from a Docker Compose file
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'isComposeFormat'?: boolean;
    /**
     * URL of the template\'s logo
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'logo'?: string;
    /**
     * A note that will be displayed in the UI. Supports HTML content
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'note'?: string;
    /**
     * Platform associated to the template. Valid values are: 1 - \'linux\', 2 - \'windows\' Required for Docker stacks
     * @type {number}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'platform'?: number;
    /**
     * Use basic authentication to clone the Git repository
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'repositoryAuthentication'?: boolean;
    /**
     * Password used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'repositoryPassword'?: string;
    /**
     * Reference name of a Git repository hosting the Stack file
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'repositoryReferenceName'?: string;
    /**
     * URL of a Git repository hosting the Stack file
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'repositoryURL': string;
    /**
     * Username used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'repositoryUsername'?: string;
    /**
     * Title of the template
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'title': string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'tlsskipVerify'?: boolean;
    /**
     * Type of created stack: * 1 - swarm * 2 - compose * 3 - kubernetes
     * @type {number}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'type': number;
    /**
     * Definitions of variables in the stack file
     * @type {Array<PortainerCustomTemplateVariableDefinition>}
     * @memberof CustomtemplatesCustomTemplateFromGitRepositoryPayload
     */
    'variables'?: Array<PortainerCustomTemplateVariableDefinition>;
}
/**
 * 
 * @export
 * @interface CustomtemplatesCustomTemplateUpdatePayload
 */
export interface CustomtemplatesCustomTemplateUpdatePayload {
    /**
     * Path to the Stack file inside the Git repository
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'composeFilePathInRepository'?: string;
    /**
     * Description of the template
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'description': string;
    /**
     * EdgeTemplate indicates if this template purpose for Edge Stack
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'edgeTemplate'?: boolean;
    /**
     * Content of stack file
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'fileContent': string;
    /**
     * IsComposeFormat indicates if the Kubernetes template is created from a Docker Compose file
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'isComposeFormat'?: boolean;
    /**
     * URL of the template\'s logo
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'logo'?: string;
    /**
     * A note that will be displayed in the UI. Supports HTML content
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'note'?: string;
    /**
     * Platform associated to the template. Valid values are: 1 - \'linux\', 2 - \'windows\' Required for Docker stacks
     * @type {number}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'platform'?: number;
    /**
     * Use basic authentication to clone the Git repository
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'repositoryAuthentication'?: boolean;
    /**
     * GitCredentialID used to identify the bound git credential. Required when RepositoryAuthentication is true and RepositoryUsername/RepositoryPassword are not provided
     * @type {number}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'repositoryGitCredentialID'?: number;
    /**
     * Password used in basic authentication. Required when RepositoryAuthentication is true and RepositoryGitCredentialID is 0
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'repositoryPassword'?: string;
    /**
     * Reference name of a Git repository hosting the Stack file
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'repositoryReferenceName'?: string;
    /**
     * URL of a Git repository hosting the Stack file
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'repositoryURL': string;
    /**
     * Username used in basic authentication. Required when RepositoryAuthentication is true and RepositoryGitCredentialID is 0
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'repositoryUsername'?: string;
    /**
     * Title of the template
     * @type {string}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'title': string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'tlsskipVerify'?: boolean;
    /**
     * Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
     * @type {number}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'type': number;
    /**
     * Definitions of variables in the stack file
     * @type {Array<PortainerCustomTemplateVariableDefinition>}
     * @memberof CustomtemplatesCustomTemplateUpdatePayload
     */
    'variables'?: Array<PortainerCustomTemplateVariableDefinition>;
}
/**
 * 
 * @export
 * @interface CustomtemplatesFileResponse
 */
export interface CustomtemplatesFileResponse {
    /**
     * 
     * @type {string}
     * @memberof CustomtemplatesFileResponse
     */
    'fileContent'?: string;
}
/**
 * 
 * @export
 * @interface DemoEnvironmentDetails
 */
export interface DemoEnvironmentDetails {
    /**
     * 
     * @type {boolean}
     * @memberof DemoEnvironmentDetails
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof DemoEnvironmentDetails
     */
    'environments'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DemoEnvironmentDetails
     */
    'users'?: Array<number>;
}
/**
 * 
 * @export
 * @interface EdgeRegistryCredentials
 */
export interface EdgeRegistryCredentials {
    /**
     * 
     * @type {string}
     * @memberof EdgeRegistryCredentials
     */
    'secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgeRegistryCredentials
     */
    'serverURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgeRegistryCredentials
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface EdgeStackPayload
 */
export interface EdgeStackPayload {
    /**
     * Content of stack folder
     * @type {Array<FilesystemDirEntry>}
     * @memberof EdgeStackPayload
     */
    'dirEntries'?: Array<FilesystemDirEntry>;
    /**
     * EdgeUpdateID is the ID of the edge update related to this stack. Used only for EE
     * @type {number}
     * @memberof EdgeStackPayload
     */
    'edgeUpdateID'?: number;
    /**
     * Name of the stack entry file
     * @type {string}
     * @memberof EdgeStackPayload
     */
    'entryFileName'?: string;
    /**
     * Used only for EE EnvVars is a list of environment variables to inject into the stack
     * @type {Array<PortainerPair>}
     * @memberof EdgeStackPayload
     */
    'envVars'?: Array<PortainerPair>;
    /**
     * Mount point for relative path
     * @type {string}
     * @memberof EdgeStackPayload
     */
    'filesystemPath'?: string;
    /**
     * ID of the stack
     * @type {number}
     * @memberof EdgeStackPayload
     */
    'id'?: number;
    /**
     * Name of the stack
     * @type {string}
     * @memberof EdgeStackPayload
     */
    'name'?: string;
    /**
     * Namespace to use for kubernetes stack. Keep empty to use the manifest namespace.
     * @type {string}
     * @memberof EdgeStackPayload
     */
    'namespace'?: string;
    /**
     * PrePullImage is a flag indicating if the agent should pull the image before deploying the stack. Used only for EE
     * @type {boolean}
     * @memberof EdgeStackPayload
     */
    'prePullImage'?: boolean;
    /**
     * RePullImage is a flag indicating if the agent should pull the image if it is already present on the node. Used only for EE
     * @type {boolean}
     * @memberof EdgeStackPayload
     */
    'rePullImage'?: boolean;
    /**
     * Used only for EE async edge agent ReadyRePullImage is a flag to indicate whether the auto update is trigger to re-pull image
     * @type {boolean}
     * @memberof EdgeStackPayload
     */
    'readyRePullImage'?: boolean;
    /**
     * RegistryCredentials holds the credentials for a Docker registry. Used only for EE
     * @type {Array<EdgeRegistryCredentials>}
     * @memberof EdgeStackPayload
     */
    'registryCredentials'?: Array<EdgeRegistryCredentials>;
    /**
     * RetryDeploy is a flag indicating if the agent should retry to deploy the stack if it fails. Used only for EE
     * @type {boolean}
     * @memberof EdgeStackPayload
     */
    'retryDeploy'?: boolean;
    /**
     * RollbackTo specifies the stack file version to rollback to (only support to rollback to the last version currently)
     * @type {number}
     * @memberof EdgeStackPayload
     */
    'rollbackTo'?: number;
    /**
     * Content of the stack file (for compatibility to agent version less than 2.19.0)
     * @type {string}
     * @memberof EdgeStackPayload
     */
    'stackFileContent'?: string;
    /**
     * Is relative path supported
     * @type {boolean}
     * @memberof EdgeStackPayload
     */
    'supportRelativePath'?: boolean;
    /**
     * Version of the stack file
     * @type {number}
     * @memberof EdgeStackPayload
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface EdgegroupsDecoratedEdgeGroup
 */
export interface EdgegroupsDecoratedEdgeGroup {
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    'Dynamic'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    'Endpoints'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    'HasEdgeJob'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    'HasEdgeStack'?: boolean;
    /**
     * EdgeGroup Identifier
     * @type {number}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    'Name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    'PartialMatch'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    'TagIds'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    'TrustedEndpoints'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsDecoratedEdgeGroup
     */
    'endpointTypes'?: Array<number>;
}
/**
 * 
 * @export
 * @interface EdgegroupsEdgeGroupCreatePayload
 */
export interface EdgegroupsEdgeGroupCreatePayload {
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsEdgeGroupCreatePayload
     */
    'dynamic'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsEdgeGroupCreatePayload
     */
    'endpoints'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof EdgegroupsEdgeGroupCreatePayload
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsEdgeGroupCreatePayload
     */
    'partialMatch'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsEdgeGroupCreatePayload
     */
    'tagIDs'?: Array<number>;
}
/**
 * 
 * @export
 * @interface EdgegroupsEdgeGroupUpdatePayload
 */
export interface EdgegroupsEdgeGroupUpdatePayload {
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsEdgeGroupUpdatePayload
     */
    'dynamic'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsEdgeGroupUpdatePayload
     */
    'endpoints'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof EdgegroupsEdgeGroupUpdatePayload
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EdgegroupsEdgeGroupUpdatePayload
     */
    'partialMatch'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgegroupsEdgeGroupUpdatePayload
     */
    'tagIDs'?: Array<number>;
}
/**
 * 
 * @export
 * @interface EdgejobsEdgeJobCreateFromFileContentPayload
 */
export interface EdgejobsEdgeJobCreateFromFileContentPayload {
    /**
     * 
     * @type {string}
     * @memberof EdgejobsEdgeJobCreateFromFileContentPayload
     */
    'cronExpression'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgejobsEdgeJobCreateFromFileContentPayload
     */
    'edgeGroups'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgejobsEdgeJobCreateFromFileContentPayload
     */
    'endpoints'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof EdgejobsEdgeJobCreateFromFileContentPayload
     */
    'fileContent'?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgejobsEdgeJobCreateFromFileContentPayload
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EdgejobsEdgeJobCreateFromFileContentPayload
     */
    'recurring'?: boolean;
}
/**
 * 
 * @export
 * @interface EdgejobsEdgeJobFileResponse
 */
export interface EdgejobsEdgeJobFileResponse {
    /**
     * 
     * @type {string}
     * @memberof EdgejobsEdgeJobFileResponse
     */
    'FileContent'?: string;
}
/**
 * 
 * @export
 * @interface EdgejobsEdgeJobUpdatePayload
 */
export interface EdgejobsEdgeJobUpdatePayload {
    /**
     * 
     * @type {string}
     * @memberof EdgejobsEdgeJobUpdatePayload
     */
    'cronExpression'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgejobsEdgeJobUpdatePayload
     */
    'edgeGroups'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgejobsEdgeJobUpdatePayload
     */
    'endpoints'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof EdgejobsEdgeJobUpdatePayload
     */
    'fileContent'?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgejobsEdgeJobUpdatePayload
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EdgejobsEdgeJobUpdatePayload
     */
    'recurring'?: boolean;
}
/**
 * 
 * @export
 * @interface EdgejobsFileResponse
 */
export interface EdgejobsFileResponse {
    /**
     * 
     * @type {string}
     * @memberof EdgejobsFileResponse
     */
    'FileContent'?: string;
}
/**
 * 
 * @export
 * @interface EdgejobsTaskContainer
 */
export interface EdgejobsTaskContainer {
    /**
     * 
     * @type {number}
     * @memberof EdgejobsTaskContainer
     */
    'EndpointId'?: number;
    /**
     * 
     * @type {string}
     * @memberof EdgejobsTaskContainer
     */
    'Id'?: string;
    /**
     * 
     * @type {number}
     * @memberof EdgejobsTaskContainer
     */
    'LogsStatus'?: number;
}
/**
 * 
 * @export
 * @interface EdgestacksEdgeStackFromGitRepositoryPayload
 */
export interface EdgestacksEdgeStackFromGitRepositoryPayload {
    /**
     * Deployment type to deploy this stack Valid values are: 0 - \'compose\', 1 - \'kubernetes\' compose is enabled only for docker environments kubernetes is enabled only for kubernetes environments
     * @type {number}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    'deploymentType'?: number;
    /**
     * List of identifiers of EdgeGroups
     * @type {Array<number>}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    'edgeGroups': Array<number>;
    /**
     * Path to the Stack file inside the Git repository
     * @type {string}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    'filePathInRepository'?: string;
    /**
     * Name of the stack
     * @type {string}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    'name': string;
    /**
     * List of Registries to use for this stack
     * @type {Array<number>}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    'registries'?: Array<number>;
    /**
     * Use basic authentication to clone the Git repository
     * @type {boolean}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    'repositoryAuthentication'?: boolean;
    /**
     * Password used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    'repositoryPassword'?: string;
    /**
     * Reference name of a Git repository hosting the Stack file
     * @type {string}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    'repositoryReferenceName'?: string;
    /**
     * URL of a Git repository hosting the Stack file
     * @type {string}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    'repositoryURL': string;
    /**
     * Username used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    'repositoryUsername'?: string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    'tlsskipVerify'?: boolean;
    /**
     * Uses the manifest\'s namespaces instead of the default one
     * @type {boolean}
     * @memberof EdgestacksEdgeStackFromGitRepositoryPayload
     */
    'useManifestNamespaces'?: boolean;
}
/**
 * 
 * @export
 * @interface EdgestacksEdgeStackFromStringPayload
 */
export interface EdgestacksEdgeStackFromStringPayload {
    /**
     * Deployment type to deploy this stack Valid values are: 0 - \'compose\', 1 - \'kubernetes\' compose is enabled only for docker environments kubernetes is enabled only for kubernetes environments
     * @type {number}
     * @memberof EdgestacksEdgeStackFromStringPayload
     */
    'deploymentType'?: number;
    /**
     * List of identifiers of EdgeGroups
     * @type {Array<number>}
     * @memberof EdgestacksEdgeStackFromStringPayload
     */
    'edgeGroups'?: Array<number>;
    /**
     * Name of the stack
     * @type {string}
     * @memberof EdgestacksEdgeStackFromStringPayload
     */
    'name': string;
    /**
     * List of Registries to use for this stack
     * @type {Array<number>}
     * @memberof EdgestacksEdgeStackFromStringPayload
     */
    'registries'?: Array<number>;
    /**
     * Content of the Stack file
     * @type {string}
     * @memberof EdgestacksEdgeStackFromStringPayload
     */
    'stackFileContent': string;
    /**
     * Uses the manifest\'s namespaces instead of the default one
     * @type {boolean}
     * @memberof EdgestacksEdgeStackFromStringPayload
     */
    'useManifestNamespaces'?: boolean;
}
/**
 * 
 * @export
 * @interface EdgestacksStackFileResponse
 */
export interface EdgestacksStackFileResponse {
    /**
     * 
     * @type {string}
     * @memberof EdgestacksStackFileResponse
     */
    'StackFileContent'?: string;
}
/**
 * 
 * @export
 * @interface EdgestacksUpdateEdgeStackPayload
 */
export interface EdgestacksUpdateEdgeStackPayload {
    /**
     * Deployment type to deploy this stack Valid values are: 0 - \'compose\', 1 - \'kubernetes\' compose is enabled only for docker environments kubernetes is enabled only for kubernetes environments
     * @type {number}
     * @memberof EdgestacksUpdateEdgeStackPayload
     */
    'deploymentType'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof EdgestacksUpdateEdgeStackPayload
     */
    'edgeGroups'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof EdgestacksUpdateEdgeStackPayload
     */
    'stackFileContent'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EdgestacksUpdateEdgeStackPayload
     */
    'updateVersion'?: boolean;
    /**
     * Uses the manifest\'s namespaces instead of the default one
     * @type {boolean}
     * @memberof EdgestacksUpdateEdgeStackPayload
     */
    'useManifestNamespaces'?: boolean;
}
/**
 * 
 * @export
 * @interface EdgestacksUpdateStatusPayload
 */
export interface EdgestacksUpdateStatusPayload {
    /**
     * 
     * @type {number}
     * @memberof EdgestacksUpdateStatusPayload
     */
    'endpointID'?: number;
    /**
     * 
     * @type {string}
     * @memberof EdgestacksUpdateStatusPayload
     */
    'error'?: string;
    /**
     * Deprecated
     * @type {number}
     * @memberof EdgestacksUpdateStatusPayload
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof EdgestacksUpdateStatusPayload
     */
    'time'?: number;
}
/**
 * 
 * @export
 * @interface EndpointedgeEdgeJobResponse
 */
export interface EndpointedgeEdgeJobResponse {
    /**
     * Whether to collect logs
     * @type {boolean}
     * @memberof EndpointedgeEdgeJobResponse
     */
    'CollectLogs'?: boolean;
    /**
     * A cron expression to schedule this job
     * @type {string}
     * @memberof EndpointedgeEdgeJobResponse
     */
    'CronExpression'?: string;
    /**
     * EdgeJob Identifier
     * @type {number}
     * @memberof EndpointedgeEdgeJobResponse
     */
    'Id'?: number;
    /**
     * Script to run
     * @type {string}
     * @memberof EndpointedgeEdgeJobResponse
     */
    'Script'?: string;
    /**
     * Version of this EdgeJob
     * @type {number}
     * @memberof EndpointedgeEdgeJobResponse
     */
    'Version'?: number;
}
/**
 * 
 * @export
 * @interface EndpointedgeEndpointEdgeStatusInspectResponse
 */
export interface EndpointedgeEndpointEdgeStatusInspectResponse {
    /**
     * The current value of CheckinInterval
     * @type {number}
     * @memberof EndpointedgeEndpointEdgeStatusInspectResponse
     */
    'checkin'?: number;
    /**
     * 
     * @type {string}
     * @memberof EndpointedgeEndpointEdgeStatusInspectResponse
     */
    'credentials'?: string;
    /**
     * The tunnel port
     * @type {number}
     * @memberof EndpointedgeEndpointEdgeStatusInspectResponse
     */
    'port'?: number;
    /**
     * List of requests for jobs to run on the environment(endpoint)
     * @type {Array<EndpointedgeEdgeJobResponse>}
     * @memberof EndpointedgeEndpointEdgeStatusInspectResponse
     */
    'schedules'?: Array<EndpointedgeEdgeJobResponse>;
    /**
     * List of stacks to be deployed on the environments(endpoints)
     * @type {Array<EndpointedgeStackStatusResponse>}
     * @memberof EndpointedgeEndpointEdgeStatusInspectResponse
     */
    'stacks'?: Array<EndpointedgeStackStatusResponse>;
    /**
     * Status represents the environment(endpoint) status
     * @type {string}
     * @memberof EndpointedgeEndpointEdgeStatusInspectResponse
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface EndpointedgeStackStatusResponse
 */
export interface EndpointedgeStackStatusResponse {
    /**
     * EdgeStack Identifier
     * @type {number}
     * @memberof EndpointedgeStackStatusResponse
     */
    'id'?: number;
    /**
     * Version of this stack
     * @type {number}
     * @memberof EndpointedgeStackStatusResponse
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface EndpointgroupsEndpointGroupCreatePayload
 */
export interface EndpointgroupsEndpointGroupCreatePayload {
    /**
     * List of environment(endpoint) identifiers that will be part of this group
     * @type {Array<number>}
     * @memberof EndpointgroupsEndpointGroupCreatePayload
     */
    'associatedEndpoints'?: Array<number>;
    /**
     * Environment(Endpoint) group description
     * @type {string}
     * @memberof EndpointgroupsEndpointGroupCreatePayload
     */
    'description'?: string;
    /**
     * Environment(Endpoint) group name
     * @type {string}
     * @memberof EndpointgroupsEndpointGroupCreatePayload
     */
    'name': string;
    /**
     * List of tag identifiers to which this environment(endpoint) group is associated
     * @type {Array<number>}
     * @memberof EndpointgroupsEndpointGroupCreatePayload
     */
    'tagIDs'?: Array<number>;
}
/**
 * 
 * @export
 * @interface EndpointgroupsEndpointGroupUpdatePayload
 */
export interface EndpointgroupsEndpointGroupUpdatePayload {
    /**
     * Environment(Endpoint) group description
     * @type {string}
     * @memberof EndpointgroupsEndpointGroupUpdatePayload
     */
    'description'?: string;
    /**
     * Environment(Endpoint) group name
     * @type {string}
     * @memberof EndpointgroupsEndpointGroupUpdatePayload
     */
    'name'?: string;
    /**
     * List of tag identifiers associated to the environment(endpoint) group
     * @type {Array<number>}
     * @memberof EndpointgroupsEndpointGroupUpdatePayload
     */
    'tagIDs'?: Array<number>;
    /**
     * 
     * @type {{ [key: string]: PortainerAccessPolicy; }}
     * @memberof EndpointgroupsEndpointGroupUpdatePayload
     */
    'teamAccessPolicies'?: { [key: string]: PortainerAccessPolicy; };
    /**
     * 
     * @type {{ [key: string]: PortainerAccessPolicy; }}
     * @memberof EndpointgroupsEndpointGroupUpdatePayload
     */
    'userAccessPolicies'?: { [key: string]: PortainerAccessPolicy; };
}
/**
 * 
 * @export
 * @interface EndpointsDockerhubStatusResponse
 */
export interface EndpointsDockerhubStatusResponse {
    /**
     * Daily limit
     * @type {number}
     * @memberof EndpointsDockerhubStatusResponse
     */
    'limit'?: number;
    /**
     * Remaiming images to pull
     * @type {number}
     * @memberof EndpointsDockerhubStatusResponse
     */
    'remaining'?: number;
}
/**
 * 
 * @export
 * @interface EndpointsEndpointCreateGlobalKeyResponse
 */
export interface EndpointsEndpointCreateGlobalKeyResponse {
    /**
     * Environment(Endpoint) Identifier
     * @type {number}
     * @memberof EndpointsEndpointCreateGlobalKeyResponse
     */
    'endpointID'?: number;
}
/**
 * 
 * @export
 * @interface EndpointsEndpointSettingsUpdatePayload
 */
export interface EndpointsEndpointSettingsUpdatePayload {
    /**
     * Whether non-administrator should be able to use bind mounts when creating containers
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    'allowBindMountsForRegularUsers'?: boolean;
    /**
     * Whether non-administrator should be able to use container capabilities
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    'allowContainerCapabilitiesForRegularUsers'?: boolean;
    /**
     * Whether non-administrator should be able to use device mapping
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    'allowDeviceMappingForRegularUsers'?: boolean;
    /**
     * Whether non-administrator should be able to use the host pid
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    'allowHostNamespaceForRegularUsers'?: boolean;
    /**
     * Whether non-administrator should be able to use privileged mode when creating containers
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    'allowPrivilegedModeForRegularUsers'?: boolean;
    /**
     * Whether non-administrator should be able to manage stacks
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    'allowStackManagementForRegularUsers'?: boolean;
    /**
     * Whether non-administrator should be able to use sysctl settings
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    'allowSysctlSettingForRegularUsers'?: boolean;
    /**
     * Whether non-administrator should be able to browse volumes
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    'allowVolumeBrowserForRegularUsers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    'enableGPUManagement'?: boolean;
    /**
     * Whether host management features are enabled
     * @type {boolean}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    'enableHostManagementFeatures'?: boolean;
    /**
     * 
     * @type {Array<PortainerPair>}
     * @memberof EndpointsEndpointSettingsUpdatePayload
     */
    'gpus'?: Array<PortainerPair>;
}
/**
 * 
 * @export
 * @interface EndpointsEndpointUpdatePayload
 */
export interface EndpointsEndpointUpdatePayload {
    /**
     * Azure application ID
     * @type {string}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'azureApplicationID'?: string;
    /**
     * Azure authentication key
     * @type {string}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'azureAuthenticationKey'?: string;
    /**
     * Azure tenant ID
     * @type {string}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'azureTenantID'?: string;
    /**
     * The check in interval for edge agent (in seconds)
     * @type {number}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'edgeCheckinInterval'?: number;
    /**
     * GPUs information
     * @type {Array<PortainerPair>}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'gpus'?: Array<PortainerPair>;
    /**
     * Group identifier
     * @type {number}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'groupID'?: number;
    /**
     * 
     * @type {PortainerKubernetesData}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'kubernetes'?: PortainerKubernetesData;
    /**
     * Name that will be used to identify this environment(endpoint)
     * @type {string}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'name'?: string;
    /**
     * URL or IP address where exposed containers will be reachable.\\ Defaults to URL if not specified
     * @type {string}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'publicURL'?: string;
    /**
     * The status of the environment(endpoint) (1 - up, 2 - down)
     * @type {number}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'status'?: number;
    /**
     * List of tag identifiers to which this environment(endpoint) is associated
     * @type {Array<number>}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'tagIDs'?: Array<number>;
    /**
     * 
     * @type {{ [key: string]: PortainerAccessPolicy; }}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'teamAccessPolicies'?: { [key: string]: PortainerAccessPolicy; };
    /**
     * Require TLS to connect against this environment(endpoint)
     * @type {boolean}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'tls'?: boolean;
    /**
     * Skip client verification when using TLS
     * @type {boolean}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'tlsskipClientVerify'?: boolean;
    /**
     * Skip server verification when using TLS
     * @type {boolean}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'tlsskipVerify'?: boolean;
    /**
     * URL or IP address of a Docker host
     * @type {string}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'url'?: string;
    /**
     * 
     * @type {{ [key: string]: PortainerAccessPolicy; }}
     * @memberof EndpointsEndpointUpdatePayload
     */
    'userAccessPolicies'?: { [key: string]: PortainerAccessPolicy; };
}
/**
 * 
 * @export
 * @interface EndpointsEndpointUpdateRelationsPayload
 */
export interface EndpointsEndpointUpdateRelationsPayload {
    /**
     * 
     * @type {{ [key: string]: EndpointsEndpointUpdateRelationsPayloadRelations; }}
     * @memberof EndpointsEndpointUpdateRelationsPayload
     */
    'relations'?: { [key: string]: EndpointsEndpointUpdateRelationsPayloadRelations; };
}
/**
 * 
 * @export
 * @interface EndpointsEndpointUpdateRelationsPayloadRelations
 */
export interface EndpointsEndpointUpdateRelationsPayloadRelations {
    /**
     * 
     * @type {Array<number>}
     * @memberof EndpointsEndpointUpdateRelationsPayloadRelations
     */
    'edgeGroups'?: Array<number>;
    /**
     * Environment(Endpoint) group identifier
     * @type {number}
     * @memberof EndpointsEndpointUpdateRelationsPayloadRelations
     */
    'group'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof EndpointsEndpointUpdateRelationsPayloadRelations
     */
    'tags'?: Array<number>;
}
/**
 * 
 * @export
 * @interface EndpointsForceUpdateServicePayload
 */
export interface EndpointsForceUpdateServicePayload {
    /**
     * PullImage if true will pull the image
     * @type {boolean}
     * @memberof EndpointsForceUpdateServicePayload
     */
    'pullImage'?: boolean;
    /**
     * ServiceId to update
     * @type {string}
     * @memberof EndpointsForceUpdateServicePayload
     */
    'serviceID'?: string;
}
/**
 * 
 * @export
 * @interface EndpointsRegistryAccessPayload
 */
export interface EndpointsRegistryAccessPayload {
    /**
     * 
     * @type {Array<string>}
     * @memberof EndpointsRegistryAccessPayload
     */
    'namespaces'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: PortainerAccessPolicy; }}
     * @memberof EndpointsRegistryAccessPayload
     */
    'teamAccessPolicies'?: { [key: string]: PortainerAccessPolicy; };
    /**
     * 
     * @type {{ [key: string]: PortainerAccessPolicy; }}
     * @memberof EndpointsRegistryAccessPayload
     */
    'userAccessPolicies'?: { [key: string]: PortainerAccessPolicy; };
}
/**
 * 
 * @export
 * @interface FdoDeviceConfigurePayload
 */
export interface FdoDeviceConfigurePayload {
    /**
     * 
     * @type {string}
     * @memberof FdoDeviceConfigurePayload
     */
    'edgeID'?: string;
    /**
     * 
     * @type {string}
     * @memberof FdoDeviceConfigurePayload
     */
    'edgeKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof FdoDeviceConfigurePayload
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FdoDeviceConfigurePayload
     */
    'profile'?: number;
}
/**
 * 
 * @export
 * @interface FdoFdoConfigurePayload
 */
export interface FdoFdoConfigurePayload {
    /**
     * 
     * @type {boolean}
     * @memberof FdoFdoConfigurePayload
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FdoFdoConfigurePayload
     */
    'ownerPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof FdoFdoConfigurePayload
     */
    'ownerURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof FdoFdoConfigurePayload
     */
    'ownerUsername'?: string;
}
/**
 * 
 * @export
 * @interface FilesystemDirEntry
 */
export interface FilesystemDirEntry {
    /**
     * 
     * @type {string}
     * @memberof FilesystemDirEntry
     */
    'content'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FilesystemDirEntry
     */
    'isFile'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FilesystemDirEntry
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FilesystemDirEntry
     */
    'permissions'?: number;
}
/**
 * 
 * @export
 * @interface GitopsFileResponse
 */
export interface GitopsFileResponse {
    /**
     * 
     * @type {string}
     * @memberof GitopsFileResponse
     */
    'fileContent'?: string;
}
/**
 * 
 * @export
 * @interface GitopsRepositoryFilePreviewPayload
 */
export interface GitopsRepositoryFilePreviewPayload {
    /**
     * 
     * @type {string}
     * @memberof GitopsRepositoryFilePreviewPayload
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitopsRepositoryFilePreviewPayload
     */
    'reference'?: string;
    /**
     * 
     * @type {string}
     * @memberof GitopsRepositoryFilePreviewPayload
     */
    'repository': string;
    /**
     * Path to file whose content will be read
     * @type {string}
     * @memberof GitopsRepositoryFilePreviewPayload
     */
    'targetFile'?: string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof GitopsRepositoryFilePreviewPayload
     */
    'tlsskipVerify'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GitopsRepositoryFilePreviewPayload
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface GittypesGitAuthentication
 */
export interface GittypesGitAuthentication {
    /**
     * Git credentials identifier when the value is not 0 When the value is 0, Username and Password are set without using saved credential This is introduced since 2.15.0
     * @type {number}
     * @memberof GittypesGitAuthentication
     */
    'gitCredentialID'?: number;
    /**
     * 
     * @type {string}
     * @memberof GittypesGitAuthentication
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof GittypesGitAuthentication
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface GittypesRepoConfig
 */
export interface GittypesRepoConfig {
    /**
     * 
     * @type {GittypesGitAuthentication}
     * @memberof GittypesRepoConfig
     */
    'authentication'?: GittypesGitAuthentication;
    /**
     * Path to where the config file is in this url/refName
     * @type {string}
     * @memberof GittypesRepoConfig
     */
    'configFilePath'?: string;
    /**
     * Repository hash
     * @type {string}
     * @memberof GittypesRepoConfig
     */
    'configHash'?: string;
    /**
     * The reference name
     * @type {string}
     * @memberof GittypesRepoConfig
     */
    'referenceName'?: string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof GittypesRepoConfig
     */
    'tlsskipVerify'?: boolean;
    /**
     * The repo url
     * @type {string}
     * @memberof GittypesRepoConfig
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface HelmAddHelmRepoUrlPayload
 */
export interface HelmAddHelmRepoUrlPayload {
    /**
     * 
     * @type {string}
     * @memberof HelmAddHelmRepoUrlPayload
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface HelmHelmUserRepositoryResponse
 */
export interface HelmHelmUserRepositoryResponse {
    /**
     * 
     * @type {string}
     * @memberof HelmHelmUserRepositoryResponse
     */
    'GlobalRepository'?: string;
    /**
     * 
     * @type {Array<PortainerHelmUserRepository>}
     * @memberof HelmHelmUserRepositoryResponse
     */
    'UserRepositories'?: Array<PortainerHelmUserRepository>;
}
/**
 * 
 * @export
 * @interface HelmInstallChartPayload
 */
export interface HelmInstallChartPayload {
    /**
     * 
     * @type {string}
     * @memberof HelmInstallChartPayload
     */
    'chart'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmInstallChartPayload
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmInstallChartPayload
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmInstallChartPayload
     */
    'repo'?: string;
    /**
     * 
     * @type {string}
     * @memberof HelmInstallChartPayload
     */
    'values'?: string;
}
/**
 * 
 * @export
 * @interface ImagesImageResponse
 */
export interface ImagesImageResponse {
    /**
     * 
     * @type {number}
     * @memberof ImagesImageResponse
     */
    'created'?: number;
    /**
     * 
     * @type {string}
     * @memberof ImagesImageResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImagesImageResponse
     */
    'nodeName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ImagesImageResponse
     */
    'size'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImagesImageResponse
     */
    'tags'?: Array<string>;
    /**
     * Used is true if the image is used by at least one container supplied only when withUsage is true
     * @type {boolean}
     * @memberof ImagesImageResponse
     */
    'used'?: boolean;
}
/**
 * 
 * @export
 * @interface KubernetesK8sApplication
 */
export interface KubernetesK8sApplication {
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sApplication
     */
    'kind'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sApplication
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sApplication
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sApplication
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sApplication
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface KubernetesK8sConfigMapOrSecret
 */
export interface KubernetesK8sConfigMapOrSecret {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sConfigMapOrSecret
     */
    'Annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof KubernetesK8sConfigMapOrSecret
     */
    'Applications'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sConfigMapOrSecret
     */
    'CreationDate'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sConfigMapOrSecret
     */
    'Data'?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof KubernetesK8sConfigMapOrSecret
     */
    'IsSecret'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sConfigMapOrSecret
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sConfigMapOrSecret
     */
    'Namespace'?: string;
    /**
     * SecretType will be an empty string for config maps.
     * @type {string}
     * @memberof KubernetesK8sConfigMapOrSecret
     */
    'SecretType'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sConfigMapOrSecret
     */
    'UID'?: string;
}
/**
 * 
 * @export
 * @interface KubernetesK8sIngressController
 */
export interface KubernetesK8sIngressController {
    /**
     * 
     * @type {boolean}
     * @memberof KubernetesK8sIngressController
     */
    'Availability'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressController
     */
    'ClassName'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressController
     */
    'Name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KubernetesK8sIngressController
     */
    'New'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressController
     */
    'Type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KubernetesK8sIngressController
     */
    'Used'?: boolean;
}
/**
 * 
 * @export
 * @interface KubernetesK8sIngressInfo
 */
export interface KubernetesK8sIngressInfo {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sIngressInfo
     */
    'Annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressInfo
     */
    'ClassName'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressInfo
     */
    'CreationDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof KubernetesK8sIngressInfo
     */
    'Hosts'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sIngressInfo
     */
    'Labels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressInfo
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressInfo
     */
    'Namespace'?: string;
    /**
     * 
     * @type {Array<KubernetesK8sIngressPath>}
     * @memberof KubernetesK8sIngressInfo
     */
    'Paths'?: Array<KubernetesK8sIngressPath>;
    /**
     * 
     * @type {Array<KubernetesK8sIngressTLS>}
     * @memberof KubernetesK8sIngressInfo
     */
    'TLS'?: Array<KubernetesK8sIngressTLS>;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressInfo
     */
    'Type'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressInfo
     */
    'UID'?: string;
}
/**
 * 
 * @export
 * @interface KubernetesK8sIngressPath
 */
export interface KubernetesK8sIngressPath {
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressPath
     */
    'Host'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressPath
     */
    'IngressName'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressPath
     */
    'Path'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressPath
     */
    'PathType'?: string;
    /**
     * 
     * @type {number}
     * @memberof KubernetesK8sIngressPath
     */
    'Port'?: number;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressPath
     */
    'ServiceName'?: string;
}
/**
 * 
 * @export
 * @interface KubernetesK8sIngressTLS
 */
export interface KubernetesK8sIngressTLS {
    /**
     * 
     * @type {Array<string>}
     * @memberof KubernetesK8sIngressTLS
     */
    'Hosts'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sIngressTLS
     */
    'SecretName'?: string;
}
/**
 * 
 * @export
 * @interface KubernetesK8sNamespaceDetails
 */
export interface KubernetesK8sNamespaceDetails {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sNamespaceDetails
     */
    'Annotations'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sNamespaceDetails
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sNamespaceDetails
     */
    'Owner'?: string;
    /**
     * 
     * @type {KubernetesK8sResourceQuota}
     * @memberof KubernetesK8sNamespaceDetails
     */
    'ResourceQuota'?: KubernetesK8sResourceQuota;
}
/**
 * 
 * @export
 * @interface KubernetesK8sResourceQuota
 */
export interface KubernetesK8sResourceQuota {
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sResourceQuota
     */
    'cpu'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KubernetesK8sResourceQuota
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sResourceQuota
     */
    'memory'?: string;
}
/**
 * 
 * @export
 * @interface KubernetesK8sServiceInfo
 */
export interface KubernetesK8sServiceInfo {
    /**
     * 
     * @type {boolean}
     * @memberof KubernetesK8sServiceInfo
     */
    'allocateLoadBalancerNodePorts'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sServiceInfo
     */
    'annotations'?: { [key: string]: string; };
    /**
     * serviceList screen
     * @type {Array<KubernetesK8sApplication>}
     * @memberof KubernetesK8sServiceInfo
     */
    'applications'?: Array<KubernetesK8sApplication>;
    /**
     * 
     * @type {Array<string>}
     * @memberof KubernetesK8sServiceInfo
     */
    'clusterIPs'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceInfo
     */
    'creationTimestamp'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof KubernetesK8sServiceInfo
     */
    'externalIPs'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceInfo
     */
    'externalName'?: string;
    /**
     * 
     * @type {Array<KubernetesK8sServiceIngress>}
     * @memberof KubernetesK8sServiceInfo
     */
    'ingressStatus'?: Array<KubernetesK8sServiceIngress>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sServiceInfo
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceInfo
     */
    'namespace'?: string;
    /**
     * 
     * @type {Array<KubernetesK8sServicePort>}
     * @memberof KubernetesK8sServiceInfo
     */
    'ports'?: Array<KubernetesK8sServicePort>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KubernetesK8sServiceInfo
     */
    'selector'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceInfo
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceInfo
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface KubernetesK8sServiceIngress
 */
export interface KubernetesK8sServiceIngress {
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceIngress
     */
    'Host'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServiceIngress
     */
    'IP'?: string;
}
/**
 * 
 * @export
 * @interface KubernetesK8sServicePort
 */
export interface KubernetesK8sServicePort {
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServicePort
     */
    'Name'?: string;
    /**
     * 
     * @type {number}
     * @memberof KubernetesK8sServicePort
     */
    'NodePort'?: number;
    /**
     * 
     * @type {number}
     * @memberof KubernetesK8sServicePort
     */
    'Port'?: number;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServicePort
     */
    'Protocol'?: string;
    /**
     * 
     * @type {string}
     * @memberof KubernetesK8sServicePort
     */
    'TargetPort'?: string;
}
/**
 * 
 * @export
 * @interface KubernetesNamespacesToggleSystemPayload
 */
export interface KubernetesNamespacesToggleSystemPayload {
    /**
     * Toggle the system state of this namespace to true or false
     * @type {boolean}
     * @memberof KubernetesNamespacesToggleSystemPayload
     */
    'system'?: boolean;
}
/**
 * 
 * @export
 * @interface LdapCheckPayload
 */
export interface LdapCheckPayload {
    /**
     * 
     * @type {PortainerLDAPSettings}
     * @memberof LdapCheckPayload
     */
    'ldapsettings'?: PortainerLDAPSettings;
}
/**
 * 
 * @export
 * @interface MotdMotdResponse
 */
export interface MotdMotdResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MotdMotdResponse
     */
    'ContentLayout'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<number>}
     * @memberof MotdMotdResponse
     */
    'Hash'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof MotdMotdResponse
     */
    'Message'?: string;
    /**
     * 
     * @type {string}
     * @memberof MotdMotdResponse
     */
    'Style'?: string;
    /**
     * 
     * @type {string}
     * @memberof MotdMotdResponse
     */
    'Title'?: string;
}
/**
 * 
 * @export
 * @interface OpenamtDeviceActionPayload
 */
export interface OpenamtDeviceActionPayload {
    /**
     * 
     * @type {string}
     * @memberof OpenamtDeviceActionPayload
     */
    'action'?: string;
}
/**
 * 
 * @export
 * @interface OpenamtDeviceFeaturesPayload
 */
export interface OpenamtDeviceFeaturesPayload {
    /**
     * 
     * @type {PortainerOpenAMTDeviceEnabledFeatures}
     * @memberof OpenamtDeviceFeaturesPayload
     */
    'features'?: PortainerOpenAMTDeviceEnabledFeatures;
}
/**
 * 
 * @export
 * @interface OpenamtOpenAMTConfigurePayload
 */
export interface OpenamtOpenAMTConfigurePayload {
    /**
     * 
     * @type {string}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    'certFileContent'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    'certFileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    'certFilePassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    'domainName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    'mpspassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    'mpsserver'?: string;
    /**
     * 
     * @type {string}
     * @memberof OpenamtOpenAMTConfigurePayload
     */
    'mpsuser'?: string;
}
/**
 * 
 * @export
 * @interface PortainerAPIKey
 */
export interface PortainerAPIKey {
    /**
     * Unix timestamp (UTC) when the API key was created
     * @type {number}
     * @memberof PortainerAPIKey
     */
    'dateCreated'?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerAPIKey
     */
    'description'?: string;
    /**
     * Digest represents SHA256 hash of the raw API key
     * @type {string}
     * @memberof PortainerAPIKey
     */
    'digest'?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerAPIKey
     */
    'id'?: number;
    /**
     * Unix timestamp (UTC) when the API key was last used
     * @type {number}
     * @memberof PortainerAPIKey
     */
    'lastUsed'?: number;
    /**
     * API key identifier (7 char prefix)
     * @type {string}
     * @memberof PortainerAPIKey
     */
    'prefix'?: string;
    /**
     * User Identifier
     * @type {number}
     * @memberof PortainerAPIKey
     */
    'userId'?: number;
}
/**
 * 
 * @export
 * @interface PortainerAccessPolicy
 */
export interface PortainerAccessPolicy {
    /**
     * Role identifier. Reference the role that will be associated to this access policy
     * @type {number}
     * @memberof PortainerAccessPolicy
     */
    'RoleId'?: number;
}
/**
 * 
 * @export
 * @interface PortainerAutoUpdateSettings
 */
export interface PortainerAutoUpdateSettings {
    /**
     * Pull latest image
     * @type {boolean}
     * @memberof PortainerAutoUpdateSettings
     */
    'forcePullImage'?: boolean;
    /**
     * Force update ignores repo changes
     * @type {boolean}
     * @memberof PortainerAutoUpdateSettings
     */
    'forceUpdate'?: boolean;
    /**
     * Auto update interval
     * @type {string}
     * @memberof PortainerAutoUpdateSettings
     */
    'interval'?: string;
    /**
     * Autoupdate job id
     * @type {string}
     * @memberof PortainerAutoUpdateSettings
     */
    'jobID'?: string;
    /**
     * A UUID generated from client
     * @type {string}
     * @memberof PortainerAutoUpdateSettings
     */
    'webhook'?: string;
}
/**
 * 
 * @export
 * @interface PortainerAzureCredentials
 */
export interface PortainerAzureCredentials {
    /**
     * Azure application ID
     * @type {string}
     * @memberof PortainerAzureCredentials
     */
    'ApplicationID'?: string;
    /**
     * Azure authentication key
     * @type {string}
     * @memberof PortainerAzureCredentials
     */
    'AuthenticationKey'?: string;
    /**
     * Azure tenant ID
     * @type {string}
     * @memberof PortainerAzureCredentials
     */
    'TenantID'?: string;
}
/**
 * 
 * @export
 * @interface PortainerCustomTemplate
 */
export interface PortainerCustomTemplate {
    /**
     * User identifier who created this template
     * @type {number}
     * @memberof PortainerCustomTemplate
     */
    'CreatedByUserId'?: number;
    /**
     * Description of the template
     * @type {string}
     * @memberof PortainerCustomTemplate
     */
    'Description'?: string;
    /**
     * Path to the Stack file
     * @type {string}
     * @memberof PortainerCustomTemplate
     */
    'EntryPoint'?: string;
    /**
     * 
     * @type {GittypesRepoConfig}
     * @memberof PortainerCustomTemplate
     */
    'GitConfig'?: GittypesRepoConfig;
    /**
     * CustomTemplate Identifier
     * @type {number}
     * @memberof PortainerCustomTemplate
     */
    'Id'?: number;
    /**
     * URL of the template\'s logo
     * @type {string}
     * @memberof PortainerCustomTemplate
     */
    'Logo'?: string;
    /**
     * A note that will be displayed in the UI. Supports HTML content
     * @type {string}
     * @memberof PortainerCustomTemplate
     */
    'Note'?: string;
    /**
     * Platform associated to the template. Valid values are: 1 - \'linux\', 2 - \'windows\'
     * @type {number}
     * @memberof PortainerCustomTemplate
     */
    'Platform'?: number;
    /**
     * Path on disk to the repository hosting the Stack file
     * @type {string}
     * @memberof PortainerCustomTemplate
     */
    'ProjectPath'?: string;
    /**
     * 
     * @type {PortainerResourceControl}
     * @memberof PortainerCustomTemplate
     */
    'ResourceControl'?: PortainerResourceControl;
    /**
     * Title of the template
     * @type {string}
     * @memberof PortainerCustomTemplate
     */
    'Title'?: string;
    /**
     * Type of created stack: * 1 - swarm * 2 - compose * 3 - kubernetes
     * @type {number}
     * @memberof PortainerCustomTemplate
     */
    'Type'?: number;
    /**
     * EdgeTemplate indicates if this template purpose for Edge Stack
     * @type {boolean}
     * @memberof PortainerCustomTemplate
     */
    'edgeTemplate'?: boolean;
    /**
     * IsComposeFormat indicates if the Kubernetes template is created from a Docker Compose file
     * @type {boolean}
     * @memberof PortainerCustomTemplate
     */
    'isComposeFormat'?: boolean;
    /**
     * 
     * @type {Array<PortainerCustomTemplateVariableDefinition>}
     * @memberof PortainerCustomTemplate
     */
    'variables'?: Array<PortainerCustomTemplateVariableDefinition>;
}
/**
 * 
 * @export
 * @interface PortainerCustomTemplateVariableDefinition
 */
export interface PortainerCustomTemplateVariableDefinition {
    /**
     * 
     * @type {string}
     * @memberof PortainerCustomTemplateVariableDefinition
     */
    'defaultValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerCustomTemplateVariableDefinition
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerCustomTemplateVariableDefinition
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerCustomTemplateVariableDefinition
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PortainerDockerSnapshot
 */
export interface PortainerDockerSnapshot {
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    'ContainerCount'?: number;
    /**
     * 
     * @type {object}
     * @memberof PortainerDockerSnapshot
     */
    'DockerSnapshotRaw'?: object;
    /**
     * 
     * @type {string}
     * @memberof PortainerDockerSnapshot
     */
    'DockerVersion'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerDockerSnapshot
     */
    'GpuUseAll'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PortainerDockerSnapshot
     */
    'GpuUseList'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    'HealthyContainerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    'ImageCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    'NodeCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    'RunningContainerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    'ServiceCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    'StackCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    'StoppedContainerCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerDockerSnapshot
     */
    'Swarm'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    'Time'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    'TotalCPU'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    'TotalMemory'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    'UnhealthyContainerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerDockerSnapshot
     */
    'VolumeCount'?: number;
}
/**
 * 
 * @export
 * @interface PortainerEcrData
 */
export interface PortainerEcrData {
    /**
     * 
     * @type {string}
     * @memberof PortainerEcrData
     */
    'Region'?: string;
}
/**
 * 
 * @export
 * @interface PortainerEdgeGroup
 */
export interface PortainerEdgeGroup {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeGroup
     */
    'Dynamic'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof PortainerEdgeGroup
     */
    'Endpoints'?: Array<number>;
    /**
     * EdgeGroup Identifier
     * @type {number}
     * @memberof PortainerEdgeGroup
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeGroup
     */
    'Name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeGroup
     */
    'PartialMatch'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof PortainerEdgeGroup
     */
    'TagIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface PortainerEdgeJob
 */
export interface PortainerEdgeJob {
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeJob
     */
    'Created'?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeJob
     */
    'CronExpression'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PortainerEdgeJob
     */
    'EdgeGroups'?: Array<number>;
    /**
     * 
     * @type {{ [key: string]: PortainerEdgeJobEndpointMeta; }}
     * @memberof PortainerEdgeJob
     */
    'Endpoints'?: { [key: string]: PortainerEdgeJobEndpointMeta; };
    /**
     * EdgeJob Identifier
     * @type {number}
     * @memberof PortainerEdgeJob
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeJob
     */
    'Name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeJob
     */
    'Recurring'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeJob
     */
    'ScriptPath'?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeJob
     */
    'Version'?: number;
    /**
     * Field used for log collection of Endpoints belonging to EdgeGroups
     * @type {{ [key: string]: PortainerEdgeJobEndpointMeta; }}
     * @memberof PortainerEdgeJob
     */
    'groupLogsCollection'?: { [key: string]: PortainerEdgeJobEndpointMeta; };
}
/**
 * 
 * @export
 * @interface PortainerEdgeJobEndpointMeta
 */
export interface PortainerEdgeJobEndpointMeta {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeJobEndpointMeta
     */
    'collectLogs'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeJobEndpointMeta
     */
    'logsStatus'?: number;
}
/**
 * 
 * @export
 * @interface PortainerEdgeStack
 */
export interface PortainerEdgeStack {
    /**
     * StatusArray    map[EndpointID][]EdgeStackStatus `json:\"StatusArray\"`
     * @type {number}
     * @memberof PortainerEdgeStack
     */
    'CreationDate'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof PortainerEdgeStack
     */
    'EdgeGroups'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeStack
     */
    'EntryPoint'?: string;
    /**
     * EdgeStack Identifier
     * @type {number}
     * @memberof PortainerEdgeStack
     */
    'Id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeStack
     */
    'Name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeStack
     */
    'NumDeployments'?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeStack
     */
    'ProjectPath'?: string;
    /**
     * Deprecated
     * @type {boolean}
     * @memberof PortainerEdgeStack
     */
    'Prune'?: boolean;
    /**
     * 
     * @type {{ [key: string]: PortainerEdgeStackStatus; }}
     * @memberof PortainerEdgeStack
     */
    'Status'?: { [key: string]: PortainerEdgeStackStatus; };
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeStack
     */
    'Version'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeStack
     */
    'deploymentType'?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeStack
     */
    'manifestPath'?: string;
    /**
     * Uses the manifest\'s namespaces instead of the default one
     * @type {boolean}
     * @memberof PortainerEdgeStack
     */
    'useManifestNamespaces'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerEdgeStackDeploymentStatus
 */
export interface PortainerEdgeStackDeploymentStatus {
    /**
     * 
     * @type {string}
     * @memberof PortainerEdgeStackDeploymentStatus
     */
    'error'?: string;
    /**
     * EE only feature
     * @type {number}
     * @memberof PortainerEdgeStackDeploymentStatus
     */
    'rollbackTo'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeStackDeploymentStatus
     */
    'time'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeStackDeploymentStatus
     */
    'type'?: number;
}
/**
 * 
 * @export
 * @interface PortainerEdgeStackStatus
 */
export interface PortainerEdgeStackStatus {
    /**
     * Deprecated
     * @type {number}
     * @memberof PortainerEdgeStackStatus
     */
    'Type'?: number;
    /**
     * 
     * @type {PortainerStackDeploymentInfo}
     * @memberof PortainerEdgeStackStatus
     */
    'deploymentInfo'?: PortainerStackDeploymentInfo;
    /**
     * 
     * @type {PortainerEdgeStackStatusDetails}
     * @memberof PortainerEdgeStackStatus
     */
    'details'?: PortainerEdgeStackStatusDetails;
    /**
     * 
     * @type {number}
     * @memberof PortainerEdgeStackStatus
     */
    'endpointID'?: number;
    /**
     * Deprecated
     * @type {string}
     * @memberof PortainerEdgeStackStatus
     */
    'error'?: string;
    /**
     * ReadyRePullImage is a flag to indicate whether the auto update is trigger to re-pull image
     * @type {boolean}
     * @memberof PortainerEdgeStackStatus
     */
    'readyRePullImage'?: boolean;
    /**
     * 
     * @type {Array<PortainerEdgeStackDeploymentStatus>}
     * @memberof PortainerEdgeStackStatus
     */
    'status'?: Array<PortainerEdgeStackDeploymentStatus>;
}
/**
 * 
 * @export
 * @interface PortainerEdgeStackStatusDetails
 */
export interface PortainerEdgeStackStatusDetails {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeStackStatusDetails
     */
    'acknowledged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeStackStatusDetails
     */
    'error'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeStackStatusDetails
     */
    'imagesPulled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeStackStatusDetails
     */
    'ok'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeStackStatusDetails
     */
    'pending'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeStackStatusDetails
     */
    'remoteUpdateSuccess'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEdgeStackStatusDetails
     */
    'remove'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerEndpoint
 */
export interface PortainerEndpoint {
    /**
     * The identifier of the AMT Device associated with this environment(endpoint)
     * @type {string}
     * @memberof PortainerEndpoint
     */
    'AMTDeviceGUID'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PortainerEndpoint
     */
    'AuthorizedTeams'?: Array<number>;
    /**
     * Deprecated in DBVersion == 18
     * @type {Array<number>}
     * @memberof PortainerEndpoint
     */
    'AuthorizedUsers'?: Array<number>;
    /**
     * 
     * @type {PortainerAzureCredentials}
     * @memberof PortainerEndpoint
     */
    'AzureCredentials'?: PortainerAzureCredentials;
    /**
     * Maximum version of docker-compose
     * @type {string}
     * @memberof PortainerEndpoint
     */
    'ComposeSyntaxMaxVersion'?: string;
    /**
     * The check in interval for edge agent (in seconds)
     * @type {number}
     * @memberof PortainerEndpoint
     */
    'EdgeCheckinInterval'?: number;
    /**
     * The identifier of the edge agent associated with this environment(endpoint)
     * @type {string}
     * @memberof PortainerEndpoint
     */
    'EdgeID'?: string;
    /**
     * The key which is used to map the agent to Portainer
     * @type {string}
     * @memberof PortainerEndpoint
     */
    'EdgeKey'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEndpoint
     */
    'EnableGPUManagement'?: boolean;
    /**
     * 
     * @type {Array<PortainerPair>}
     * @memberof PortainerEndpoint
     */
    'Gpus'?: Array<PortainerPair>;
    /**
     * Environment(Endpoint) group identifier
     * @type {number}
     * @memberof PortainerEndpoint
     */
    'GroupId'?: number;
    /**
     * Heartbeat indicates the heartbeat status of an edge environment
     * @type {boolean}
     * @memberof PortainerEndpoint
     */
    'Heartbeat'?: boolean;
    /**
     * Environment(Endpoint) Identifier
     * @type {number}
     * @memberof PortainerEndpoint
     */
    'Id'?: number;
    /**
     * Deprecated v2.18
     * @type {boolean}
     * @memberof PortainerEndpoint
     */
    'IsEdgeDevice'?: boolean;
    /**
     * 
     * @type {PortainerKubernetesData}
     * @memberof PortainerEndpoint
     */
    'Kubernetes'?: PortainerKubernetesData;
    /**
     * Environment(Endpoint) name
     * @type {string}
     * @memberof PortainerEndpoint
     */
    'Name'?: string;
    /**
     * 
     * @type {PortainerEndpointPostInitMigrations}
     * @memberof PortainerEndpoint
     */
    'PostInitMigrations'?: PortainerEndpointPostInitMigrations;
    /**
     * URL or IP address where exposed containers will be reachable
     * @type {string}
     * @memberof PortainerEndpoint
     */
    'PublicURL'?: string;
    /**
     * List of snapshots
     * @type {Array<PortainerDockerSnapshot>}
     * @memberof PortainerEndpoint
     */
    'Snapshots'?: Array<PortainerDockerSnapshot>;
    /**
     * The status of the environment(endpoint) (1 - up, 2 - down)
     * @type {number}
     * @memberof PortainerEndpoint
     */
    'Status'?: number;
    /**
     * Deprecated fields Deprecated in DBVersion == 4
     * @type {boolean}
     * @memberof PortainerEndpoint
     */
    'TLS'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerEndpoint
     */
    'TLSCACert'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerEndpoint
     */
    'TLSCert'?: string;
    /**
     * 
     * @type {PortainerTLSConfiguration}
     * @memberof PortainerEndpoint
     */
    'TLSConfig'?: PortainerTLSConfiguration;
    /**
     * 
     * @type {string}
     * @memberof PortainerEndpoint
     */
    'TLSKey'?: string;
    /**
     * List of tag identifiers to which this environment(endpoint) is associated
     * @type {Array<number>}
     * @memberof PortainerEndpoint
     */
    'TagIds'?: Array<number>;
    /**
     * Deprecated in DBVersion == 22
     * @type {Array<string>}
     * @memberof PortainerEndpoint
     */
    'Tags'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: PortainerAccessPolicy; }}
     * @memberof PortainerEndpoint
     */
    'TeamAccessPolicies'?: { [key: string]: PortainerAccessPolicy; };
    /**
     * Environment(Endpoint) environment(endpoint) type. 1 for a Docker environment(endpoint), 2 for an agent on Docker environment(endpoint) or 3 for an Azure environment(endpoint).
     * @type {number}
     * @memberof PortainerEndpoint
     */
    'Type'?: number;
    /**
     * URL or IP address of the Docker host associated to this environment(endpoint)
     * @type {string}
     * @memberof PortainerEndpoint
     */
    'URL'?: string;
    /**
     * 
     * @type {{ [key: string]: PortainerAccessPolicy; }}
     * @memberof PortainerEndpoint
     */
    'UserAccessPolicies'?: { [key: string]: PortainerAccessPolicy; };
    /**
     * Whether the device has been trusted or not by the user
     * @type {boolean}
     * @memberof PortainerEndpoint
     */
    'UserTrusted'?: boolean;
    /**
     * 
     * @type {PortainerEndpointAgent}
     * @memberof PortainerEndpoint
     */
    'agent'?: PortainerEndpointAgent;
    /**
     * 
     * @type {PortainerEnvironmentEdgeSettings}
     * @memberof PortainerEndpoint
     */
    'edge'?: PortainerEnvironmentEdgeSettings;
    /**
     * LastCheckInDate mark last check-in date on checkin
     * @type {number}
     * @memberof PortainerEndpoint
     */
    'lastCheckInDate'?: number;
    /**
     * QueryDate of each query with the endpoints list
     * @type {number}
     * @memberof PortainerEndpoint
     */
    'queryDate'?: number;
    /**
     * 
     * @type {PortainerEndpointSecuritySettings}
     * @memberof PortainerEndpoint
     */
    'securitySettings'?: PortainerEndpointSecuritySettings;
}
/**
 * 
 * @export
 * @interface PortainerEndpointAgent
 */
export interface PortainerEndpointAgent {
    /**
     * 
     * @type {string}
     * @memberof PortainerEndpointAgent
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface PortainerEndpointGroup
 */
export interface PortainerEndpointGroup {
    /**
     * 
     * @type {Array<number>}
     * @memberof PortainerEndpointGroup
     */
    'AuthorizedTeams'?: Array<number>;
    /**
     * Deprecated in DBVersion == 18
     * @type {Array<number>}
     * @memberof PortainerEndpointGroup
     */
    'AuthorizedUsers'?: Array<number>;
    /**
     * Description associated to the environment(endpoint) group
     * @type {string}
     * @memberof PortainerEndpointGroup
     */
    'Description'?: string;
    /**
     * Environment(Endpoint) group Identifier
     * @type {number}
     * @memberof PortainerEndpointGroup
     */
    'Id'?: number;
    /**
     * Deprecated fields
     * @type {Array<PortainerPair>}
     * @memberof PortainerEndpointGroup
     */
    'Labels'?: Array<PortainerPair>;
    /**
     * Environment(Endpoint) group name
     * @type {string}
     * @memberof PortainerEndpointGroup
     */
    'Name'?: string;
    /**
     * List of tags associated to this environment(endpoint) group
     * @type {Array<number>}
     * @memberof PortainerEndpointGroup
     */
    'TagIds'?: Array<number>;
    /**
     * Deprecated in DBVersion == 22
     * @type {Array<string>}
     * @memberof PortainerEndpointGroup
     */
    'Tags'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: PortainerAccessPolicy; }}
     * @memberof PortainerEndpointGroup
     */
    'TeamAccessPolicies'?: { [key: string]: PortainerAccessPolicy; };
    /**
     * 
     * @type {{ [key: string]: PortainerAccessPolicy; }}
     * @memberof PortainerEndpointGroup
     */
    'UserAccessPolicies'?: { [key: string]: PortainerAccessPolicy; };
}
/**
 * 
 * @export
 * @interface PortainerEndpointPostInitMigrations
 */
export interface PortainerEndpointPostInitMigrations {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEndpointPostInitMigrations
     */
    'MigrateGPUs'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerEndpointPostInitMigrations
     */
    'MigrateIngresses'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerEndpointSecuritySettings
 */
export interface PortainerEndpointSecuritySettings {
    /**
     * Whether non-administrator should be able to use bind mounts when creating containers
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    'allowBindMountsForRegularUsers'?: boolean;
    /**
     * Whether non-administrator should be able to use container capabilities
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    'allowContainerCapabilitiesForRegularUsers'?: boolean;
    /**
     * Whether non-administrator should be able to use device mapping
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    'allowDeviceMappingForRegularUsers'?: boolean;
    /**
     * Whether non-administrator should be able to use the host pid
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    'allowHostNamespaceForRegularUsers'?: boolean;
    /**
     * Whether non-administrator should be able to use privileged mode when creating containers
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    'allowPrivilegedModeForRegularUsers'?: boolean;
    /**
     * Whether non-administrator should be able to manage stacks
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    'allowStackManagementForRegularUsers'?: boolean;
    /**
     * Whether non-administrator should be able to use sysctl settings
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    'allowSysctlSettingForRegularUsers'?: boolean;
    /**
     * Whether non-administrator should be able to browse volumes
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    'allowVolumeBrowserForRegularUsers'?: boolean;
    /**
     * Whether host management features are enabled
     * @type {boolean}
     * @memberof PortainerEndpointSecuritySettings
     */
    'enableHostManagementFeatures'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerEnvironmentEdgeSettings
 */
export interface PortainerEnvironmentEdgeSettings {
    /**
     * The command list interval for edge agent - used in edge async mode [seconds]
     * @type {number}
     * @memberof PortainerEnvironmentEdgeSettings
     */
    'CommandInterval'?: number;
    /**
     * The ping interval for edge agent - used in edge async mode [seconds]
     * @type {number}
     * @memberof PortainerEnvironmentEdgeSettings
     */
    'PingInterval'?: number;
    /**
     * The snapshot interval for edge agent - used in edge async mode [seconds]
     * @type {number}
     * @memberof PortainerEnvironmentEdgeSettings
     */
    'SnapshotInterval'?: number;
    /**
     * Whether the device has been started in edge async mode
     * @type {boolean}
     * @memberof PortainerEnvironmentEdgeSettings
     */
    'asyncMode'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerFDOConfiguration
 */
export interface PortainerFDOConfiguration {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerFDOConfiguration
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerFDOConfiguration
     */
    'ownerPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerFDOConfiguration
     */
    'ownerURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerFDOConfiguration
     */
    'ownerUsername'?: string;
}
/**
 * 
 * @export
 * @interface PortainerGitlabRegistryData
 */
export interface PortainerGitlabRegistryData {
    /**
     * 
     * @type {string}
     * @memberof PortainerGitlabRegistryData
     */
    'InstanceURL'?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerGitlabRegistryData
     */
    'ProjectId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerGitlabRegistryData
     */
    'ProjectPath'?: string;
}
/**
 * 
 * @export
 * @interface PortainerGlobalDeploymentOptions
 */
export interface PortainerGlobalDeploymentOptions {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerGlobalDeploymentOptions
     */
    'hideStacksFunctionality'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerHelmUserRepository
 */
export interface PortainerHelmUserRepository {
    /**
     * Membership Identifier
     * @type {number}
     * @memberof PortainerHelmUserRepository
     */
    'Id'?: number;
    /**
     * Helm repository URL
     * @type {string}
     * @memberof PortainerHelmUserRepository
     */
    'URL'?: string;
    /**
     * User identifier
     * @type {number}
     * @memberof PortainerHelmUserRepository
     */
    'UserId'?: number;
}
/**
 * 
 * @export
 * @interface PortainerInternalAuthSettings
 */
export interface PortainerInternalAuthSettings {
    /**
     * 
     * @type {number}
     * @memberof PortainerInternalAuthSettings
     */
    'requiredPasswordLength'?: number;
}
/**
 * 
 * @export
 * @interface PortainerK8sNamespaceInfo
 */
export interface PortainerK8sNamespaceInfo {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerK8sNamespaceInfo
     */
    'IsDefault'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerK8sNamespaceInfo
     */
    'IsSystem'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerK8sNodeLimits
 */
export interface PortainerK8sNodeLimits {
    /**
     * 
     * @type {number}
     * @memberof PortainerK8sNodeLimits
     */
    'CPU'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerK8sNodeLimits
     */
    'Memory'?: number;
}
/**
 * 
 * @export
 * @interface PortainerKubernetesConfiguration
 */
export interface PortainerKubernetesConfiguration {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesConfiguration
     */
    'AllowNoneIngressClass'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesConfiguration
     */
    'EnableResourceOverCommit'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesConfiguration
     */
    'IngressAvailabilityPerNamespace'?: boolean;
    /**
     * 
     * @type {Array<PortainerKubernetesIngressClassConfig>}
     * @memberof PortainerKubernetesConfiguration
     */
    'IngressClasses'?: Array<PortainerKubernetesIngressClassConfig>;
    /**
     * 
     * @type {number}
     * @memberof PortainerKubernetesConfiguration
     */
    'ResourceOverCommitPercentage'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesConfiguration
     */
    'RestrictDefaultNamespace'?: boolean;
    /**
     * 
     * @type {Array<PortainerKubernetesStorageClassConfig>}
     * @memberof PortainerKubernetesConfiguration
     */
    'StorageClasses'?: Array<PortainerKubernetesStorageClassConfig>;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesConfiguration
     */
    'UseLoadBalancer'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesConfiguration
     */
    'UseServerMetrics'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerKubernetesData
 */
export interface PortainerKubernetesData {
    /**
     * 
     * @type {PortainerKubernetesConfiguration}
     * @memberof PortainerKubernetesData
     */
    'Configuration'?: PortainerKubernetesConfiguration;
    /**
     * 
     * @type {PortainerKubernetesFlags}
     * @memberof PortainerKubernetesData
     */
    'Flags'?: PortainerKubernetesFlags;
    /**
     * 
     * @type {Array<PortainerKubernetesSnapshot>}
     * @memberof PortainerKubernetesData
     */
    'Snapshots'?: Array<PortainerKubernetesSnapshot>;
}
/**
 * 
 * @export
 * @interface PortainerKubernetesFlags
 */
export interface PortainerKubernetesFlags {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesFlags
     */
    'IsServerIngressClassDetected'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesFlags
     */
    'IsServerMetricsDetected'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesFlags
     */
    'IsServerStorageDetected'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerKubernetesIngressClassConfig
 */
export interface PortainerKubernetesIngressClassConfig {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesIngressClassConfig
     */
    'Blocked'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PortainerKubernetesIngressClassConfig
     */
    'BlockedNamespaces'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PortainerKubernetesIngressClassConfig
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerKubernetesIngressClassConfig
     */
    'Type'?: string;
}
/**
 * 
 * @export
 * @interface PortainerKubernetesSnapshot
 */
export interface PortainerKubernetesSnapshot {
    /**
     * 
     * @type {string}
     * @memberof PortainerKubernetesSnapshot
     */
    'KubernetesVersion'?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerKubernetesSnapshot
     */
    'NodeCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerKubernetesSnapshot
     */
    'Time'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerKubernetesSnapshot
     */
    'TotalCPU'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerKubernetesSnapshot
     */
    'TotalMemory'?: number;
}
/**
 * 
 * @export
 * @interface PortainerKubernetesStorageClassConfig
 */
export interface PortainerKubernetesStorageClassConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof PortainerKubernetesStorageClassConfig
     */
    'AccessModes'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerKubernetesStorageClassConfig
     */
    'AllowVolumeExpansion'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerKubernetesStorageClassConfig
     */
    'Name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerKubernetesStorageClassConfig
     */
    'Provisioner'?: string;
}
/**
 * 
 * @export
 * @interface PortainerLDAPGroupSearchSettings
 */
export interface PortainerLDAPGroupSearchSettings {
    /**
     * LDAP attribute which denotes the group membership
     * @type {string}
     * @memberof PortainerLDAPGroupSearchSettings
     */
    'GroupAttribute'?: string;
    /**
     * The distinguished name of the element from which the LDAP server will search for groups
     * @type {string}
     * @memberof PortainerLDAPGroupSearchSettings
     */
    'GroupBaseDN'?: string;
    /**
     * The LDAP search filter used to select group elements, optional
     * @type {string}
     * @memberof PortainerLDAPGroupSearchSettings
     */
    'GroupFilter'?: string;
}
/**
 * 
 * @export
 * @interface PortainerLDAPSearchSettings
 */
export interface PortainerLDAPSearchSettings {
    /**
     * The distinguished name of the element from which the LDAP server will search for users
     * @type {string}
     * @memberof PortainerLDAPSearchSettings
     */
    'BaseDN'?: string;
    /**
     * Optional LDAP search filter used to select user elements
     * @type {string}
     * @memberof PortainerLDAPSearchSettings
     */
    'Filter'?: string;
    /**
     * LDAP attribute which denotes the username
     * @type {string}
     * @memberof PortainerLDAPSearchSettings
     */
    'UserNameAttribute'?: string;
}
/**
 * 
 * @export
 * @interface PortainerLDAPSettings
 */
export interface PortainerLDAPSettings {
    /**
     * Enable this option if the server is configured for Anonymous access. When enabled, ReaderDN and Password will not be used
     * @type {boolean}
     * @memberof PortainerLDAPSettings
     */
    'AnonymousMode'?: boolean;
    /**
     * Automatically provision users and assign them to matching LDAP group names
     * @type {boolean}
     * @memberof PortainerLDAPSettings
     */
    'AutoCreateUsers'?: boolean;
    /**
     * 
     * @type {Array<PortainerLDAPGroupSearchSettings>}
     * @memberof PortainerLDAPSettings
     */
    'GroupSearchSettings'?: Array<PortainerLDAPGroupSearchSettings>;
    /**
     * Password of the account that will be used to search users
     * @type {string}
     * @memberof PortainerLDAPSettings
     */
    'Password'?: string;
    /**
     * Account that will be used to search for users
     * @type {string}
     * @memberof PortainerLDAPSettings
     */
    'ReaderDN'?: string;
    /**
     * 
     * @type {Array<PortainerLDAPSearchSettings>}
     * @memberof PortainerLDAPSettings
     */
    'SearchSettings'?: Array<PortainerLDAPSearchSettings>;
    /**
     * Whether LDAP connection should use StartTLS
     * @type {boolean}
     * @memberof PortainerLDAPSettings
     */
    'StartTLS'?: boolean;
    /**
     * 
     * @type {PortainerTLSConfiguration}
     * @memberof PortainerLDAPSettings
     */
    'TLSConfig'?: PortainerTLSConfiguration;
    /**
     * URL or IP address of the LDAP server
     * @type {string}
     * @memberof PortainerLDAPSettings
     */
    'URL'?: string;
}
/**
 * 
 * @export
 * @interface PortainerOAuthSettings
 */
export interface PortainerOAuthSettings {
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    'AccessTokenURI'?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerOAuthSettings
     */
    'AuthStyle'?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    'AuthorizationURI'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    'ClientID'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    'ClientSecret'?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerOAuthSettings
     */
    'DefaultTeamID'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof PortainerOAuthSettings
     */
    'KubeSecretKey'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    'LogoutURI'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerOAuthSettings
     */
    'OAuthAutoCreateUsers'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    'RedirectURI'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    'ResourceURI'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerOAuthSettings
     */
    'SSO'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    'Scopes'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOAuthSettings
     */
    'UserIdentifier'?: string;
}
/**
 * 
 * @export
 * @interface PortainerOpenAMTConfiguration
 */
export interface PortainerOpenAMTConfiguration {
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    'certFileContent'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    'certFileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    'certFilePassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    'domainName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerOpenAMTConfiguration
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    'mpsPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    'mpsServer'?: string;
    /**
     * retrieved from API
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    'mpsToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTConfiguration
     */
    'mpsUser'?: string;
}
/**
 * 
 * @export
 * @interface PortainerOpenAMTDeviceEnabledFeatures
 */
export interface PortainerOpenAMTDeviceEnabledFeatures {
    /**
     * 
     * @type {boolean}
     * @memberof PortainerOpenAMTDeviceEnabledFeatures
     */
    'IDER'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerOpenAMTDeviceEnabledFeatures
     */
    'KVM'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerOpenAMTDeviceEnabledFeatures
     */
    'SOL'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerOpenAMTDeviceEnabledFeatures
     */
    'redirection'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerOpenAMTDeviceEnabledFeatures
     */
    'userConsent'?: string;
}
/**
 * 
 * @export
 * @interface PortainerPair
 */
export interface PortainerPair {
    /**
     * 
     * @type {string}
     * @memberof PortainerPair
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerPair
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface PortainerQuayRegistryData
 */
export interface PortainerQuayRegistryData {
    /**
     * 
     * @type {string}
     * @memberof PortainerQuayRegistryData
     */
    'OrganisationName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerQuayRegistryData
     */
    'UseOrganisation'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerRegistry
 */
export interface PortainerRegistry {
    /**
     * Stores temporary access token
     * @type {string}
     * @memberof PortainerRegistry
     */
    'AccessToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerRegistry
     */
    'AccessTokenExpiry'?: number;
    /**
     * Is authentication against this registry enabled
     * @type {boolean}
     * @memberof PortainerRegistry
     */
    'Authentication'?: boolean;
    /**
     * Deprecated in DBVersion == 18
     * @type {Array<number>}
     * @memberof PortainerRegistry
     */
    'AuthorizedTeams'?: Array<number>;
    /**
     * Deprecated in DBVersion == 18
     * @type {Array<number>}
     * @memberof PortainerRegistry
     */
    'AuthorizedUsers'?: Array<number>;
    /**
     * Base URL, introduced for ProGet registry
     * @type {string}
     * @memberof PortainerRegistry
     */
    'BaseURL'?: string;
    /**
     * 
     * @type {PortainerEcrData}
     * @memberof PortainerRegistry
     */
    'Ecr'?: PortainerEcrData;
    /**
     * 
     * @type {PortainerGitlabRegistryData}
     * @memberof PortainerRegistry
     */
    'Gitlab'?: PortainerGitlabRegistryData;
    /**
     * Registry Identifier
     * @type {number}
     * @memberof PortainerRegistry
     */
    'Id'?: number;
    /**
     * 
     * @type {PortainerRegistryManagementConfiguration}
     * @memberof PortainerRegistry
     */
    'ManagementConfiguration'?: PortainerRegistryManagementConfiguration;
    /**
     * Registry Name
     * @type {string}
     * @memberof PortainerRegistry
     */
    'Name'?: string;
    /**
     * Password or SecretAccessKey used to authenticate against this registry
     * @type {string}
     * @memberof PortainerRegistry
     */
    'Password'?: string;
    /**
     * 
     * @type {PortainerQuayRegistryData}
     * @memberof PortainerRegistry
     */
    'Quay'?: PortainerQuayRegistryData;
    /**
     * 
     * @type {{ [key: string]: PortainerRegistryAccessPolicies; }}
     * @memberof PortainerRegistry
     */
    'RegistryAccesses'?: { [key: string]: PortainerRegistryAccessPolicies; };
    /**
     * 
     * @type {{ [key: string]: PortainerAccessPolicy; }}
     * @memberof PortainerRegistry
     */
    'TeamAccessPolicies'?: { [key: string]: PortainerAccessPolicy; };
    /**
     * Registry Type (1 - Quay, 2 - Azure, 3 - Custom, 4 - Gitlab, 5 - ProGet, 6 - DockerHub, 7 - ECR)
     * @type {number}
     * @memberof PortainerRegistry
     */
    'Type'?: number;
    /**
     * URL or IP address of the Docker registry
     * @type {string}
     * @memberof PortainerRegistry
     */
    'URL'?: string;
    /**
     * 
     * @type {{ [key: string]: PortainerAccessPolicy; }}
     * @memberof PortainerRegistry
     */
    'UserAccessPolicies'?: { [key: string]: PortainerAccessPolicy; };
    /**
     * Username or AccessKeyID used to authenticate against this registry
     * @type {string}
     * @memberof PortainerRegistry
     */
    'Username'?: string;
}
/**
 * 
 * @export
 * @interface PortainerRegistryAccessPolicies
 */
export interface PortainerRegistryAccessPolicies {
    /**
     * 
     * @type {Array<string>}
     * @memberof PortainerRegistryAccessPolicies
     */
    'Namespaces'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: PortainerAccessPolicy; }}
     * @memberof PortainerRegistryAccessPolicies
     */
    'TeamAccessPolicies'?: { [key: string]: PortainerAccessPolicy; };
    /**
     * 
     * @type {{ [key: string]: PortainerAccessPolicy; }}
     * @memberof PortainerRegistryAccessPolicies
     */
    'UserAccessPolicies'?: { [key: string]: PortainerAccessPolicy; };
}
/**
 * 
 * @export
 * @interface PortainerRegistryManagementConfiguration
 */
export interface PortainerRegistryManagementConfiguration {
    /**
     * 
     * @type {string}
     * @memberof PortainerRegistryManagementConfiguration
     */
    'AccessToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerRegistryManagementConfiguration
     */
    'AccessTokenExpiry'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerRegistryManagementConfiguration
     */
    'Authentication'?: boolean;
    /**
     * 
     * @type {PortainerEcrData}
     * @memberof PortainerRegistryManagementConfiguration
     */
    'Ecr'?: PortainerEcrData;
    /**
     * 
     * @type {string}
     * @memberof PortainerRegistryManagementConfiguration
     */
    'Password'?: string;
    /**
     * 
     * @type {PortainerTLSConfiguration}
     * @memberof PortainerRegistryManagementConfiguration
     */
    'TLSConfig'?: PortainerTLSConfiguration;
    /**
     * Registry Type (1 - Quay, 2 - Azure, 3 - Custom, 4 - Gitlab, 5 - ProGet, 6 - DockerHub, 7 - ECR)
     * @type {number}
     * @memberof PortainerRegistryManagementConfiguration
     */
    'Type'?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerRegistryManagementConfiguration
     */
    'Username'?: string;
}
/**
 * 
 * @export
 * @interface PortainerResourceControl
 */
export interface PortainerResourceControl {
    /**
     * 
     * @type {number}
     * @memberof PortainerResourceControl
     */
    'AccessLevel'?: number;
    /**
     * Permit access to resource only to admins
     * @type {boolean}
     * @memberof PortainerResourceControl
     */
    'AdministratorsOnly'?: boolean;
    /**
     * ResourceControl Identifier
     * @type {number}
     * @memberof PortainerResourceControl
     */
    'Id'?: number;
    /**
     * Deprecated fields Deprecated in DBVersion == 2
     * @type {number}
     * @memberof PortainerResourceControl
     */
    'OwnerId'?: number;
    /**
     * Permit access to the associated resource to any user
     * @type {boolean}
     * @memberof PortainerResourceControl
     */
    'Public'?: boolean;
    /**
     * Docker resource identifier on which access control will be applied.\\ In the case of a resource control applied to a stack, use the stack name as identifier
     * @type {string}
     * @memberof PortainerResourceControl
     */
    'ResourceId'?: string;
    /**
     * List of Docker resources that will inherit this access control
     * @type {Array<string>}
     * @memberof PortainerResourceControl
     */
    'SubResourceIds'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerResourceControl
     */
    'System'?: boolean;
    /**
     * 
     * @type {Array<PortainerTeamResourceAccess>}
     * @memberof PortainerResourceControl
     */
    'TeamAccesses'?: Array<PortainerTeamResourceAccess>;
    /**
     * Type of Docker resource. Valid values are: 1- container, 2 -service 3 - volume, 4 - secret, 5 - stack, 6 - config or 7 - custom template
     * @type {number}
     * @memberof PortainerResourceControl
     */
    'Type'?: number;
    /**
     * 
     * @type {Array<PortainerUserResourceAccess>}
     * @memberof PortainerResourceControl
     */
    'UserAccesses'?: Array<PortainerUserResourceAccess>;
}
/**
 * 
 * @export
 * @interface PortainerRole
 */
export interface PortainerRole {
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof PortainerRole
     */
    'Authorizations'?: { [key: string]: boolean; };
    /**
     * Role description
     * @type {string}
     * @memberof PortainerRole
     */
    'Description'?: string;
    /**
     * Role Identifier
     * @type {number}
     * @memberof PortainerRole
     */
    'Id'?: number;
    /**
     * Role name
     * @type {string}
     * @memberof PortainerRole
     */
    'Name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PortainerRole
     */
    'Priority'?: number;
}
/**
 * 
 * @export
 * @interface PortainerSSLSettings
 */
export interface PortainerSSLSettings {
    /**
     * 
     * @type {string}
     * @memberof PortainerSSLSettings
     */
    'certPath'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSSLSettings
     */
    'httpEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PortainerSSLSettings
     */
    'keyPath'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSSLSettings
     */
    'selfSigned'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerSettings
 */
export interface PortainerSettings {
    /**
     * Container environment parameter AGENT_SECRET
     * @type {string}
     * @memberof PortainerSettings
     */
    'AgentSecret'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'AllowBindMountsForRegularUsers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'AllowContainerCapabilitiesForRegularUsers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'AllowDeviceMappingForRegularUsers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'AllowHostNamespaceForRegularUsers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'AllowPrivilegedModeForRegularUsers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'AllowStackManagementForRegularUsers'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'AllowVolumeBrowserForRegularUsers'?: boolean;
    /**
     * Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth
     * @type {number}
     * @memberof PortainerSettings
     */
    'AuthenticationMethod'?: number;
    /**
     * A list of label name & value that will be used to hide containers when querying containers
     * @type {Array<PortainerPair>}
     * @memberof PortainerSettings
     */
    'BlackListedLabels'?: Array<PortainerPair>;
    /**
     * Deprecated fields
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'DisplayDonationHeader'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'DisplayExternalContributors'?: boolean;
    /**
     * The default check in interval for edge agent (in seconds)
     * @type {number}
     * @memberof PortainerSettings
     */
    'EdgeAgentCheckinInterval'?: number;
    /**
     * EdgePortainerURL is the URL that is exposed to edge agents
     * @type {string}
     * @memberof PortainerSettings
     */
    'EdgePortainerUrl'?: string;
    /**
     * Whether edge compute features are enabled
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'EnableEdgeComputeFeatures'?: boolean;
    /**
     * Deprecated fields v26
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'EnableHostManagementFeatures'?: boolean;
    /**
     * Whether telemetry is enabled
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'EnableTelemetry'?: boolean;
    /**
     * EnforceEdgeID makes Portainer store the Edge ID instead of accepting anyone
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'EnforceEdgeID'?: boolean;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof PortainerSettings
     */
    'FeatureFlagSettings'?: { [key: string]: boolean; };
    /**
     * 
     * @type {PortainerGlobalDeploymentOptions}
     * @memberof PortainerSettings
     */
    'GlobalDeploymentOptions'?: PortainerGlobalDeploymentOptions;
    /**
     * Helm repository URL, defaults to \"https://charts.bitnami.com/bitnami\"
     * @type {string}
     * @memberof PortainerSettings
     */
    'HelmRepositoryURL'?: string;
    /**
     * 
     * @type {PortainerInternalAuthSettings}
     * @memberof PortainerSettings
     */
    'InternalAuthSettings'?: PortainerInternalAuthSettings;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'IsDockerDesktopExtension'?: boolean;
    /**
     * The expiry of a Kubeconfig
     * @type {string}
     * @memberof PortainerSettings
     */
    'KubeconfigExpiry'?: string;
    /**
     * KubectlImage, defaults to portainer/kubectl-shell
     * @type {string}
     * @memberof PortainerSettings
     */
    'KubectlShellImage'?: string;
    /**
     * 
     * @type {PortainerLDAPSettings}
     * @memberof PortainerSettings
     */
    'LDAPSettings'?: PortainerLDAPSettings;
    /**
     * URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string
     * @type {string}
     * @memberof PortainerSettings
     */
    'LogoURL'?: string;
    /**
     * 
     * @type {PortainerOAuthSettings}
     * @memberof PortainerSettings
     */
    'OAuthSettings'?: PortainerOAuthSettings;
    /**
     * Show the Kompose build option (discontinued in 2.18)
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'ShowKomposeBuildOption'?: boolean;
    /**
     * The interval in which environment(endpoint) snapshots are created
     * @type {string}
     * @memberof PortainerSettings
     */
    'SnapshotInterval'?: string;
    /**
     * URL to the templates that will be displayed in the UI when navigating to App Templates
     * @type {string}
     * @memberof PortainerSettings
     */
    'TemplatesURL'?: string;
    /**
     * TrustOnFirstConnect makes Portainer accepting edge agent connection by default
     * @type {boolean}
     * @memberof PortainerSettings
     */
    'TrustOnFirstConnect'?: boolean;
    /**
     * The duration of a user session
     * @type {string}
     * @memberof PortainerSettings
     */
    'UserSessionTimeout'?: string;
    /**
     * 
     * @type {PortainerSettingsEdge}
     * @memberof PortainerSettings
     */
    'edge'?: PortainerSettingsEdge;
    /**
     * 
     * @type {PortainerFDOConfiguration}
     * @memberof PortainerSettings
     */
    'fdoConfiguration'?: PortainerFDOConfiguration;
    /**
     * 
     * @type {PortainerOpenAMTConfiguration}
     * @memberof PortainerSettings
     */
    'openAMTConfiguration'?: PortainerOpenAMTConfiguration;
}
/**
 * 
 * @export
 * @interface PortainerSettingsEdge
 */
export interface PortainerSettingsEdge {
    /**
     * The command list interval for edge agent - used in edge async mode (in seconds)
     * @type {number}
     * @memberof PortainerSettingsEdge
     */
    'CommandInterval'?: number;
    /**
     * The ping interval for edge agent - used in edge async mode (in seconds)
     * @type {number}
     * @memberof PortainerSettingsEdge
     */
    'PingInterval'?: number;
    /**
     * The snapshot interval for edge agent - used in edge async mode (in seconds)
     * @type {number}
     * @memberof PortainerSettingsEdge
     */
    'SnapshotInterval'?: number;
    /**
     * Deprecated 2.18
     * @type {boolean}
     * @memberof PortainerSettingsEdge
     */
    'asyncMode'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerStack
 */
export interface PortainerStack {
    /**
     * Only applies when deploying stack with multiple files
     * @type {Array<string>}
     * @memberof PortainerStack
     */
    'AdditionalFiles'?: Array<string>;
    /**
     * 
     * @type {PortainerAutoUpdateSettings}
     * @memberof PortainerStack
     */
    'AutoUpdate'?: PortainerAutoUpdateSettings;
    /**
     * Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment
     * @type {number}
     * @memberof PortainerStack
     */
    'EndpointId'?: number;
    /**
     * Path to the Stack file
     * @type {string}
     * @memberof PortainerStack
     */
    'EntryPoint'?: string;
    /**
     * A list of environment(endpoint) variables used during stack deployment
     * @type {Array<PortainerPair>}
     * @memberof PortainerStack
     */
    'Env'?: Array<PortainerPair>;
    /**
     * Stack Identifier
     * @type {number}
     * @memberof PortainerStack
     */
    'Id'?: number;
    /**
     * Stack name
     * @type {string}
     * @memberof PortainerStack
     */
    'Name'?: string;
    /**
     * 
     * @type {PortainerStackOption}
     * @memberof PortainerStack
     */
    'Option'?: PortainerStackOption;
    /**
     * 
     * @type {PortainerResourceControl}
     * @memberof PortainerStack
     */
    'ResourceControl'?: PortainerResourceControl;
    /**
     * Stack status (1 - active, 2 - inactive)
     * @type {number}
     * @memberof PortainerStack
     */
    'Status'?: number;
    /**
     * Cluster identifier of the Swarm cluster where the stack is deployed
     * @type {string}
     * @memberof PortainerStack
     */
    'SwarmId'?: string;
    /**
     * Stack type. 1 for a Swarm stack, 2 for a Compose stack
     * @type {number}
     * @memberof PortainerStack
     */
    'Type'?: number;
    /**
     * The username which created this stack
     * @type {string}
     * @memberof PortainerStack
     */
    'createdBy'?: string;
    /**
     * The date in unix time when stack was created
     * @type {number}
     * @memberof PortainerStack
     */
    'creationDate'?: number;
    /**
     * Whether the stack is from a app template
     * @type {boolean}
     * @memberof PortainerStack
     */
    'fromAppTemplate'?: boolean;
    /**
     * 
     * @type {GittypesRepoConfig}
     * @memberof PortainerStack
     */
    'gitConfig'?: GittypesRepoConfig;
    /**
     * IsComposeFormat indicates if the Kubernetes stack is created from a Docker Compose file
     * @type {boolean}
     * @memberof PortainerStack
     */
    'isComposeFormat'?: boolean;
    /**
     * Kubernetes namespace if stack is a kube application
     * @type {string}
     * @memberof PortainerStack
     */
    'namespace'?: string;
    /**
     * Path on disk to the repository hosting the Stack file
     * @type {string}
     * @memberof PortainerStack
     */
    'projectPath'?: string;
    /**
     * The date in unix time when stack was last updated
     * @type {number}
     * @memberof PortainerStack
     */
    'updateDate'?: number;
    /**
     * The username which last updated this stack
     * @type {string}
     * @memberof PortainerStack
     */
    'updatedBy'?: string;
}
/**
 * 
 * @export
 * @interface PortainerStackDeploymentInfo
 */
export interface PortainerStackDeploymentInfo {
    /**
     * ConfigHash is the commit hash of the git repository used for deploying the stack
     * @type {string}
     * @memberof PortainerStackDeploymentInfo
     */
    'ConfigHash'?: string;
    /**
     * FileVersion is the version of the stack file, used to detect changes
     * @type {number}
     * @memberof PortainerStackDeploymentInfo
     */
    'FileVersion'?: number;
    /**
     * Version is the version of the stack and also is the deployed version in edge agent
     * @type {number}
     * @memberof PortainerStackDeploymentInfo
     */
    'Version'?: number;
}
/**
 * 
 * @export
 * @interface PortainerStackOption
 */
export interface PortainerStackOption {
    /**
     * Prune services that are no longer referenced
     * @type {boolean}
     * @memberof PortainerStackOption
     */
    'prune'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerTLSConfiguration
 */
export interface PortainerTLSConfiguration {
    /**
     * Use TLS
     * @type {boolean}
     * @memberof PortainerTLSConfiguration
     */
    'TLS'?: boolean;
    /**
     * Path to the TLS CA certificate file
     * @type {string}
     * @memberof PortainerTLSConfiguration
     */
    'TLSCACert'?: string;
    /**
     * Path to the TLS client certificate file
     * @type {string}
     * @memberof PortainerTLSConfiguration
     */
    'TLSCert'?: string;
    /**
     * Path to the TLS client key file
     * @type {string}
     * @memberof PortainerTLSConfiguration
     */
    'TLSKey'?: string;
    /**
     * Skip the verification of the server TLS certificate
     * @type {boolean}
     * @memberof PortainerTLSConfiguration
     */
    'TLSSkipVerify'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerTag
 */
export interface PortainerTag {
    /**
     * A set of environment(endpoint) group ids that have this tag
     * @type {{ [key: string]: boolean; }}
     * @memberof PortainerTag
     */
    'EndpointGroups'?: { [key: string]: boolean; };
    /**
     * A set of environment(endpoint) ids that have this tag
     * @type {{ [key: string]: boolean; }}
     * @memberof PortainerTag
     */
    'Endpoints'?: { [key: string]: boolean; };
    /**
     * Tag name
     * @type {string}
     * @memberof PortainerTag
     */
    'Name'?: string;
    /**
     * Tag identifier
     * @type {number}
     * @memberof PortainerTag
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface PortainerTeam
 */
export interface PortainerTeam {
    /**
     * Team Identifier
     * @type {number}
     * @memberof PortainerTeam
     */
    'Id'?: number;
    /**
     * Team name
     * @type {string}
     * @memberof PortainerTeam
     */
    'Name'?: string;
}
/**
 * 
 * @export
 * @interface PortainerTeamMembership
 */
export interface PortainerTeamMembership {
    /**
     * Membership Identifier
     * @type {number}
     * @memberof PortainerTeamMembership
     */
    'Id'?: number;
    /**
     * Team role (1 for team leader and 2 for team member)
     * @type {number}
     * @memberof PortainerTeamMembership
     */
    'Role'?: number;
    /**
     * Team identifier
     * @type {number}
     * @memberof PortainerTeamMembership
     */
    'TeamID'?: number;
    /**
     * User identifier
     * @type {number}
     * @memberof PortainerTeamMembership
     */
    'UserID'?: number;
}
/**
 * 
 * @export
 * @interface PortainerTeamResourceAccess
 */
export interface PortainerTeamResourceAccess {
    /**
     * 
     * @type {number}
     * @memberof PortainerTeamResourceAccess
     */
    'AccessLevel'?: number;
    /**
     * 
     * @type {number}
     * @memberof PortainerTeamResourceAccess
     */
    'TeamId'?: number;
}
/**
 * 
 * @export
 * @interface PortainerTemplate
 */
export interface PortainerTemplate {
    /**
     * Whether the template should be available to administrators only
     * @type {boolean}
     * @memberof PortainerTemplate
     */
    'administrator_only'?: boolean;
    /**
     * A list of categories associated to the template
     * @type {Array<string>}
     * @memberof PortainerTemplate
     */
    'categories'?: Array<string>;
    /**
     * The command that will be executed in a container template
     * @type {string}
     * @memberof PortainerTemplate
     */
    'command'?: string;
    /**
     * Description of the template
     * @type {string}
     * @memberof PortainerTemplate
     */
    'description'?: string;
    /**
     * A list of environment(endpoint) variables used during the template deployment
     * @type {Array<PortainerTemplateEnv>}
     * @memberof PortainerTemplate
     */
    'env'?: Array<PortainerTemplateEnv>;
    /**
     * Container hostname
     * @type {string}
     * @memberof PortainerTemplate
     */
    'hostname'?: string;
    /**
     * Mandatory container/stack fields Template Identifier
     * @type {number}
     * @memberof PortainerTemplate
     */
    'id'?: number;
    /**
     * Mandatory container fields Image associated to a container template. Mandatory for a container template
     * @type {string}
     * @memberof PortainerTemplate
     */
    'image'?: string;
    /**
     * Whether the container should be started in interactive mode (-i -t equivalent on the CLI)
     * @type {boolean}
     * @memberof PortainerTemplate
     */
    'interactive'?: boolean;
    /**
     * Container labels
     * @type {Array<PortainerPair>}
     * @memberof PortainerTemplate
     */
    'labels'?: Array<PortainerPair>;
    /**
     * URL of the template\'s logo
     * @type {string}
     * @memberof PortainerTemplate
     */
    'logo'?: string;
    /**
     * Optional stack/container fields Default name for the stack/container to be used on deployment
     * @type {string}
     * @memberof PortainerTemplate
     */
    'name'?: string;
    /**
     * Name of a network that will be used on container deployment if it exists inside the environment(endpoint)
     * @type {string}
     * @memberof PortainerTemplate
     */
    'network'?: string;
    /**
     * A note that will be displayed in the UI. Supports HTML content
     * @type {string}
     * @memberof PortainerTemplate
     */
    'note'?: string;
    /**
     * Platform associated to the template. Valid values are: \'linux\', \'windows\' or leave empty for multi-platform
     * @type {string}
     * @memberof PortainerTemplate
     */
    'platform'?: string;
    /**
     * A list of ports exposed by the container
     * @type {Array<string>}
     * @memberof PortainerTemplate
     */
    'ports'?: Array<string>;
    /**
     * Whether the container should be started in privileged mode
     * @type {boolean}
     * @memberof PortainerTemplate
     */
    'privileged'?: boolean;
    /**
     * Optional container fields The URL of a registry associated to the image for a container template
     * @type {string}
     * @memberof PortainerTemplate
     */
    'registry'?: string;
    /**
     * 
     * @type {PortainerTemplateRepository}
     * @memberof PortainerTemplate
     */
    'repository'?: PortainerTemplateRepository;
    /**
     * Container restart policy
     * @type {string}
     * @memberof PortainerTemplate
     */
    'restart_policy'?: string;
    /**
     * Mandatory Edge stack fields Stack file used for this template
     * @type {string}
     * @memberof PortainerTemplate
     */
    'stackFile'?: string;
    /**
     * Title of the template
     * @type {string}
     * @memberof PortainerTemplate
     */
    'title'?: string;
    /**
     * Template type. Valid values are: 1 (container), 2 (Swarm stack), 3 (Compose stack), 4 (Compose edge stack)
     * @type {number}
     * @memberof PortainerTemplate
     */
    'type'?: number;
    /**
     * A list of volumes used during the container template deployment
     * @type {Array<PortainerTemplateVolume>}
     * @memberof PortainerTemplate
     */
    'volumes'?: Array<PortainerTemplateVolume>;
}
/**
 * 
 * @export
 * @interface PortainerTemplateEnv
 */
export interface PortainerTemplateEnv {
    /**
     * Default value that will be set for the variable
     * @type {string}
     * @memberof PortainerTemplateEnv
     */
    'default'?: string;
    /**
     * Content of the tooltip that will be generated in the UI
     * @type {string}
     * @memberof PortainerTemplateEnv
     */
    'description'?: string;
    /**
     * Text for the label that will be generated in the UI
     * @type {string}
     * @memberof PortainerTemplateEnv
     */
    'label'?: string;
    /**
     * name of the environment(endpoint) variable
     * @type {string}
     * @memberof PortainerTemplateEnv
     */
    'name'?: string;
    /**
     * If set to true, will not generate any input for this variable in the UI
     * @type {boolean}
     * @memberof PortainerTemplateEnv
     */
    'preset'?: boolean;
    /**
     * A list of name/value that will be used to generate a dropdown in the UI
     * @type {Array<PortainerTemplateEnvSelect>}
     * @memberof PortainerTemplateEnv
     */
    'select'?: Array<PortainerTemplateEnvSelect>;
}
/**
 * 
 * @export
 * @interface PortainerTemplateEnvSelect
 */
export interface PortainerTemplateEnvSelect {
    /**
     * Will set this choice as the default choice
     * @type {boolean}
     * @memberof PortainerTemplateEnvSelect
     */
    'default'?: boolean;
    /**
     * Some text that will displayed as a choice
     * @type {string}
     * @memberof PortainerTemplateEnvSelect
     */
    'text'?: string;
    /**
     * A value that will be associated to the choice
     * @type {string}
     * @memberof PortainerTemplateEnvSelect
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface PortainerTemplateRepository
 */
export interface PortainerTemplateRepository {
    /**
     * Path to the stack file inside the git repository
     * @type {string}
     * @memberof PortainerTemplateRepository
     */
    'stackfile'?: string;
    /**
     * URL of a git repository used to deploy a stack template. Mandatory for a Swarm/Compose stack template
     * @type {string}
     * @memberof PortainerTemplateRepository
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface PortainerTemplateVolume
 */
export interface PortainerTemplateVolume {
    /**
     * Path on the host
     * @type {string}
     * @memberof PortainerTemplateVolume
     */
    'bind'?: string;
    /**
     * Path inside the container
     * @type {string}
     * @memberof PortainerTemplateVolume
     */
    'container'?: string;
    /**
     * Whether the volume used should be readonly
     * @type {boolean}
     * @memberof PortainerTemplateVolume
     */
    'readonly'?: boolean;
}
/**
 * 
 * @export
 * @interface PortainerUser
 */
export interface PortainerUser {
    /**
     * User Identifier
     * @type {number}
     * @memberof PortainerUser
     */
    'Id'?: number;
    /**
     * User role (1 for administrator account and 2 for regular account)
     * @type {number}
     * @memberof PortainerUser
     */
    'Role'?: number;
    /**
     * 
     * @type {PortainerUserThemeSettings}
     * @memberof PortainerUser
     */
    'ThemeSettings'?: PortainerUserThemeSettings;
    /**
     * 
     * @type {number}
     * @memberof PortainerUser
     */
    'TokenIssueAt'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PortainerUser
     */
    'UseCache'?: boolean;
    /**
     * Deprecated
     * @type {string}
     * @memberof PortainerUser
     */
    'UserTheme'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerUser
     */
    'Username'?: string;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: boolean; }; }}
     * @memberof PortainerUser
     */
    'endpointAuthorizations'?: { [key: string]: { [key: string]: boolean; }; };
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof PortainerUser
     */
    'portainerAuthorizations'?: { [key: string]: boolean; };
}
/**
 * 
 * @export
 * @interface PortainerUserResourceAccess
 */
export interface PortainerUserResourceAccess {
    /**
     * 
     * @type {number}
     * @memberof PortainerUserResourceAccess
     */
    'AccessLevel'?: number;
    /**
     * User identifier who created this template
     * @type {number}
     * @memberof PortainerUserResourceAccess
     */
    'UserId'?: number;
}
/**
 * 
 * @export
 * @interface PortainerUserThemeSettings
 */
export interface PortainerUserThemeSettings {
    /**
     * Color represents the color theme of the UI
     * @type {string}
     * @memberof PortainerUserThemeSettings
     */
    'color'?: PortainerUserThemeSettingsColorEnum;
}

export const PortainerUserThemeSettingsColorEnum = {
    Dark: 'dark',
    Light: 'light',
    Highcontrast: 'highcontrast',
    Auto: 'auto'
} as const;

export type PortainerUserThemeSettingsColorEnum = typeof PortainerUserThemeSettingsColorEnum[keyof typeof PortainerUserThemeSettingsColorEnum];

/**
 * 
 * @export
 * @interface PortainerWebhook
 */
export interface PortainerWebhook {
    /**
     * Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment
     * @type {number}
     * @memberof PortainerWebhook
     */
    'EndpointId'?: number;
    /**
     * Webhook Identifier
     * @type {number}
     * @memberof PortainerWebhook
     */
    'Id'?: number;
    /**
     * Registry Identifier
     * @type {number}
     * @memberof PortainerWebhook
     */
    'RegistryId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PortainerWebhook
     */
    'ResourceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PortainerWebhook
     */
    'Token'?: string;
    /**
     * Type of webhook (1 - service)
     * @type {number}
     * @memberof PortainerWebhook
     */
    'Type'?: number;
}
/**
 * 
 * @export
 * @interface RegistriesRegistryConfigurePayload
 */
export interface RegistriesRegistryConfigurePayload {
    /**
     * Is authentication against this registry enabled
     * @type {boolean}
     * @memberof RegistriesRegistryConfigurePayload
     */
    'authentication': boolean;
    /**
     * Password used to authenticate against this registry. required when Authentication is true
     * @type {string}
     * @memberof RegistriesRegistryConfigurePayload
     */
    'password'?: string;
    /**
     * ECR region
     * @type {string}
     * @memberof RegistriesRegistryConfigurePayload
     */
    'region'?: string;
    /**
     * Use TLS
     * @type {boolean}
     * @memberof RegistriesRegistryConfigurePayload
     */
    'tls'?: boolean;
    /**
     * The TLS CA certificate file
     * @type {Array<number>}
     * @memberof RegistriesRegistryConfigurePayload
     */
    'tlscacertFile'?: Array<number>;
    /**
     * The TLS client certificate file
     * @type {Array<number>}
     * @memberof RegistriesRegistryConfigurePayload
     */
    'tlscertFile'?: Array<number>;
    /**
     * The TLS client key file
     * @type {Array<number>}
     * @memberof RegistriesRegistryConfigurePayload
     */
    'tlskeyFile'?: Array<number>;
    /**
     * Skip the verification of the server TLS certificate
     * @type {boolean}
     * @memberof RegistriesRegistryConfigurePayload
     */
    'tlsskipVerify'?: boolean;
    /**
     * Username used to authenticate against this registry. Required when Authentication is true
     * @type {string}
     * @memberof RegistriesRegistryConfigurePayload
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface RegistriesRegistryCreatePayload
 */
export interface RegistriesRegistryCreatePayload {
    /**
     * Is authentication against this registry enabled
     * @type {boolean}
     * @memberof RegistriesRegistryCreatePayload
     */
    'authentication': boolean;
    /**
     * BaseURL required for ProGet registry
     * @type {string}
     * @memberof RegistriesRegistryCreatePayload
     */
    'baseURL'?: string;
    /**
     * 
     * @type {PortainerEcrData}
     * @memberof RegistriesRegistryCreatePayload
     */
    'ecr'?: PortainerEcrData;
    /**
     * 
     * @type {PortainerGitlabRegistryData}
     * @memberof RegistriesRegistryCreatePayload
     */
    'gitlab'?: PortainerGitlabRegistryData;
    /**
     * Name that will be used to identify this registry
     * @type {string}
     * @memberof RegistriesRegistryCreatePayload
     */
    'name': string;
    /**
     * Password used to authenticate against this registry. required when Authentication is true
     * @type {string}
     * @memberof RegistriesRegistryCreatePayload
     */
    'password'?: string;
    /**
     * 
     * @type {PortainerQuayRegistryData}
     * @memberof RegistriesRegistryCreatePayload
     */
    'quay'?: PortainerQuayRegistryData;
    /**
     * Registry Type. Valid values are:  1 (Quay.io),  2 (Azure container registry),  3 (custom registry),  4 (Gitlab registry),  5 (ProGet registry),  6 (DockerHub)  7 (ECR)
     * @type {number}
     * @memberof RegistriesRegistryCreatePayload
     */
    'type': number;
    /**
     * URL or IP address of the Docker registry
     * @type {string}
     * @memberof RegistriesRegistryCreatePayload
     */
    'url': string;
    /**
     * Username used to authenticate against this registry. Required when Authentication is true
     * @type {string}
     * @memberof RegistriesRegistryCreatePayload
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface RegistriesRegistryUpdatePayload
 */
export interface RegistriesRegistryUpdatePayload {
    /**
     * Is authentication against this registry enabled
     * @type {boolean}
     * @memberof RegistriesRegistryUpdatePayload
     */
    'authentication': boolean;
    /**
     * BaseURL is used for quay registry
     * @type {string}
     * @memberof RegistriesRegistryUpdatePayload
     */
    'baseURL'?: string;
    /**
     * 
     * @type {PortainerEcrData}
     * @memberof RegistriesRegistryUpdatePayload
     */
    'ecr'?: PortainerEcrData;
    /**
     * Name that will be used to identify this registry
     * @type {string}
     * @memberof RegistriesRegistryUpdatePayload
     */
    'name': string;
    /**
     * Password used to authenticate against this registry. required when Authentication is true
     * @type {string}
     * @memberof RegistriesRegistryUpdatePayload
     */
    'password'?: string;
    /**
     * 
     * @type {PortainerQuayRegistryData}
     * @memberof RegistriesRegistryUpdatePayload
     */
    'quay'?: PortainerQuayRegistryData;
    /**
     * 
     * @type {{ [key: string]: PortainerRegistryAccessPolicies; }}
     * @memberof RegistriesRegistryUpdatePayload
     */
    'registryAccesses'?: { [key: string]: PortainerRegistryAccessPolicies; };
    /**
     * URL or IP address of the Docker registry
     * @type {string}
     * @memberof RegistriesRegistryUpdatePayload
     */
    'url': string;
    /**
     * Username used to authenticate against this registry. Required when Authentication is true
     * @type {string}
     * @memberof RegistriesRegistryUpdatePayload
     */
    'username'?: string;
}
/**
 * 
 * @export
 * @interface ReleaseChart
 */
export interface ReleaseChart {
    /**
     * Files are miscellaneous files in a chart archive, e.g. README, LICENSE, etc.
     * @type {Array<ReleaseFile>}
     * @memberof ReleaseChart
     */
    'files'?: Array<ReleaseFile>;
    /**
     * 
     * @type {ReleaseLock}
     * @memberof ReleaseChart
     */
    'lock'?: ReleaseLock;
    /**
     * 
     * @type {ReleaseMetadata}
     * @memberof ReleaseChart
     */
    'metadata'?: ReleaseMetadata;
    /**
     * Schema is an optional JSON schema for imposing structure on Values
     * @type {Array<number>}
     * @memberof ReleaseChart
     */
    'schema'?: Array<number>;
    /**
     * Templates for this chart.
     * @type {Array<ReleaseFile>}
     * @memberof ReleaseChart
     */
    'templates'?: Array<ReleaseFile>;
    /**
     * Values are default config for this chart.
     * @type {object}
     * @memberof ReleaseChart
     */
    'values'?: object;
}
/**
 * 
 * @export
 * @interface ReleaseDependency
 */
export interface ReleaseDependency {
    /**
     * Alias usable alias to be used for the chart
     * @type {string}
     * @memberof ReleaseDependency
     */
    'alias'?: string;
    /**
     * A yaml path that resolves to a boolean, used for enabling/disabling charts (e.g. subchart1.enabled )
     * @type {string}
     * @memberof ReleaseDependency
     */
    'condition'?: string;
    /**
     * Enabled bool determines if chart should be loaded
     * @type {boolean}
     * @memberof ReleaseDependency
     */
    'enabled'?: boolean;
    /**
     * ImportValues holds the mapping of source values to parent key to be imported. Each item can be a string or pair of child/parent sublist items.
     * @type {Array<object>}
     * @memberof ReleaseDependency
     */
    'import-values'?: Array<object>;
    /**
     * Name is the name of the dependency.  This must mach the name in the dependency\'s Chart.yaml.
     * @type {string}
     * @memberof ReleaseDependency
     */
    'name'?: string;
    /**
     * The URL to the repository.  Appending `index.yaml` to this string should result in a URL that can be used to fetch the repository index.
     * @type {string}
     * @memberof ReleaseDependency
     */
    'repository'?: string;
    /**
     * Tags can be used to group charts for enabling/disabling together
     * @type {Array<string>}
     * @memberof ReleaseDependency
     */
    'tags'?: Array<string>;
    /**
     * Version is the version (range) of this chart.  A lock file will always produce a single version, while a dependency may contain a semantic version range.
     * @type {string}
     * @memberof ReleaseDependency
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ReleaseFile
 */
export interface ReleaseFile {
    /**
     * Data is the template as byte data.
     * @type {Array<number>}
     * @memberof ReleaseFile
     */
    'data'?: Array<number>;
    /**
     * Name is the path-like name of the template.
     * @type {string}
     * @memberof ReleaseFile
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ReleaseHook
 */
export interface ReleaseHook {
    /**
     * DeletePolicies are the policies that indicate when to delete the hook
     * @type {Array<string>}
     * @memberof ReleaseHook
     */
    'delete_policies'?: Array<string>;
    /**
     * Events are the events that this hook fires on.
     * @type {Array<string>}
     * @memberof ReleaseHook
     */
    'events'?: Array<string>;
    /**
     * Kind is the Kubernetes kind.
     * @type {string}
     * @memberof ReleaseHook
     */
    'kind'?: string;
    /**
     * 
     * @type {ReleaseHookExecution}
     * @memberof ReleaseHook
     */
    'last_run'?: ReleaseHookExecution;
    /**
     * Manifest is the manifest contents.
     * @type {string}
     * @memberof ReleaseHook
     */
    'manifest'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseHook
     */
    'name'?: string;
    /**
     * Path is the chart-relative path to the template.
     * @type {string}
     * @memberof ReleaseHook
     */
    'path'?: string;
    /**
     * Weight indicates the sort order for execution among similar Hook type
     * @type {number}
     * @memberof ReleaseHook
     */
    'weight'?: number;
}
/**
 * 
 * @export
 * @interface ReleaseHookExecution
 */
export interface ReleaseHookExecution {
    /**
     * CompletedAt indicates the date/time this hook was completed.
     * @type {string}
     * @memberof ReleaseHookExecution
     */
    'completed_at'?: string;
    /**
     * Phase indicates whether the hook completed successfully
     * @type {string}
     * @memberof ReleaseHookExecution
     */
    'phase'?: string;
    /**
     * StartedAt indicates the date/time this hook was started
     * @type {string}
     * @memberof ReleaseHookExecution
     */
    'started_at'?: string;
}
/**
 * 
 * @export
 * @interface ReleaseLock
 */
export interface ReleaseLock {
    /**
     * Dependencies is the list of dependencies that this lock file has locked.
     * @type {Array<ReleaseDependency>}
     * @memberof ReleaseLock
     */
    'dependencies'?: Array<ReleaseDependency>;
    /**
     * Digest is a hash of the dependencies in Chart.yaml.
     * @type {string}
     * @memberof ReleaseLock
     */
    'digest'?: string;
    /**
     * Generated is the date the lock file was last generated.
     * @type {string}
     * @memberof ReleaseLock
     */
    'generated'?: string;
}
/**
 * 
 * @export
 * @interface ReleaseMaintainer
 */
export interface ReleaseMaintainer {
    /**
     * Email is an optional email address to contact the named maintainer
     * @type {string}
     * @memberof ReleaseMaintainer
     */
    'email'?: string;
    /**
     * Name is a user name or organization name
     * @type {string}
     * @memberof ReleaseMaintainer
     */
    'name'?: string;
    /**
     * URL is an optional URL to an address for the named maintainer
     * @type {string}
     * @memberof ReleaseMaintainer
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ReleaseMetadata
 */
export interface ReleaseMetadata {
    /**
     * Annotations are additional mappings uninterpreted by Helm, made available for inspection by other applications.
     * @type {{ [key: string]: string; }}
     * @memberof ReleaseMetadata
     */
    'annotations'?: { [key: string]: string; };
    /**
     * The API Version of this chart. Required.
     * @type {string}
     * @memberof ReleaseMetadata
     */
    'apiVersion'?: string;
    /**
     * The version of the application enclosed inside of this chart.
     * @type {string}
     * @memberof ReleaseMetadata
     */
    'appVersion'?: string;
    /**
     * The condition to check to enable chart
     * @type {string}
     * @memberof ReleaseMetadata
     */
    'condition'?: string;
    /**
     * Dependencies are a list of dependencies for a chart.
     * @type {Array<ReleaseDependency>}
     * @memberof ReleaseMetadata
     */
    'dependencies'?: Array<ReleaseDependency>;
    /**
     * Whether or not this chart is deprecated
     * @type {boolean}
     * @memberof ReleaseMetadata
     */
    'deprecated'?: boolean;
    /**
     * A one-sentence description of the chart
     * @type {string}
     * @memberof ReleaseMetadata
     */
    'description'?: string;
    /**
     * The URL to a relevant project page, git repo, or contact person
     * @type {string}
     * @memberof ReleaseMetadata
     */
    'home'?: string;
    /**
     * The URL to an icon file.
     * @type {string}
     * @memberof ReleaseMetadata
     */
    'icon'?: string;
    /**
     * A list of string keywords
     * @type {Array<string>}
     * @memberof ReleaseMetadata
     */
    'keywords'?: Array<string>;
    /**
     * KubeVersion is a SemVer constraint specifying the version of Kubernetes required.
     * @type {string}
     * @memberof ReleaseMetadata
     */
    'kubeVersion'?: string;
    /**
     * A list of name and URL/email address combinations for the maintainer(s)
     * @type {Array<ReleaseMaintainer>}
     * @memberof ReleaseMetadata
     */
    'maintainers'?: Array<ReleaseMaintainer>;
    /**
     * The name of the chart. Required.
     * @type {string}
     * @memberof ReleaseMetadata
     */
    'name'?: string;
    /**
     * Source is the URL to the source code of this chart
     * @type {Array<string>}
     * @memberof ReleaseMetadata
     */
    'sources'?: Array<string>;
    /**
     * The tags to check to enable chart
     * @type {string}
     * @memberof ReleaseMetadata
     */
    'tags'?: string;
    /**
     * Specifies the chart type: application or library
     * @type {string}
     * @memberof ReleaseMetadata
     */
    'type'?: string;
    /**
     * A SemVer 2 conformant version string of the chart. Required.
     * @type {string}
     * @memberof ReleaseMetadata
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ReleaseRelease
 */
export interface ReleaseRelease {
    /**
     * 
     * @type {ReleaseChart}
     * @memberof ReleaseRelease
     */
    'chart'?: ReleaseChart;
    /**
     * Config is the set of extra Values added to the chart. These values override the default values inside of the chart.
     * @type {object}
     * @memberof ReleaseRelease
     */
    'config'?: object;
    /**
     * Hooks are all of the hooks declared for this release.
     * @type {Array<ReleaseHook>}
     * @memberof ReleaseRelease
     */
    'hooks'?: Array<ReleaseHook>;
    /**
     * Manifest is the string representation of the rendered template.
     * @type {string}
     * @memberof ReleaseRelease
     */
    'manifest'?: string;
    /**
     * Name is the name of the release
     * @type {string}
     * @memberof ReleaseRelease
     */
    'name'?: string;
    /**
     * Namespace is the kubernetes namespace of the release.
     * @type {string}
     * @memberof ReleaseRelease
     */
    'namespace'?: string;
    /**
     * Version is an int which represents the revision of the release.
     * @type {number}
     * @memberof ReleaseRelease
     */
    'version'?: number;
}
/**
 * 
 * @export
 * @interface ReleaseReleaseElement
 */
export interface ReleaseReleaseElement {
    /**
     * 
     * @type {string}
     * @memberof ReleaseReleaseElement
     */
    'app_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseReleaseElement
     */
    'chart'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseReleaseElement
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseReleaseElement
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseReleaseElement
     */
    'revision'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseReleaseElement
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReleaseReleaseElement
     */
    'updated'?: string;
}
/**
 * 
 * @export
 * @interface ResourceQuantity
 */
export interface ResourceQuantity {
    /**
     * 
     * @type {string}
     * @memberof ResourceQuantity
     */
    'Format'?: string;
}
/**
 * 
 * @export
 * @interface ResourcecontrolsResourceControlCreatePayload
 */
export interface ResourcecontrolsResourceControlCreatePayload {
    /**
     * Permit access to resource only to admins
     * @type {boolean}
     * @memberof ResourcecontrolsResourceControlCreatePayload
     */
    'administratorsOnly'?: boolean;
    /**
     * Permit access to the associated resource to any user
     * @type {boolean}
     * @memberof ResourcecontrolsResourceControlCreatePayload
     */
    'public'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ResourcecontrolsResourceControlCreatePayload
     */
    'resourceID': string;
    /**
     * List of Docker resources that will inherit this access control
     * @type {Array<string>}
     * @memberof ResourcecontrolsResourceControlCreatePayload
     */
    'subResourceIDs'?: Array<string>;
    /**
     * List of team identifiers with access to the associated resource
     * @type {Array<number>}
     * @memberof ResourcecontrolsResourceControlCreatePayload
     */
    'teams'?: Array<number>;
    /**
     * Type of Resource. Valid values are: 1 - container, 2 - service 3 - volume, 4 - network, 5 - secret, 6 - stack, 7 - config, 8 - custom template, 9 - azure-container-group
     * @type {number}
     * @memberof ResourcecontrolsResourceControlCreatePayload
     */
    'type': number;
    /**
     * List of user identifiers with access to the associated resource
     * @type {Array<number>}
     * @memberof ResourcecontrolsResourceControlCreatePayload
     */
    'users'?: Array<number>;
}
/**
 * 
 * @export
 * @interface ResourcecontrolsResourceControlUpdatePayload
 */
export interface ResourcecontrolsResourceControlUpdatePayload {
    /**
     * Permit access to resource only to admins
     * @type {boolean}
     * @memberof ResourcecontrolsResourceControlUpdatePayload
     */
    'administratorsOnly'?: boolean;
    /**
     * Permit access to the associated resource to any user
     * @type {boolean}
     * @memberof ResourcecontrolsResourceControlUpdatePayload
     */
    'public'?: boolean;
    /**
     * List of team identifiers with access to the associated resource
     * @type {Array<number>}
     * @memberof ResourcecontrolsResourceControlUpdatePayload
     */
    'teams'?: Array<number>;
    /**
     * List of user identifiers with access to the associated resource
     * @type {Array<number>}
     * @memberof ResourcecontrolsResourceControlUpdatePayload
     */
    'users'?: Array<number>;
}
/**
 * 
 * @export
 * @interface SettingsPublicSettingsResponse
 */
export interface SettingsPublicSettingsResponse {
    /**
     * Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth
     * @type {number}
     * @memberof SettingsPublicSettingsResponse
     */
    'AuthenticationMethod'?: number;
    /**
     * Whether edge compute features are enabled
     * @type {boolean}
     * @memberof SettingsPublicSettingsResponse
     */
    'EnableEdgeComputeFeatures'?: boolean;
    /**
     * Whether telemetry is enabled
     * @type {boolean}
     * @memberof SettingsPublicSettingsResponse
     */
    'EnableTelemetry'?: boolean;
    /**
     * Supported feature flags
     * @type {{ [key: string]: boolean; }}
     * @memberof SettingsPublicSettingsResponse
     */
    'Features'?: { [key: string]: boolean; };
    /**
     * 
     * @type {PortainerGlobalDeploymentOptions}
     * @memberof SettingsPublicSettingsResponse
     */
    'GlobalDeploymentOptions'?: PortainerGlobalDeploymentOptions;
    /**
     * 
     * @type {boolean}
     * @memberof SettingsPublicSettingsResponse
     */
    'IsDockerDesktopExtension'?: boolean;
    /**
     * URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string
     * @type {string}
     * @memberof SettingsPublicSettingsResponse
     */
    'LogoURL'?: string;
    /**
     * The URL used for oauth login
     * @type {string}
     * @memberof SettingsPublicSettingsResponse
     */
    'OAuthLoginURI'?: string;
    /**
     * The URL used for oauth logout
     * @type {string}
     * @memberof SettingsPublicSettingsResponse
     */
    'OAuthLogoutURI'?: string;
    /**
     * The minimum required length for a password of any user when using internal auth mode
     * @type {number}
     * @memberof SettingsPublicSettingsResponse
     */
    'RequiredPasswordLength'?: number;
    /**
     * Show the Kompose build option (discontinued in 2.18)
     * @type {boolean}
     * @memberof SettingsPublicSettingsResponse
     */
    'ShowKomposeBuildOption'?: boolean;
    /**
     * Whether team sync is enabled
     * @type {boolean}
     * @memberof SettingsPublicSettingsResponse
     */
    'TeamSync'?: boolean;
    /**
     * 
     * @type {SettingsPublicSettingsResponseEdge}
     * @memberof SettingsPublicSettingsResponse
     */
    'edge'?: SettingsPublicSettingsResponseEdge;
    /**
     * Whether AMT is enabled
     * @type {boolean}
     * @memberof SettingsPublicSettingsResponse
     */
    'isAMTEnabled'?: boolean;
    /**
     * Whether FDO is enabled
     * @type {boolean}
     * @memberof SettingsPublicSettingsResponse
     */
    'isFDOEnabled'?: boolean;
    /**
     * The expiry of a Kubeconfig
     * @type {string}
     * @memberof SettingsPublicSettingsResponse
     */
    'kubeconfigExpiry'?: string;
}
/**
 * 
 * @export
 * @interface SettingsPublicSettingsResponseEdge
 */
export interface SettingsPublicSettingsResponseEdge {
    /**
     * The command list interval for edge agent - used in edge async mode [seconds]
     * @type {number}
     * @memberof SettingsPublicSettingsResponseEdge
     */
    'CommandInterval'?: number;
    /**
     * The ping interval for edge agent - used in edge async mode [seconds]
     * @type {number}
     * @memberof SettingsPublicSettingsResponseEdge
     */
    'PingInterval'?: number;
    /**
     * The snapshot interval for edge agent - used in edge async mode [seconds]
     * @type {number}
     * @memberof SettingsPublicSettingsResponseEdge
     */
    'SnapshotInterval'?: number;
    /**
     * The check in interval for edge agent (in seconds) - used in non async mode [seconds]
     * @type {number}
     * @memberof SettingsPublicSettingsResponseEdge
     */
    'checkinInterval'?: number;
}
/**
 * 
 * @export
 * @interface SettingsSettingsUpdatePayload
 */
export interface SettingsSettingsUpdatePayload {
    /**
     * EdgePortainerURL is the URL that is exposed to edge agents
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    'EdgePortainerURL'?: string;
    /**
     * Show the Kompose build option (discontinued in 2.18)
     * @type {boolean}
     * @memberof SettingsSettingsUpdatePayload
     */
    'ShowKomposeBuildOption'?: boolean;
    /**
     * Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth
     * @type {number}
     * @memberof SettingsSettingsUpdatePayload
     */
    'authenticationMethod'?: number;
    /**
     * A list of label name & value that will be used to hide containers when querying containers
     * @type {Array<PortainerPair>}
     * @memberof SettingsSettingsUpdatePayload
     */
    'blackListedLabels'?: Array<PortainerPair>;
    /**
     * 
     * @type {number}
     * @memberof SettingsSettingsUpdatePayload
     */
    'edgeAgentCheckinInterval'?: number;
    /**
     * Whether edge compute features are enabled
     * @type {boolean}
     * @memberof SettingsSettingsUpdatePayload
     */
    'enableEdgeComputeFeatures'?: boolean;
    /**
     * Whether telemetry is enabled
     * @type {boolean}
     * @memberof SettingsSettingsUpdatePayload
     */
    'enableTelemetry'?: boolean;
    /**
     * EnforceEdgeID makes Portainer store the Edge ID instead of accepting anyone
     * @type {boolean}
     * @memberof SettingsSettingsUpdatePayload
     */
    'enforceEdgeID'?: boolean;
    /**
     * 
     * @type {PortainerGlobalDeploymentOptions}
     * @memberof SettingsSettingsUpdatePayload
     */
    'globalDeploymentOptions'?: PortainerGlobalDeploymentOptions;
    /**
     * Helm repository URL
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    'helmRepositoryURL'?: string;
    /**
     * 
     * @type {PortainerInternalAuthSettings}
     * @memberof SettingsSettingsUpdatePayload
     */
    'internalAuthSettings'?: PortainerInternalAuthSettings;
    /**
     * The expiry of a Kubeconfig
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    'kubeconfigExpiry'?: string;
    /**
     * Kubectl Shell Image
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    'kubectlShellImage'?: string;
    /**
     * 
     * @type {PortainerLDAPSettings}
     * @memberof SettingsSettingsUpdatePayload
     */
    'ldapsettings'?: PortainerLDAPSettings;
    /**
     * URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    'logoURL'?: string;
    /**
     * 
     * @type {PortainerOAuthSettings}
     * @memberof SettingsSettingsUpdatePayload
     */
    'oauthSettings'?: PortainerOAuthSettings;
    /**
     * The interval in which environment(endpoint) snapshots are created
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    'snapshotInterval'?: string;
    /**
     * URL to the templates that will be displayed in the UI when navigating to App Templates
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    'templatesURL'?: string;
    /**
     * TrustOnFirstConnect makes Portainer accepting edge agent connection by default
     * @type {boolean}
     * @memberof SettingsSettingsUpdatePayload
     */
    'trustOnFirstConnect'?: boolean;
    /**
     * The duration of a user session
     * @type {string}
     * @memberof SettingsSettingsUpdatePayload
     */
    'userSessionTimeout'?: string;
}
/**
 * 
 * @export
 * @interface SslSslUpdatePayload
 */
export interface SslSslUpdatePayload {
    /**
     * SSL Certificates
     * @type {string}
     * @memberof SslSslUpdatePayload
     */
    'cert'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SslSslUpdatePayload
     */
    'httpenabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SslSslUpdatePayload
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface StacksComposeStackFromFileContentPayload
 */
export interface StacksComposeStackFromFileContentPayload {
    /**
     * A list of environment variables used during stack deployment
     * @type {Array<PortainerPair>}
     * @memberof StacksComposeStackFromFileContentPayload
     */
    'env'?: Array<PortainerPair>;
    /**
     * Whether the stack is from a app template
     * @type {boolean}
     * @memberof StacksComposeStackFromFileContentPayload
     */
    'fromAppTemplate'?: boolean;
    /**
     * Name of the stack
     * @type {string}
     * @memberof StacksComposeStackFromFileContentPayload
     */
    'name': string;
    /**
     * Content of the Stack file
     * @type {string}
     * @memberof StacksComposeStackFromFileContentPayload
     */
    'stackFileContent': string;
}
/**
 * 
 * @export
 * @interface StacksComposeStackFromGitRepositoryPayload
 */
export interface StacksComposeStackFromGitRepositoryPayload {
    /**
     * Applicable when deploying with multiple stack files
     * @type {Array<string>}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    'additionalFiles'?: Array<string>;
    /**
     * 
     * @type {PortainerAutoUpdateSettings}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    'autoUpdate'?: PortainerAutoUpdateSettings;
    /**
     * Path to the Stack file inside the Git repository
     * @type {string}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    'composeFile'?: string;
    /**
     * A list of environment variables used during stack deployment
     * @type {Array<PortainerPair>}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    'env'?: Array<PortainerPair>;
    /**
     * Whether the stack is from a app template
     * @type {boolean}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    'fromAppTemplate'?: boolean;
    /**
     * Name of the stack
     * @type {string}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    'name': string;
    /**
     * Use basic authentication to clone the Git repository
     * @type {boolean}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    'repositoryAuthentication'?: boolean;
    /**
     * Password used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    'repositoryPassword'?: string;
    /**
     * Reference name of a Git repository hosting the Stack file
     * @type {string}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    'repositoryReferenceName'?: string;
    /**
     * URL of a Git repository hosting the Stack file
     * @type {string}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    'repositoryURL': string;
    /**
     * Username used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    'repositoryUsername'?: string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof StacksComposeStackFromGitRepositoryPayload
     */
    'tlsskipVerify'?: boolean;
}
/**
 * 
 * @export
 * @interface StacksKubernetesGitDeploymentPayload
 */
export interface StacksKubernetesGitDeploymentPayload {
    /**
     * 
     * @type {Array<string>}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    'additionalFiles'?: Array<string>;
    /**
     * 
     * @type {PortainerAutoUpdateSettings}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    'autoUpdate'?: PortainerAutoUpdateSettings;
    /**
     * 
     * @type {boolean}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    'composeFormat'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    'manifestFile'?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    'namespace'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    'repositoryAuthentication'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    'repositoryPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    'repositoryReferenceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    'repositoryURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    'repositoryUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    'stackName'?: string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof StacksKubernetesGitDeploymentPayload
     */
    'tlsskipVerify'?: boolean;
}
/**
 * 
 * @export
 * @interface StacksKubernetesManifestURLDeploymentPayload
 */
export interface StacksKubernetesManifestURLDeploymentPayload {
    /**
     * 
     * @type {boolean}
     * @memberof StacksKubernetesManifestURLDeploymentPayload
     */
    'composeFormat'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesManifestURLDeploymentPayload
     */
    'manifestURL'?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesManifestURLDeploymentPayload
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesManifestURLDeploymentPayload
     */
    'stackName'?: string;
}
/**
 * 
 * @export
 * @interface StacksKubernetesStringDeploymentPayload
 */
export interface StacksKubernetesStringDeploymentPayload {
    /**
     * 
     * @type {boolean}
     * @memberof StacksKubernetesStringDeploymentPayload
     */
    'composeFormat'?: boolean;
    /**
     * Whether the stack is from a app template
     * @type {boolean}
     * @memberof StacksKubernetesStringDeploymentPayload
     */
    'fromAppTemplate'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesStringDeploymentPayload
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesStringDeploymentPayload
     */
    'stackFileContent'?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksKubernetesStringDeploymentPayload
     */
    'stackName'?: string;
}
/**
 * 
 * @export
 * @interface StacksStackFileResponse
 */
export interface StacksStackFileResponse {
    /**
     * Content of the Stack file
     * @type {string}
     * @memberof StacksStackFileResponse
     */
    'StackFileContent'?: string;
}
/**
 * 
 * @export
 * @interface StacksStackGitRedployPayload
 */
export interface StacksStackGitRedployPayload {
    /**
     * 
     * @type {Array<PortainerPair>}
     * @memberof StacksStackGitRedployPayload
     */
    'env'?: Array<PortainerPair>;
    /**
     * 
     * @type {boolean}
     * @memberof StacksStackGitRedployPayload
     */
    'prune'?: boolean;
    /**
     * Force a pulling to current image with the original tag though the image is already the latest
     * @type {boolean}
     * @memberof StacksStackGitRedployPayload
     */
    'pullImage'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StacksStackGitRedployPayload
     */
    'repositoryAuthentication'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StacksStackGitRedployPayload
     */
    'repositoryPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksStackGitRedployPayload
     */
    'repositoryReferenceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksStackGitRedployPayload
     */
    'repositoryUsername'?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksStackGitRedployPayload
     */
    'stackName'?: string;
}
/**
 * 
 * @export
 * @interface StacksStackGitUpdatePayload
 */
export interface StacksStackGitUpdatePayload {
    /**
     * 
     * @type {PortainerAutoUpdateSettings}
     * @memberof StacksStackGitUpdatePayload
     */
    'autoUpdate'?: PortainerAutoUpdateSettings;
    /**
     * 
     * @type {Array<PortainerPair>}
     * @memberof StacksStackGitUpdatePayload
     */
    'env'?: Array<PortainerPair>;
    /**
     * 
     * @type {boolean}
     * @memberof StacksStackGitUpdatePayload
     */
    'prune'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StacksStackGitUpdatePayload
     */
    'repositoryAuthentication'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StacksStackGitUpdatePayload
     */
    'repositoryPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksStackGitUpdatePayload
     */
    'repositoryReferenceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof StacksStackGitUpdatePayload
     */
    'repositoryUsername'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StacksStackGitUpdatePayload
     */
    'tlsskipVerify'?: boolean;
}
/**
 * 
 * @export
 * @interface StacksStackMigratePayload
 */
export interface StacksStackMigratePayload {
    /**
     * Environment(Endpoint) identifier of the target environment(endpoint) where the stack will be relocated
     * @type {number}
     * @memberof StacksStackMigratePayload
     */
    'endpointID': number;
    /**
     * If provided will rename the migrated stack
     * @type {string}
     * @memberof StacksStackMigratePayload
     */
    'name'?: string;
    /**
     * Swarm cluster identifier, must match the identifier of the cluster where the stack will be relocated
     * @type {string}
     * @memberof StacksStackMigratePayload
     */
    'swarmID'?: string;
}
/**
 * 
 * @export
 * @interface StacksSwarmStackFromFileContentPayload
 */
export interface StacksSwarmStackFromFileContentPayload {
    /**
     * A list of environment variables used during stack deployment
     * @type {Array<PortainerPair>}
     * @memberof StacksSwarmStackFromFileContentPayload
     */
    'env'?: Array<PortainerPair>;
    /**
     * Whether the stack is from a app template
     * @type {boolean}
     * @memberof StacksSwarmStackFromFileContentPayload
     */
    'fromAppTemplate'?: boolean;
    /**
     * Name of the stack
     * @type {string}
     * @memberof StacksSwarmStackFromFileContentPayload
     */
    'name': string;
    /**
     * Content of the Stack file
     * @type {string}
     * @memberof StacksSwarmStackFromFileContentPayload
     */
    'stackFileContent': string;
    /**
     * Swarm cluster identifier
     * @type {string}
     * @memberof StacksSwarmStackFromFileContentPayload
     */
    'swarmID': string;
}
/**
 * 
 * @export
 * @interface StacksSwarmStackFromGitRepositoryPayload
 */
export interface StacksSwarmStackFromGitRepositoryPayload {
    /**
     * Applicable when deploying with multiple stack files
     * @type {Array<string>}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    'additionalFiles'?: Array<string>;
    /**
     * 
     * @type {PortainerAutoUpdateSettings}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    'autoUpdate'?: PortainerAutoUpdateSettings;
    /**
     * Path to the Stack file inside the Git repository
     * @type {string}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    'composeFile'?: string;
    /**
     * A list of environment variables used during stack deployment
     * @type {Array<PortainerPair>}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    'env'?: Array<PortainerPair>;
    /**
     * Whether the stack is from a app template
     * @type {boolean}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    'fromAppTemplate'?: boolean;
    /**
     * Name of the stack
     * @type {string}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    'name': string;
    /**
     * Use basic authentication to clone the Git repository
     * @type {boolean}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    'repositoryAuthentication'?: boolean;
    /**
     * Password used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    'repositoryPassword'?: string;
    /**
     * Reference name of a Git repository hosting the Stack file
     * @type {string}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    'repositoryReferenceName'?: string;
    /**
     * URL of a Git repository hosting the Stack file
     * @type {string}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    'repositoryURL': string;
    /**
     * Username used in basic authentication. Required when RepositoryAuthentication is true.
     * @type {string}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    'repositoryUsername'?: string;
    /**
     * Swarm cluster identifier
     * @type {string}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    'swarmID': string;
    /**
     * TLSSkipVerify skips SSL verification when cloning the Git repository
     * @type {boolean}
     * @memberof StacksSwarmStackFromGitRepositoryPayload
     */
    'tlsskipVerify'?: boolean;
}
/**
 * 
 * @export
 * @interface StacksUpdateSwarmStackPayload
 */
export interface StacksUpdateSwarmStackPayload {
    /**
     * A list of environment(endpoint) variables used during stack deployment
     * @type {Array<PortainerPair>}
     * @memberof StacksUpdateSwarmStackPayload
     */
    'env'?: Array<PortainerPair>;
    /**
     * Prune services that are no longer referenced (only available for Swarm stacks)
     * @type {boolean}
     * @memberof StacksUpdateSwarmStackPayload
     */
    'prune'?: boolean;
    /**
     * Force a pulling to current image with the original tag though the image is already the latest
     * @type {boolean}
     * @memberof StacksUpdateSwarmStackPayload
     */
    'pullImage'?: boolean;
    /**
     * New content of the Stack file
     * @type {string}
     * @memberof StacksUpdateSwarmStackPayload
     */
    'stackFileContent'?: string;
}
/**
 * 
 * @export
 * @interface SwarmServiceUpdateResponse
 */
export interface SwarmServiceUpdateResponse {
    /**
     * Optional warning messages
     * @type {Array<string>}
     * @memberof SwarmServiceUpdateResponse
     */
    'Warnings'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SystemBuildInfo
 */
export interface SystemBuildInfo {
    /**
     * 
     * @type {string}
     * @memberof SystemBuildInfo
     */
    'buildNumber'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SystemBuildInfo
     */
    'env'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SystemBuildInfo
     */
    'gitCommit'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemBuildInfo
     */
    'goVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemBuildInfo
     */
    'imageTag'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemBuildInfo
     */
    'nodejsVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemBuildInfo
     */
    'webpackVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemBuildInfo
     */
    'yarnVersion'?: string;
}
/**
 * 
 * @export
 * @interface SystemNodesCountResponse
 */
export interface SystemNodesCountResponse {
    /**
     * 
     * @type {number}
     * @memberof SystemNodesCountResponse
     */
    'nodes'?: number;
}
/**
 * 
 * @export
 * @interface SystemStatus
 */
export interface SystemStatus {
    /**
     * Portainer API version
     * @type {string}
     * @memberof SystemStatus
     */
    'Version'?: string;
    /**
     * 
     * @type {DemoEnvironmentDetails}
     * @memberof SystemStatus
     */
    'demoEnvironment'?: DemoEnvironmentDetails;
    /**
     * Server Instance ID
     * @type {string}
     * @memberof SystemStatus
     */
    'instanceID'?: string;
}
/**
 * 
 * @export
 * @interface SystemSystemInfoResponse
 */
export interface SystemSystemInfoResponse {
    /**
     * 
     * @type {number}
     * @memberof SystemSystemInfoResponse
     */
    'agents'?: number;
    /**
     * 
     * @type {number}
     * @memberof SystemSystemInfoResponse
     */
    'edgeAgents'?: number;
    /**
     * 
     * @type {string}
     * @memberof SystemSystemInfoResponse
     */
    'platform'?: string;
}
/**
 * 
 * @export
 * @interface SystemVersionResponse
 */
export interface SystemVersionResponse {
    /**
     * The latest version available
     * @type {string}
     * @memberof SystemVersionResponse
     */
    'LatestVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemVersionResponse
     */
    'ServerEdition'?: string;
    /**
     * Whether portainer has an update available
     * @type {boolean}
     * @memberof SystemVersionResponse
     */
    'UpdateAvailable'?: boolean;
    /**
     * 
     * @type {SystemBuildInfo}
     * @memberof SystemVersionResponse
     */
    'build'?: SystemBuildInfo;
    /**
     * 
     * @type {string}
     * @memberof SystemVersionResponse
     */
    'databaseVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemVersionResponse
     */
    'serverVersion'?: string;
}
/**
 * 
 * @export
 * @interface TagsTagCreatePayload
 */
export interface TagsTagCreatePayload {
    /**
     * 
     * @type {string}
     * @memberof TagsTagCreatePayload
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TeammembershipsTeamMembershipCreatePayload
 */
export interface TeammembershipsTeamMembershipCreatePayload {
    /**
     * Role for the user inside the team (1 for leader and 2 for regular member)
     * @type {number}
     * @memberof TeammembershipsTeamMembershipCreatePayload
     */
    'role': number;
    /**
     * Team identifier
     * @type {number}
     * @memberof TeammembershipsTeamMembershipCreatePayload
     */
    'teamID': number;
    /**
     * User identifier
     * @type {number}
     * @memberof TeammembershipsTeamMembershipCreatePayload
     */
    'userID': number;
}
/**
 * 
 * @export
 * @interface TeammembershipsTeamMembershipUpdatePayload
 */
export interface TeammembershipsTeamMembershipUpdatePayload {
    /**
     * Role for the user inside the team (1 for leader and 2 for regular member)
     * @type {number}
     * @memberof TeammembershipsTeamMembershipUpdatePayload
     */
    'role': number;
    /**
     * Team identifier
     * @type {number}
     * @memberof TeammembershipsTeamMembershipUpdatePayload
     */
    'teamID': number;
    /**
     * User identifier
     * @type {number}
     * @memberof TeammembershipsTeamMembershipUpdatePayload
     */
    'userID': number;
}
/**
 * 
 * @export
 * @interface TeamsTeamCreatePayload
 */
export interface TeamsTeamCreatePayload {
    /**
     * Name
     * @type {string}
     * @memberof TeamsTeamCreatePayload
     */
    'name': string;
    /**
     * TeamLeaders
     * @type {Array<number>}
     * @memberof TeamsTeamCreatePayload
     */
    'teamLeaders'?: Array<number>;
}
/**
 * 
 * @export
 * @interface TeamsTeamUpdatePayload
 */
export interface TeamsTeamUpdatePayload {
    /**
     * Name
     * @type {string}
     * @memberof TeamsTeamUpdatePayload
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TemplatesFilePayload
 */
export interface TemplatesFilePayload {
    /**
     * Path to the file inside the git repository
     * @type {string}
     * @memberof TemplatesFilePayload
     */
    'composeFilePathInRepository': string;
    /**
     * URL of a git repository where the file is stored
     * @type {string}
     * @memberof TemplatesFilePayload
     */
    'repositoryURL': string;
}
/**
 * 
 * @export
 * @interface TemplatesFileResponse
 */
export interface TemplatesFileResponse {
    /**
     * The requested file content
     * @type {string}
     * @memberof TemplatesFileResponse
     */
    'fileContent'?: string;
}
/**
 * 
 * @export
 * @interface TemplatesListResponse
 */
export interface TemplatesListResponse {
    /**
     * 
     * @type {Array<PortainerTemplate>}
     * @memberof TemplatesListResponse
     */
    'templates'?: Array<PortainerTemplate>;
    /**
     * 
     * @type {string}
     * @memberof TemplatesListResponse
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface UsersAccessTokenResponse
 */
export interface UsersAccessTokenResponse {
    /**
     * 
     * @type {PortainerAPIKey}
     * @memberof UsersAccessTokenResponse
     */
    'apiKey'?: PortainerAPIKey;
    /**
     * 
     * @type {string}
     * @memberof UsersAccessTokenResponse
     */
    'rawAPIKey'?: string;
}
/**
 * 
 * @export
 * @interface UsersAddHelmRepoUrlPayload
 */
export interface UsersAddHelmRepoUrlPayload {
    /**
     * 
     * @type {string}
     * @memberof UsersAddHelmRepoUrlPayload
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface UsersAdminInitPayload
 */
export interface UsersAdminInitPayload {
    /**
     * Password for the admin user
     * @type {string}
     * @memberof UsersAdminInitPayload
     */
    'password': string;
    /**
     * Username for the admin user
     * @type {string}
     * @memberof UsersAdminInitPayload
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface UsersHelmUserRepositoryResponse
 */
export interface UsersHelmUserRepositoryResponse {
    /**
     * 
     * @type {string}
     * @memberof UsersHelmUserRepositoryResponse
     */
    'GlobalRepository'?: string;
    /**
     * 
     * @type {Array<PortainerHelmUserRepository>}
     * @memberof UsersHelmUserRepositoryResponse
     */
    'UserRepositories'?: Array<PortainerHelmUserRepository>;
}
/**
 * 
 * @export
 * @interface UsersThemePayload
 */
export interface UsersThemePayload {
    /**
     * Color represents the color theme of the UI
     * @type {string}
     * @memberof UsersThemePayload
     */
    'color'?: UsersThemePayloadColorEnum;
}

export const UsersThemePayloadColorEnum = {
    Dark: 'dark',
    Light: 'light',
    Highcontrast: 'highcontrast',
    Auto: 'auto'
} as const;

export type UsersThemePayloadColorEnum = typeof UsersThemePayloadColorEnum[keyof typeof UsersThemePayloadColorEnum];

/**
 * 
 * @export
 * @interface UsersUserAccessTokenCreatePayload
 */
export interface UsersUserAccessTokenCreatePayload {
    /**
     * 
     * @type {string}
     * @memberof UsersUserAccessTokenCreatePayload
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof UsersUserAccessTokenCreatePayload
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UsersUserCreatePayload
 */
export interface UsersUserCreatePayload {
    /**
     * 
     * @type {string}
     * @memberof UsersUserCreatePayload
     */
    'password': string;
    /**
     * User role (1 for administrator account and 2 for regular account)
     * @type {number}
     * @memberof UsersUserCreatePayload
     */
    'role': number;
    /**
     * 
     * @type {string}
     * @memberof UsersUserCreatePayload
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface UsersUserUpdatePasswordPayload
 */
export interface UsersUserUpdatePasswordPayload {
    /**
     * New Password
     * @type {string}
     * @memberof UsersUserUpdatePasswordPayload
     */
    'newPassword': string;
    /**
     * Current Password
     * @type {string}
     * @memberof UsersUserUpdatePasswordPayload
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UsersUserUpdatePayload
 */
export interface UsersUserUpdatePayload {
    /**
     * 
     * @type {string}
     * @memberof UsersUserUpdatePayload
     */
    'newPassword': string;
    /**
     * 
     * @type {string}
     * @memberof UsersUserUpdatePayload
     */
    'password': string;
    /**
     * User role (1 for administrator account and 2 for regular account)
     * @type {number}
     * @memberof UsersUserUpdatePayload
     */
    'role': number;
    /**
     * 
     * @type {UsersThemePayload}
     * @memberof UsersUserUpdatePayload
     */
    'theme'?: UsersThemePayload;
    /**
     * 
     * @type {boolean}
     * @memberof UsersUserUpdatePayload
     */
    'useCache': boolean;
    /**
     * 
     * @type {string}
     * @memberof UsersUserUpdatePayload
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface V1Duration
 */
export interface V1Duration {
    /**
     * 
     * @type {number}
     * @memberof V1Duration
     */
    'time.Duration'?: number;
}
/**
 * 
 * @export
 * @interface V1ManagedFieldsEntry
 */
export interface V1ManagedFieldsEntry {
    /**
     * APIVersion defines the version of this resource that this field set applies to. The format is \"group/version\" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
     * @type {string}
     * @memberof V1ManagedFieldsEntry
     */
    'apiVersion'?: string;
    /**
     * FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: \"FieldsV1\"
     * @type {string}
     * @memberof V1ManagedFieldsEntry
     */
    'fieldsType'?: string;
    /**
     * 
     * @type {object}
     * @memberof V1ManagedFieldsEntry
     */
    'fieldsV1'?: object;
    /**
     * Manager is an identifier of the workflow managing these fields.
     * @type {string}
     * @memberof V1ManagedFieldsEntry
     */
    'manager'?: string;
    /**
     * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are \'Apply\' and \'Update\'.
     * @type {string}
     * @memberof V1ManagedFieldsEntry
     */
    'operation'?: string;
    /**
     * Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
     * @type {string}
     * @memberof V1ManagedFieldsEntry
     */
    'subresource'?: string;
    /**
     * Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over. +optional
     * @type {string}
     * @memberof V1ManagedFieldsEntry
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface V1OwnerReference
 */
export interface V1OwnerReference {
    /**
     * API version of the referent.
     * @type {string}
     * @memberof V1OwnerReference
     */
    'apiVersion'?: string;
    /**
     * If true, AND if the owner has the \"foregroundDeletion\" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs \"delete\" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned. +optional
     * @type {boolean}
     * @memberof V1OwnerReference
     */
    'blockOwnerDeletion'?: boolean;
    /**
     * If true, this reference points to the managing controller. +optional
     * @type {boolean}
     * @memberof V1OwnerReference
     */
    'controller'?: boolean;
    /**
     * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
     * @type {string}
     * @memberof V1OwnerReference
     */
    'kind'?: string;
    /**
     * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
     * @type {string}
     * @memberof V1OwnerReference
     */
    'name'?: string;
    /**
     * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
     * @type {string}
     * @memberof V1OwnerReference
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface V1beta1ContainerMetrics
 */
export interface V1beta1ContainerMetrics {
    /**
     * Container name corresponding to the one from pod.spec.containers.
     * @type {string}
     * @memberof V1beta1ContainerMetrics
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: ResourceQuantity; }}
     * @memberof V1beta1ContainerMetrics
     */
    'usage'?: { [key: string]: ResourceQuantity; };
}
/**
 * 
 * @export
 * @interface V1beta1NodeMetrics
 */
export interface V1beta1NodeMetrics {
    /**
     * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations +optional
     * @type {{ [key: string]: string; }}
     * @memberof V1beta1NodeMetrics
     */
    'annotations'?: { [key: string]: string; };
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    'apiVersion'?: string;
    /**
     * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.  Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    'creationTimestamp'?: string;
    /**
     * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only. +optional
     * @type {number}
     * @memberof V1beta1NodeMetrics
     */
    'deletionGracePeriodSeconds'?: number;
    /**
     * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.  Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    'deletionTimestamp'?: string;
    /**
     * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. +optional +patchStrategy=merge
     * @type {Array<string>}
     * @memberof V1beta1NodeMetrics
     */
    'finalizers'?: Array<string>;
    /**
     * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.  If this field is specified and the generated name exists, the server will return a 409.  Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    'generateName'?: string;
    /**
     * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only. +optional
     * @type {number}
     * @memberof V1beta1NodeMetrics
     */
    'generation'?: number;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    'kind'?: string;
    /**
     * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels +optional
     * @type {{ [key: string]: string; }}
     * @memberof V1beta1NodeMetrics
     */
    'labels'?: { [key: string]: string; };
    /**
     * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn\'t need to set or understand this field. A workflow can be the user\'s name, a controller\'s name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.  +optional
     * @type {Array<V1ManagedFieldsEntry>}
     * @memberof V1beta1NodeMetrics
     */
    'managedFields'?: Array<V1ManagedFieldsEntry>;
    /**
     * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    'name'?: string;
    /**
     * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.  Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    'namespace'?: string;
    /**
     * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. +optional +patchMergeKey=uid +patchStrategy=merge
     * @type {Array<V1OwnerReference>}
     * @memberof V1beta1NodeMetrics
     */
    'ownerReferences'?: Array<V1OwnerReference>;
    /**
     * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.  Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    'resourceVersion'?: string;
    /**
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    'selfLink'?: string;
    /**
     * The following fields define time interval from which metrics were collected from the interval [Timestamp-Window, Timestamp].
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    'timestamp'?: string;
    /**
     * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.  Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids +optional
     * @type {string}
     * @memberof V1beta1NodeMetrics
     */
    'uid'?: string;
    /**
     * 
     * @type {{ [key: string]: ResourceQuantity; }}
     * @memberof V1beta1NodeMetrics
     */
    'usage'?: { [key: string]: ResourceQuantity; };
    /**
     * 
     * @type {V1Duration}
     * @memberof V1beta1NodeMetrics
     */
    'window'?: V1Duration;
}
/**
 * 
 * @export
 * @interface V1beta1NodeMetricsList
 */
export interface V1beta1NodeMetricsList {
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources +optional
     * @type {string}
     * @memberof V1beta1NodeMetricsList
     */
    'apiVersion'?: string;
    /**
     * continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
     * @type {string}
     * @memberof V1beta1NodeMetricsList
     */
    'continue'?: string;
    /**
     * List of node metrics.
     * @type {Array<V1beta1NodeMetrics>}
     * @memberof V1beta1NodeMetricsList
     */
    'items'?: Array<V1beta1NodeMetrics>;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds +optional
     * @type {string}
     * @memberof V1beta1NodeMetricsList
     */
    'kind'?: string;
    /**
     * remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact. +optional
     * @type {number}
     * @memberof V1beta1NodeMetricsList
     */
    'remainingItemCount'?: number;
    /**
     * String that identifies the server\'s internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency +optional
     * @type {string}
     * @memberof V1beta1NodeMetricsList
     */
    'resourceVersion'?: string;
    /**
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. +optional
     * @type {string}
     * @memberof V1beta1NodeMetricsList
     */
    'selfLink'?: string;
}
/**
 * 
 * @export
 * @interface V1beta1PodMetrics
 */
export interface V1beta1PodMetrics {
    /**
     * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations +optional
     * @type {{ [key: string]: string; }}
     * @memberof V1beta1PodMetrics
     */
    'annotations'?: { [key: string]: string; };
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    'apiVersion'?: string;
    /**
     * Metrics for all containers are collected within the same time window.
     * @type {Array<V1beta1ContainerMetrics>}
     * @memberof V1beta1PodMetrics
     */
    'containers'?: Array<V1beta1ContainerMetrics>;
    /**
     * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.  Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    'creationTimestamp'?: string;
    /**
     * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only. +optional
     * @type {number}
     * @memberof V1beta1PodMetrics
     */
    'deletionGracePeriodSeconds'?: number;
    /**
     * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.  Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    'deletionTimestamp'?: string;
    /**
     * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list. +optional +patchStrategy=merge
     * @type {Array<string>}
     * @memberof V1beta1PodMetrics
     */
    'finalizers'?: Array<string>;
    /**
     * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.  If this field is specified and the generated name exists, the server will return a 409.  Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    'generateName'?: string;
    /**
     * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only. +optional
     * @type {number}
     * @memberof V1beta1PodMetrics
     */
    'generation'?: number;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    'kind'?: string;
    /**
     * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels +optional
     * @type {{ [key: string]: string; }}
     * @memberof V1beta1PodMetrics
     */
    'labels'?: { [key: string]: string; };
    /**
     * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn\'t need to set or understand this field. A workflow can be the user\'s name, a controller\'s name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.  +optional
     * @type {Array<V1ManagedFieldsEntry>}
     * @memberof V1beta1PodMetrics
     */
    'managedFields'?: Array<V1ManagedFieldsEntry>;
    /**
     * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    'name'?: string;
    /**
     * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.  Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    'namespace'?: string;
    /**
     * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller. +optional +patchMergeKey=uid +patchStrategy=merge
     * @type {Array<V1OwnerReference>}
     * @memberof V1beta1PodMetrics
     */
    'ownerReferences'?: Array<V1OwnerReference>;
    /**
     * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.  Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    'resourceVersion'?: string;
    /**
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    'selfLink'?: string;
    /**
     * The following fields define time interval from which metrics were collected from the interval [Timestamp-Window, Timestamp].
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    'timestamp'?: string;
    /**
     * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.  Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids +optional
     * @type {string}
     * @memberof V1beta1PodMetrics
     */
    'uid'?: string;
    /**
     * 
     * @type {V1Duration}
     * @memberof V1beta1PodMetrics
     */
    'window'?: V1Duration;
}
/**
 * 
 * @export
 * @interface V1beta1PodMetricsList
 */
export interface V1beta1PodMetricsList {
    /**
     * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources +optional
     * @type {string}
     * @memberof V1beta1PodMetricsList
     */
    'apiVersion'?: string;
    /**
     * continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
     * @type {string}
     * @memberof V1beta1PodMetricsList
     */
    'continue'?: string;
    /**
     * List of pod metrics.
     * @type {Array<V1beta1PodMetrics>}
     * @memberof V1beta1PodMetricsList
     */
    'items'?: Array<V1beta1PodMetrics>;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds +optional
     * @type {string}
     * @memberof V1beta1PodMetricsList
     */
    'kind'?: string;
    /**
     * remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact. +optional
     * @type {number}
     * @memberof V1beta1PodMetricsList
     */
    'remainingItemCount'?: number;
    /**
     * String that identifies the server\'s internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency +optional
     * @type {string}
     * @memberof V1beta1PodMetricsList
     */
    'resourceVersion'?: string;
    /**
     * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system. +optional
     * @type {string}
     * @memberof V1beta1PodMetricsList
     */
    'selfLink'?: string;
}
/**
 * 
 * @export
 * @interface WebhooksWebhookCreatePayload
 */
export interface WebhooksWebhookCreatePayload {
    /**
     * Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment
     * @type {number}
     * @memberof WebhooksWebhookCreatePayload
     */
    'endpointID'?: number;
    /**
     * Registry Identifier
     * @type {number}
     * @memberof WebhooksWebhookCreatePayload
     */
    'registryID'?: number;
    /**
     * 
     * @type {string}
     * @memberof WebhooksWebhookCreatePayload
     */
    'resourceID'?: string;
    /**
     * Type of webhook (1 - service)
     * @type {number}
     * @memberof WebhooksWebhookCreatePayload
     */
    'webhookType'?: number;
}
/**
 * 
 * @export
 * @interface WebhooksWebhookUpdatePayload
 */
export interface WebhooksWebhookUpdatePayload {
    /**
     * Registry Identifier
     * @type {number}
     * @memberof WebhooksWebhookUpdatePayload
     */
    'registryID'?: number;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: public Use this environment(endpoint) to authenticate against Portainer using a username and password.
         * @summary Authenticate
         * @param {AuthAuthenticatePayload} body Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser: async (body: AuthAuthenticatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authenticateUser', 'body', body)
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Authenticate with OAuth
         * @param {AuthOauthPayload} body OAuth Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateOAuth: async (body: AuthOauthPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('validateOAuth', 'body', body)
            const localVarPath = `/auth/oauth/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * **Access policy**: public Use this environment(endpoint) to authenticate against Portainer using a username and password.
         * @summary Authenticate
         * @param {AuthAuthenticatePayload} body Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateUser(body: AuthAuthenticatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthAuthenticateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateUser(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: public
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: public
         * @summary Authenticate with OAuth
         * @param {AuthOauthPayload} body OAuth Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateOAuth(body: AuthOauthPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthAuthenticateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateOAuth(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * **Access policy**: public Use this environment(endpoint) to authenticate against Portainer using a username and password.
         * @summary Authenticate
         * @param {AuthAuthenticatePayload} body Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser(body: AuthAuthenticatePayload, options?: any): AxiosPromise<AuthAuthenticateResponse> {
            return localVarFp.authenticateUser(body, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: public
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: public
         * @summary Authenticate with OAuth
         * @param {AuthOauthPayload} body OAuth Credentials used for authentication
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateOAuth(body: AuthOauthPayload, options?: any): AxiosPromise<AuthAuthenticateResponse> {
            return localVarFp.validateOAuth(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * **Access policy**: public Use this environment(endpoint) to authenticate against Portainer using a username and password.
     * @summary Authenticate
     * @param {AuthAuthenticatePayload} body Credentials used for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authenticateUser(body: AuthAuthenticatePayload, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authenticateUser(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: public
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: public
     * @summary Authenticate with OAuth
     * @param {AuthOauthPayload} body OAuth Credentials used for authentication
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public validateOAuth(body: AuthOauthPayload, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).validateOAuth(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BackupApi - axios parameter creator
 * @export
 */
export const BackupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an archive with a system data snapshot that could be used to restore the system. **Access policy**: admin
         * @summary Creates an archive with a system data snapshot that could be used to restore the system.
         * @param {BackupBackupPayload} [body] An object contains the password to encrypt the backup with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup: async (body?: BackupBackupPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/backup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers a system restore using provided backup file **Access policy**: public
         * @summary Triggers a system restore using provided backup file
         * @param {BackupRestorePayload} restorePayload Restore request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore: async (restorePayload: BackupRestorePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'restorePayload' is not null or undefined
            assertParamExists('restore', 'restorePayload', restorePayload)
            const localVarPath = `/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(restorePayload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackupApi - functional programming interface
 * @export
 */
export const BackupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BackupApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates an archive with a system data snapshot that could be used to restore the system. **Access policy**: admin
         * @summary Creates an archive with a system data snapshot that could be used to restore the system.
         * @param {BackupBackupPayload} [body] An object contains the password to encrypt the backup with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async backup(body?: BackupBackupPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.backup(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Triggers a system restore using provided backup file **Access policy**: public
         * @summary Triggers a system restore using provided backup file
         * @param {BackupRestorePayload} restorePayload Restore request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restore(restorePayload: BackupRestorePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restore(restorePayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BackupApi - factory interface
 * @export
 */
export const BackupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BackupApiFp(configuration)
    return {
        /**
         * Creates an archive with a system data snapshot that could be used to restore the system. **Access policy**: admin
         * @summary Creates an archive with a system data snapshot that could be used to restore the system.
         * @param {BackupBackupPayload} [body] An object contains the password to encrypt the backup with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backup(body?: BackupBackupPayload, options?: any): AxiosPromise<void> {
            return localVarFp.backup(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers a system restore using provided backup file **Access policy**: public
         * @summary Triggers a system restore using provided backup file
         * @param {BackupRestorePayload} restorePayload Restore request payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restore(restorePayload: BackupRestorePayload, options?: any): AxiosPromise<void> {
            return localVarFp.restore(restorePayload, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BackupApi - object-oriented interface
 * @export
 * @class BackupApi
 * @extends {BaseAPI}
 */
export class BackupApi extends BaseAPI {
    /**
     * Creates an archive with a system data snapshot that could be used to restore the system. **Access policy**: admin
     * @summary Creates an archive with a system data snapshot that could be used to restore the system.
     * @param {BackupBackupPayload} [body] An object contains the password to encrypt the backup with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public backup(body?: BackupBackupPayload, options?: AxiosRequestConfig) {
        return BackupApiFp(this.configuration).backup(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers a system restore using provided backup file **Access policy**: public
     * @summary Triggers a system restore using provided backup file
     * @param {BackupRestorePayload} restorePayload Restore request payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupApi
     */
    public restore(restorePayload: BackupRestorePayload, options?: AxiosRequestConfig) {
        return BackupApiFp(this.configuration).restore(restorePayload, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomTemplatesApi - axios parameter creator
 * @export
 */
export const CustomTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {'string' | 'file' | 'repository'} method method for creating template
         * @param {object} body for body documentation see the relevant /custom_templates/{method} endpoint
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        customTemplateCreate: async (method: 'string' | 'file' | 'repository', body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'method' is not null or undefined
            assertParamExists('customTemplateCreate', 'method', method)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('customTemplateCreate', 'body', body)
            const localVarPath = `/custom_templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {string} title Title of the template
         * @param {string} description Description of the template
         * @param {string} note A note that will be displayed in the UI. Supports HTML content
         * @param {number} platform Platform associated to the template (1 - \\\&#39;linux\\\&#39;, 2 - \\\&#39;windows\\\&#39;)
         * @param {number} type Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
         * @param {File} file File
         * @param {string} [logo] URL of the template\\\&#39;s logo
         * @param {string} [variables] A json array of variables definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateFile: async (title: string, description: string, note: string, platform: number, type: number, file: File, logo?: string, variables?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'title' is not null or undefined
            assertParamExists('customTemplateCreateFile', 'title', title)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('customTemplateCreateFile', 'description', description)
            // verify required parameter 'note' is not null or undefined
            assertParamExists('customTemplateCreateFile', 'note', note)
            // verify required parameter 'platform' is not null or undefined
            assertParamExists('customTemplateCreateFile', 'platform', platform)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('customTemplateCreateFile', 'type', type)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('customTemplateCreateFile', 'file', file)
            const localVarPath = `/custom_templates/create/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (title !== undefined) { 
                localVarFormParams.append('Title', title as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('Description', description as any);
            }
    
            if (note !== undefined) { 
                localVarFormParams.append('Note', note as any);
            }
    
            if (platform !== undefined) { 
                localVarFormParams.append('Platform', platform as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.append('Type', type as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('File', file as any);
            }
    
            if (logo !== undefined) { 
                localVarFormParams.append('Logo', logo as any);
            }
    
            if (variables !== undefined) { 
                localVarFormParams.append('Variables', variables as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromGitRepositoryPayload} body Required when using method&#x3D;repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateRepository: async (body: CustomtemplatesCustomTemplateFromGitRepositoryPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('customTemplateCreateRepository', 'body', body)
            const localVarPath = `/custom_templates/create/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromFileContentPayload} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateString: async (body: CustomtemplatesCustomTemplateFromFileContentPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('customTemplateCreateString', 'body', body)
            const localVarPath = `/custom_templates/create/string`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a template. **Access policy**: authenticated
         * @summary Remove a template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('customTemplateDelete', 'id', id)
            const localVarPath = `/custom_templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the content of the Stack file for the specified custom template **Access policy**: authenticated
         * @summary Get Template stack file content.
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateFile: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('customTemplateFile', 'id', id)
            const localVarPath = `/custom_templates/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a template created from git repository method. **Access policy**: authenticated
         * @summary Fetch the latest config file content based on custom template\'s git repository configuration
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateGitFetch: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('customTemplateGitFetch', 'id', id)
            const localVarPath = `/custom_templates/{id}/git_fetch`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a template. **Access policy**: authenticated
         * @summary Inspect a custom template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateInspect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('customTemplateInspect', 'id', id)
            const localVarPath = `/custom_templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available custom templates. **Access policy**: authenticated
         * @summary List available custom templates
         * @param {Array<number>} type Template types
         * @param {boolean} [edge] Filter by edge templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateList: async (type: Array<number>, edge?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('customTemplateList', 'type', type)
            const localVarPath = `/custom_templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (edge !== undefined) {
                localVarQueryParameter['edge'] = edge;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a template. **Access policy**: authenticated
         * @summary Update a template
         * @param {number} id Template identifier
         * @param {CustomtemplatesCustomTemplateUpdatePayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateUpdate: async (id: number, body: CustomtemplatesCustomTemplateUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('customTemplateUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('customTemplateUpdate', 'body', body)
            const localVarPath = `/custom_templates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomTemplatesApi - functional programming interface
 * @export
 */
export const CustomTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {'string' | 'file' | 'repository'} method method for creating template
         * @param {object} body for body documentation see the relevant /custom_templates/{method} endpoint
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async customTemplateCreate(method: 'string' | 'file' | 'repository', body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerCustomTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customTemplateCreate(method, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {string} title Title of the template
         * @param {string} description Description of the template
         * @param {string} note A note that will be displayed in the UI. Supports HTML content
         * @param {number} platform Platform associated to the template (1 - \\\&#39;linux\\\&#39;, 2 - \\\&#39;windows\\\&#39;)
         * @param {number} type Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
         * @param {File} file File
         * @param {string} [logo] URL of the template\\\&#39;s logo
         * @param {string} [variables] A json array of variables definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customTemplateCreateFile(title: string, description: string, note: string, platform: number, type: number, file: File, logo?: string, variables?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerCustomTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customTemplateCreateFile(title, description, note, platform, type, file, logo, variables, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromGitRepositoryPayload} body Required when using method&#x3D;repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customTemplateCreateRepository(body: CustomtemplatesCustomTemplateFromGitRepositoryPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerCustomTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customTemplateCreateRepository(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromFileContentPayload} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customTemplateCreateString(body: CustomtemplatesCustomTemplateFromFileContentPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerCustomTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customTemplateCreateString(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a template. **Access policy**: authenticated
         * @summary Remove a template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customTemplateDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customTemplateDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the content of the Stack file for the specified custom template **Access policy**: authenticated
         * @summary Get Template stack file content.
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customTemplateFile(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomtemplatesFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customTemplateFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve details about a template created from git repository method. **Access policy**: authenticated
         * @summary Fetch the latest config file content based on custom template\'s git repository configuration
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customTemplateGitFetch(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomtemplatesFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customTemplateGitFetch(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve details about a template. **Access policy**: authenticated
         * @summary Inspect a custom template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customTemplateInspect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerCustomTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customTemplateInspect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List available custom templates. **Access policy**: authenticated
         * @summary List available custom templates
         * @param {Array<number>} type Template types
         * @param {boolean} [edge] Filter by edge templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customTemplateList(type: Array<number>, edge?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerCustomTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customTemplateList(type, edge, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a template. **Access policy**: authenticated
         * @summary Update a template
         * @param {number} id Template identifier
         * @param {CustomtemplatesCustomTemplateUpdatePayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customTemplateUpdate(id: number, body: CustomtemplatesCustomTemplateUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerCustomTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customTemplateUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomTemplatesApi - factory interface
 * @export
 */
export const CustomTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomTemplatesApiFp(configuration)
    return {
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {'string' | 'file' | 'repository'} method method for creating template
         * @param {object} body for body documentation see the relevant /custom_templates/{method} endpoint
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        customTemplateCreate(method: 'string' | 'file' | 'repository', body: object, options?: any): AxiosPromise<PortainerCustomTemplate> {
            return localVarFp.customTemplateCreate(method, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {string} title Title of the template
         * @param {string} description Description of the template
         * @param {string} note A note that will be displayed in the UI. Supports HTML content
         * @param {number} platform Platform associated to the template (1 - \\\&#39;linux\\\&#39;, 2 - \\\&#39;windows\\\&#39;)
         * @param {number} type Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
         * @param {File} file File
         * @param {string} [logo] URL of the template\\\&#39;s logo
         * @param {string} [variables] A json array of variables definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateFile(title: string, description: string, note: string, platform: number, type: number, file: File, logo?: string, variables?: string, options?: any): AxiosPromise<PortainerCustomTemplate> {
            return localVarFp.customTemplateCreateFile(title, description, note, platform, type, file, logo, variables, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromGitRepositoryPayload} body Required when using method&#x3D;repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateRepository(body: CustomtemplatesCustomTemplateFromGitRepositoryPayload, options?: any): AxiosPromise<PortainerCustomTemplate> {
            return localVarFp.customTemplateCreateRepository(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a custom template. **Access policy**: authenticated
         * @summary Create a custom template
         * @param {CustomtemplatesCustomTemplateFromFileContentPayload} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateCreateString(body: CustomtemplatesCustomTemplateFromFileContentPayload, options?: any): AxiosPromise<PortainerCustomTemplate> {
            return localVarFp.customTemplateCreateString(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a template. **Access policy**: authenticated
         * @summary Remove a template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.customTemplateDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the content of the Stack file for the specified custom template **Access policy**: authenticated
         * @summary Get Template stack file content.
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateFile(id: number, options?: any): AxiosPromise<CustomtemplatesFileResponse> {
            return localVarFp.customTemplateFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details about a template created from git repository method. **Access policy**: authenticated
         * @summary Fetch the latest config file content based on custom template\'s git repository configuration
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateGitFetch(id: number, options?: any): AxiosPromise<CustomtemplatesFileResponse> {
            return localVarFp.customTemplateGitFetch(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details about a template. **Access policy**: authenticated
         * @summary Inspect a custom template
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateInspect(id: number, options?: any): AxiosPromise<PortainerCustomTemplate> {
            return localVarFp.customTemplateInspect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List available custom templates. **Access policy**: authenticated
         * @summary List available custom templates
         * @param {Array<number>} type Template types
         * @param {boolean} [edge] Filter by edge templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateList(type: Array<number>, edge?: boolean, options?: any): AxiosPromise<Array<PortainerCustomTemplate>> {
            return localVarFp.customTemplateList(type, edge, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a template. **Access policy**: authenticated
         * @summary Update a template
         * @param {number} id Template identifier
         * @param {CustomtemplatesCustomTemplateUpdatePayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customTemplateUpdate(id: number, body: CustomtemplatesCustomTemplateUpdatePayload, options?: any): AxiosPromise<PortainerCustomTemplate> {
            return localVarFp.customTemplateUpdate(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomTemplatesApi - object-oriented interface
 * @export
 * @class CustomTemplatesApi
 * @extends {BaseAPI}
 */
export class CustomTemplatesApi extends BaseAPI {
    /**
     * Create a custom template. **Access policy**: authenticated
     * @summary Create a custom template
     * @param {'string' | 'file' | 'repository'} method method for creating template
     * @param {object} body for body documentation see the relevant /custom_templates/{method} endpoint
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateCreate(method: 'string' | 'file' | 'repository', body: object, options?: AxiosRequestConfig) {
        return CustomTemplatesApiFp(this.configuration).customTemplateCreate(method, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a custom template. **Access policy**: authenticated
     * @summary Create a custom template
     * @param {string} title Title of the template
     * @param {string} description Description of the template
     * @param {string} note A note that will be displayed in the UI. Supports HTML content
     * @param {number} platform Platform associated to the template (1 - \\\&#39;linux\\\&#39;, 2 - \\\&#39;windows\\\&#39;)
     * @param {number} type Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
     * @param {File} file File
     * @param {string} [logo] URL of the template\\\&#39;s logo
     * @param {string} [variables] A json array of variables definitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateCreateFile(title: string, description: string, note: string, platform: number, type: number, file: File, logo?: string, variables?: string, options?: AxiosRequestConfig) {
        return CustomTemplatesApiFp(this.configuration).customTemplateCreateFile(title, description, note, platform, type, file, logo, variables, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a custom template. **Access policy**: authenticated
     * @summary Create a custom template
     * @param {CustomtemplatesCustomTemplateFromGitRepositoryPayload} body Required when using method&#x3D;repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateCreateRepository(body: CustomtemplatesCustomTemplateFromGitRepositoryPayload, options?: AxiosRequestConfig) {
        return CustomTemplatesApiFp(this.configuration).customTemplateCreateRepository(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a custom template. **Access policy**: authenticated
     * @summary Create a custom template
     * @param {CustomtemplatesCustomTemplateFromFileContentPayload} body body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateCreateString(body: CustomtemplatesCustomTemplateFromFileContentPayload, options?: AxiosRequestConfig) {
        return CustomTemplatesApiFp(this.configuration).customTemplateCreateString(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a template. **Access policy**: authenticated
     * @summary Remove a template
     * @param {number} id Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateDelete(id: number, options?: AxiosRequestConfig) {
        return CustomTemplatesApiFp(this.configuration).customTemplateDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the content of the Stack file for the specified custom template **Access policy**: authenticated
     * @summary Get Template stack file content.
     * @param {number} id Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateFile(id: number, options?: AxiosRequestConfig) {
        return CustomTemplatesApiFp(this.configuration).customTemplateFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details about a template created from git repository method. **Access policy**: authenticated
     * @summary Fetch the latest config file content based on custom template\'s git repository configuration
     * @param {number} id Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateGitFetch(id: number, options?: AxiosRequestConfig) {
        return CustomTemplatesApiFp(this.configuration).customTemplateGitFetch(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details about a template. **Access policy**: authenticated
     * @summary Inspect a custom template
     * @param {number} id Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateInspect(id: number, options?: AxiosRequestConfig) {
        return CustomTemplatesApiFp(this.configuration).customTemplateInspect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List available custom templates. **Access policy**: authenticated
     * @summary List available custom templates
     * @param {Array<number>} type Template types
     * @param {boolean} [edge] Filter by edge templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateList(type: Array<number>, edge?: boolean, options?: AxiosRequestConfig) {
        return CustomTemplatesApiFp(this.configuration).customTemplateList(type, edge, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a template. **Access policy**: authenticated
     * @summary Update a template
     * @param {number} id Template identifier
     * @param {CustomtemplatesCustomTemplateUpdatePayload} body Template details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomTemplatesApi
     */
    public customTemplateUpdate(id: number, body: CustomtemplatesCustomTemplateUpdatePayload, options?: AxiosRequestConfig) {
        return CustomTemplatesApiFp(this.configuration).customTemplateUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DockerApi - axios parameter creator
 * @export
 */
export const DockerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**:
         * @summary Fetch container gpus data
         * @param {number} environmentId Environment identifier
         * @param {number} containerId Container identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockerContainerGpusInspect: async (environmentId: number, containerId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('dockerContainerGpusInspect', 'environmentId', environmentId)
            // verify required parameter 'containerId' is not null or undefined
            assertParamExists('dockerContainerGpusInspect', 'containerId', containerId)
            const localVarPath = `/docker/{environmentId}/containers/{containerId}/gpus`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)))
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**:
         * @summary Fetch images
         * @param {number} environmentId Environment identifier
         * @param {boolean} [withUsage] Include image usage information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockerImagesList: async (environmentId: number, withUsage?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('dockerImagesList', 'environmentId', environmentId)
            const localVarPath = `/docker/{environmentId}/images`
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (withUsage !== undefined) {
                localVarQueryParameter['withUsage'] = withUsage;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DockerApi - functional programming interface
 * @export
 */
export const DockerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DockerApiAxiosParamCreator(configuration)
    return {
        /**
         * **Access policy**:
         * @summary Fetch container gpus data
         * @param {number} environmentId Environment identifier
         * @param {number} containerId Container identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dockerContainerGpusInspect(environmentId: number, containerId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersContainerGpusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dockerContainerGpusInspect(environmentId, containerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**:
         * @summary Fetch images
         * @param {number} environmentId Environment identifier
         * @param {boolean} [withUsage] Include image usage information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dockerImagesList(environmentId: number, withUsage?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImagesImageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dockerImagesList(environmentId, withUsage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DockerApi - factory interface
 * @export
 */
export const DockerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DockerApiFp(configuration)
    return {
        /**
         * **Access policy**:
         * @summary Fetch container gpus data
         * @param {number} environmentId Environment identifier
         * @param {number} containerId Container identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockerContainerGpusInspect(environmentId: number, containerId: number, options?: any): AxiosPromise<ContainersContainerGpusResponse> {
            return localVarFp.dockerContainerGpusInspect(environmentId, containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**:
         * @summary Fetch images
         * @param {number} environmentId Environment identifier
         * @param {boolean} [withUsage] Include image usage information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dockerImagesList(environmentId: number, withUsage?: boolean, options?: any): AxiosPromise<Array<ImagesImageResponse>> {
            return localVarFp.dockerImagesList(environmentId, withUsage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DockerApi - object-oriented interface
 * @export
 * @class DockerApi
 * @extends {BaseAPI}
 */
export class DockerApi extends BaseAPI {
    /**
     * **Access policy**:
     * @summary Fetch container gpus data
     * @param {number} environmentId Environment identifier
     * @param {number} containerId Container identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DockerApi
     */
    public dockerContainerGpusInspect(environmentId: number, containerId: number, options?: AxiosRequestConfig) {
        return DockerApiFp(this.configuration).dockerContainerGpusInspect(environmentId, containerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**:
     * @summary Fetch images
     * @param {number} environmentId Environment identifier
     * @param {boolean} [withUsage] Include image usage information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DockerApi
     */
    public dockerImagesList(environmentId: number, withUsage?: boolean, options?: AxiosRequestConfig) {
        return DockerApiFp(this.configuration).dockerImagesList(environmentId, withUsage, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EdgeApi - axios parameter creator
 * @export
 */
export const EdgeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost: async (id: number, jobID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointsIdEdgeJobsJobIDLogsPost', 'id', id)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('endpointsIdEdgeJobsJobIDLogsPost', 'jobID', jobID)
            const localVarPath = `/endpoints/{id}/edge/jobs/{jobID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet: async (id: number, stackId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointsIdEdgeStacksStackIdGet', 'id', id)
            // verify required parameter 'stackId' is not null or undefined
            assertParamExists('endpointsIdEdgeStacksStackIdGet', 'stackId', stackId)
            const localVarPath = `/endpoints/{id}/edge/stacks/{stackId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"stackId"}}`, encodeURIComponent(String(stackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EdgeApi - functional programming interface
 * @export
 */
export const EdgeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EdgeApiAxiosParamCreator(configuration)
    return {
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointsIdEdgeJobsJobIDLogsPost(id: number, jobID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EdgeStackPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsIdEdgeStacksStackIdGet(id, stackId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EdgeApi - factory interface
 * @export
 */
export const EdgeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EdgeApiFp(configuration)
    return {
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost(id: number, jobID: number, options?: any): AxiosPromise<void> {
            return localVarFp.endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: any): AxiosPromise<EdgeStackPayload> {
            return localVarFp.endpointsIdEdgeStacksStackIdGet(id, stackId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EdgeApi - object-oriented interface
 * @export
 * @class EdgeApi
 * @extends {BaseAPI}
 */
export class EdgeApi extends BaseAPI {
    /**
     * **Access policy**: public
     * @summary Inspect an EdgeJob Log
     * @param {number} id environment(endpoint) Id
     * @param {number} jobID Job Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeApi
     */
    public endpointsIdEdgeJobsJobIDLogsPost(id: number, jobID: number, options?: AxiosRequestConfig) {
        return EdgeApiFp(this.configuration).endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: public
     * @summary Inspect an Edge Stack for an Environment(Endpoint)
     * @param {number} id environment(endpoint) Id
     * @param {number} stackId EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeApi
     */
    public endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: AxiosRequestConfig) {
        return EdgeApiFp(this.configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EdgeGroupsApi - axios parameter creator
 * @export
 */
export const EdgeGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeGroup
         * @param {EdgegroupsEdgeGroupCreatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupCreate: async (body: EdgegroupsEdgeGroupCreatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('edgeGroupCreate', 'body', body)
            const localVarPath = `/edge_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Deletes an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeGroupDelete', 'id', id)
            const localVarPath = `/edge_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspects an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupInspect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeGroupInspect', 'id', id)
            const localVarPath = `/edge_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary list EdgeGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/edge_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Updates an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {EdgegroupsEdgeGroupUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egeGroupUpdate: async (id: number, body: EdgegroupsEdgeGroupUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('egeGroupUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('egeGroupUpdate', 'body', body)
            const localVarPath = `/edge_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EdgeGroupsApi - functional programming interface
 * @export
 */
export const EdgeGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EdgeGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeGroup
         * @param {EdgegroupsEdgeGroupCreatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeGroupCreate(body: EdgegroupsEdgeGroupCreatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeGroupCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Deletes an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeGroupDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeGroupDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Inspects an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeGroupInspect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeGroupInspect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary list EdgeGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeGroupList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EdgegroupsDecoratedEdgeGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeGroupList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Updates an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {EdgegroupsEdgeGroupUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async egeGroupUpdate(id: number, body: EdgegroupsEdgeGroupUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.egeGroupUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EdgeGroupsApi - factory interface
 * @export
 */
export const EdgeGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EdgeGroupsApiFp(configuration)
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeGroup
         * @param {EdgegroupsEdgeGroupCreatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupCreate(body: EdgegroupsEdgeGroupCreatePayload, options?: any): AxiosPromise<PortainerEdgeGroup> {
            return localVarFp.edgeGroupCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Deletes an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.edgeGroupDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Inspects an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupInspect(id: number, options?: any): AxiosPromise<PortainerEdgeGroup> {
            return localVarFp.edgeGroupInspect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary list EdgeGroups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeGroupList(options?: any): AxiosPromise<Array<EdgegroupsDecoratedEdgeGroup>> {
            return localVarFp.edgeGroupList(options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Updates an EdgeGroup
         * @param {number} id EdgeGroup Id
         * @param {EdgegroupsEdgeGroupUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        egeGroupUpdate(id: number, body: EdgegroupsEdgeGroupUpdatePayload, options?: any): AxiosPromise<PortainerEdgeGroup> {
            return localVarFp.egeGroupUpdate(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EdgeGroupsApi - object-oriented interface
 * @export
 * @class EdgeGroupsApi
 * @extends {BaseAPI}
 */
export class EdgeGroupsApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Create an EdgeGroup
     * @param {EdgegroupsEdgeGroupCreatePayload} body EdgeGroup data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    public edgeGroupCreate(body: EdgegroupsEdgeGroupCreatePayload, options?: AxiosRequestConfig) {
        return EdgeGroupsApiFp(this.configuration).edgeGroupCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Deletes an EdgeGroup
     * @param {number} id EdgeGroup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    public edgeGroupDelete(id: number, options?: AxiosRequestConfig) {
        return EdgeGroupsApiFp(this.configuration).edgeGroupDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Inspects an EdgeGroup
     * @param {number} id EdgeGroup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    public edgeGroupInspect(id: number, options?: AxiosRequestConfig) {
        return EdgeGroupsApiFp(this.configuration).edgeGroupInspect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary list EdgeGroups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    public edgeGroupList(options?: AxiosRequestConfig) {
        return EdgeGroupsApiFp(this.configuration).edgeGroupList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Updates an EdgeGroup
     * @param {number} id EdgeGroup Id
     * @param {EdgegroupsEdgeGroupUpdatePayload} body EdgeGroup data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeGroupsApi
     */
    public egeGroupUpdate(id: number, body: EdgegroupsEdgeGroupUpdatePayload, options?: AxiosRequestConfig) {
        return EdgeGroupsApiFp(this.configuration).egeGroupUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EdgeJobsApi - axios parameter creator
 * @export
 */
export const EdgeJobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob
         * @param {'file' | 'string'} method Creation Method
         * @param {object} body for body documentation see the relevant /edge_jobs/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        edgeJobCreate: async (method: 'file' | 'string', body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'method' is not null or undefined
            assertParamExists('edgeJobCreate', 'method', method)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('edgeJobCreate', 'body', body)
            const localVarPath = `/edge_jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a file
         * @param {File} file Content of the Stack file
         * @param {string} name Name of the stack
         * @param {string} cronExpression A cron expression to schedule this job
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {string} endpoints JSON stringified array of Environment ids
         * @param {boolean} [recurring] If recurring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateFile: async (file: File, name: string, cronExpression: string, edgeGroups: string, endpoints: string, recurring?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('edgeJobCreateFile', 'file', file)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('edgeJobCreateFile', 'name', name)
            // verify required parameter 'cronExpression' is not null or undefined
            assertParamExists('edgeJobCreateFile', 'cronExpression', cronExpression)
            // verify required parameter 'edgeGroups' is not null or undefined
            assertParamExists('edgeJobCreateFile', 'edgeGroups', edgeGroups)
            // verify required parameter 'endpoints' is not null or undefined
            assertParamExists('edgeJobCreateFile', 'endpoints', endpoints)
            const localVarPath = `/edge_jobs/create/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('Name', name as any);
            }
    
            if (cronExpression !== undefined) { 
                localVarFormParams.append('CronExpression', cronExpression as any);
            }
    
            if (edgeGroups !== undefined) { 
                localVarFormParams.append('EdgeGroups', edgeGroups as any);
            }
    
            if (endpoints !== undefined) { 
                localVarFormParams.append('Endpoints', endpoints as any);
            }
    
            if (recurring !== undefined) { 
                localVarFormParams.append('Recurring', recurring as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a text
         * @param {EdgejobsEdgeJobCreateFromFileContentPayload} body EdgeGroup data when method is string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateString: async (body: EdgejobsEdgeJobCreateFromFileContentPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('edgeJobCreateString', 'body', body)
            const localVarPath = `/edge_jobs/create/string`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeJobDelete', 'id', id)
            const localVarPath = `/edge_jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch a file of an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobFile: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeJobFile', 'id', id)
            const localVarPath = `/edge_jobs/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobInspect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeJobInspect', 'id', id)
            const localVarPath = `/edge_jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch EdgeJobs list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/edge_jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTaskLogsInspect: async (id: number, taskID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeJobTaskLogsInspect', 'id', id)
            // verify required parameter 'taskID' is not null or undefined
            assertParamExists('edgeJobTaskLogsInspect', 'taskID', taskID)
            const localVarPath = `/edge_jobs/{id}/tasks/{taskID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Clear the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksClear: async (id: number, taskID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeJobTasksClear', 'id', id)
            // verify required parameter 'taskID' is not null or undefined
            assertParamExists('edgeJobTasksClear', 'taskID', taskID)
            const localVarPath = `/edge_jobs/{id}/tasks/{taskID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Collect the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksCollect: async (id: number, taskID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeJobTasksCollect', 'id', id)
            // verify required parameter 'taskID' is not null or undefined
            assertParamExists('edgeJobTasksCollect', 'taskID', taskID)
            const localVarPath = `/edge_jobs/{id}/tasks/{taskID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"taskID"}}`, encodeURIComponent(String(taskID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the list of tasks on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksList: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeJobTasksList', 'id', id)
            const localVarPath = `/edge_jobs/{id}/tasks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {EdgejobsEdgeJobUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobUpdate: async (id: number, body: EdgejobsEdgeJobUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeJobUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('edgeJobUpdate', 'body', body)
            const localVarPath = `/edge_jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EdgeJobsApi - functional programming interface
 * @export
 */
export const EdgeJobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EdgeJobsApiAxiosParamCreator(configuration)
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob
         * @param {'file' | 'string'} method Creation Method
         * @param {object} body for body documentation see the relevant /edge_jobs/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async edgeJobCreate(method: 'file' | 'string', body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeJobCreate(method, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a file
         * @param {File} file Content of the Stack file
         * @param {string} name Name of the stack
         * @param {string} cronExpression A cron expression to schedule this job
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {string} endpoints JSON stringified array of Environment ids
         * @param {boolean} [recurring] If recurring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeJobCreateFile(file: File, name: string, cronExpression: string, edgeGroups: string, endpoints: string, recurring?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeJobCreateFile(file, name, cronExpression, edgeGroups, endpoints, recurring, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a text
         * @param {EdgejobsEdgeJobCreateFromFileContentPayload} body EdgeGroup data when method is string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeJobCreateString(body: EdgejobsEdgeJobCreateFromFileContentPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeJobCreateString(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeJobDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeJobDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch a file of an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeJobFile(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EdgejobsEdgeJobFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeJobFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeJobInspect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeJobInspect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch EdgeJobs list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeJobList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerEdgeJob>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeJobList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeJobTaskLogsInspect(id: number, taskID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EdgejobsFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeJobTaskLogsInspect(id, taskID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Clear the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeJobTasksClear(id: number, taskID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeJobTasksClear(id, taskID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Collect the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeJobTasksCollect(id: number, taskID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeJobTasksCollect(id, taskID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the list of tasks on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeJobTasksList(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EdgejobsTaskContainer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeJobTasksList(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {EdgejobsEdgeJobUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeJobUpdate(id: number, body: EdgejobsEdgeJobUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeJobUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EdgeJobsApi - factory interface
 * @export
 */
export const EdgeJobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EdgeJobsApiFp(configuration)
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob
         * @param {'file' | 'string'} method Creation Method
         * @param {object} body for body documentation see the relevant /edge_jobs/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        edgeJobCreate(method: 'file' | 'string', body: object, options?: any): AxiosPromise<PortainerEdgeGroup> {
            return localVarFp.edgeJobCreate(method, body, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a file
         * @param {File} file Content of the Stack file
         * @param {string} name Name of the stack
         * @param {string} cronExpression A cron expression to schedule this job
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {string} endpoints JSON stringified array of Environment ids
         * @param {boolean} [recurring] If recurring
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateFile(file: File, name: string, cronExpression: string, edgeGroups: string, endpoints: string, recurring?: boolean, options?: any): AxiosPromise<PortainerEdgeGroup> {
            return localVarFp.edgeJobCreateFile(file, name, cronExpression, edgeGroups, endpoints, recurring, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeJob from a text
         * @param {EdgejobsEdgeJobCreateFromFileContentPayload} body EdgeGroup data when method is string
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobCreateString(body: EdgejobsEdgeJobCreateFromFileContentPayload, options?: any): AxiosPromise<PortainerEdgeGroup> {
            return localVarFp.edgeJobCreateString(body, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.edgeJobDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch a file of an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobFile(id: number, options?: any): AxiosPromise<EdgejobsEdgeJobFileResponse> {
            return localVarFp.edgeJobFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobInspect(id: number, options?: any): AxiosPromise<PortainerEdgeJob> {
            return localVarFp.edgeJobInspect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch EdgeJobs list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobList(options?: any): AxiosPromise<Array<PortainerEdgeJob>> {
            return localVarFp.edgeJobList(options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTaskLogsInspect(id: number, taskID: number, options?: any): AxiosPromise<EdgejobsFileResponse> {
            return localVarFp.edgeJobTaskLogsInspect(id, taskID, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Clear the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksClear(id: number, taskID: number, options?: any): AxiosPromise<void> {
            return localVarFp.edgeJobTasksClear(id, taskID, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Collect the log for a specifc task on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {number} taskID Task Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksCollect(id: number, taskID: number, options?: any): AxiosPromise<void> {
            return localVarFp.edgeJobTasksCollect(id, taskID, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Fetch the list of tasks on an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobTasksList(id: number, options?: any): AxiosPromise<Array<EdgejobsTaskContainer>> {
            return localVarFp.edgeJobTasksList(id, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeJob
         * @param {number} id EdgeJob Id
         * @param {EdgejobsEdgeJobUpdatePayload} body EdgeGroup data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeJobUpdate(id: number, body: EdgejobsEdgeJobUpdatePayload, options?: any): AxiosPromise<PortainerEdgeJob> {
            return localVarFp.edgeJobUpdate(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EdgeJobsApi - object-oriented interface
 * @export
 * @class EdgeJobsApi
 * @extends {BaseAPI}
 */
export class EdgeJobsApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Create an EdgeJob
     * @param {'file' | 'string'} method Creation Method
     * @param {object} body for body documentation see the relevant /edge_jobs/create/{method} endpoint
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobCreate(method: 'file' | 'string', body: object, options?: AxiosRequestConfig) {
        return EdgeJobsApiFp(this.configuration).edgeJobCreate(method, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Create an EdgeJob from a file
     * @param {File} file Content of the Stack file
     * @param {string} name Name of the stack
     * @param {string} cronExpression A cron expression to schedule this job
     * @param {string} edgeGroups JSON stringified array of Edge Groups ids
     * @param {string} endpoints JSON stringified array of Environment ids
     * @param {boolean} [recurring] If recurring
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobCreateFile(file: File, name: string, cronExpression: string, edgeGroups: string, endpoints: string, recurring?: boolean, options?: AxiosRequestConfig) {
        return EdgeJobsApiFp(this.configuration).edgeJobCreateFile(file, name, cronExpression, edgeGroups, endpoints, recurring, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Create an EdgeJob from a text
     * @param {EdgejobsEdgeJobCreateFromFileContentPayload} body EdgeGroup data when method is string
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobCreateString(body: EdgejobsEdgeJobCreateFromFileContentPayload, options?: AxiosRequestConfig) {
        return EdgeJobsApiFp(this.configuration).edgeJobCreateString(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Delete an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobDelete(id: number, options?: AxiosRequestConfig) {
        return EdgeJobsApiFp(this.configuration).edgeJobDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Fetch a file of an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobFile(id: number, options?: AxiosRequestConfig) {
        return EdgeJobsApiFp(this.configuration).edgeJobFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Inspect an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobInspect(id: number, options?: AxiosRequestConfig) {
        return EdgeJobsApiFp(this.configuration).edgeJobInspect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Fetch EdgeJobs list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobList(options?: AxiosRequestConfig) {
        return EdgeJobsApiFp(this.configuration).edgeJobList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Fetch the log for a specifc task on an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {number} taskID Task Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobTaskLogsInspect(id: number, taskID: number, options?: AxiosRequestConfig) {
        return EdgeJobsApiFp(this.configuration).edgeJobTaskLogsInspect(id, taskID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Clear the log for a specifc task on an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {number} taskID Task Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobTasksClear(id: number, taskID: number, options?: AxiosRequestConfig) {
        return EdgeJobsApiFp(this.configuration).edgeJobTasksClear(id, taskID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Collect the log for a specifc task on an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {number} taskID Task Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobTasksCollect(id: number, taskID: number, options?: AxiosRequestConfig) {
        return EdgeJobsApiFp(this.configuration).edgeJobTasksCollect(id, taskID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Fetch the list of tasks on an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobTasksList(id: number, options?: AxiosRequestConfig) {
        return EdgeJobsApiFp(this.configuration).edgeJobTasksList(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Update an EdgeJob
     * @param {number} id EdgeJob Id
     * @param {EdgejobsEdgeJobUpdatePayload} body EdgeGroup data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeJobsApi
     */
    public edgeJobUpdate(id: number, body: EdgejobsEdgeJobUpdatePayload, options?: AxiosRequestConfig) {
        return EdgeJobsApiFp(this.configuration).edgeJobUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EdgeStacksApi - axios parameter creator
 * @export
 */
export const EdgeStacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack
         * @param {'file' | 'string' | 'repository'} method Creation Method
         * @param {object} body for body documentation see the relevant /edge_stacks/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        edgeStackCreate: async (method: 'file' | 'string' | 'repository', body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'method' is not null or undefined
            assertParamExists('edgeStackCreate', 'method', method)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('edgeStackCreate', 'body', body)
            const localVarPath = `/edge_stacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from file
         * @param {string} name Name of the stack
         * @param {File} file Content of the Stack file
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {number} deploymentType deploy type 0 - \\\&#39;compose\\\&#39;, 1 - \\\&#39;kubernetes\\\&#39;, 2 - \\\&#39;nomad\\\&#39;
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {string} [registries] JSON stringified array of Registry ids to use for this stack
         * @param {boolean} [useManifestNamespaces] Uses the manifest\\\&#39;s namespaces instead of the default one, relevant only for kube environments
         * @param {boolean} [prePullImage] Pre Pull image
         * @param {boolean} [retryDeploy] Retry deploy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateFile: async (name: string, file: File, edgeGroups: string, deploymentType: number, dryrun?: string, registries?: string, useManifestNamespaces?: boolean, prePullImage?: boolean, retryDeploy?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('edgeStackCreateFile', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('edgeStackCreateFile', 'file', file)
            // verify required parameter 'edgeGroups' is not null or undefined
            assertParamExists('edgeStackCreateFile', 'edgeGroups', edgeGroups)
            // verify required parameter 'deploymentType' is not null or undefined
            assertParamExists('edgeStackCreateFile', 'deploymentType', deploymentType)
            const localVarPath = `/edge_stacks/create/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (dryrun !== undefined) {
                localVarQueryParameter['dryrun'] = dryrun;
            }


            if (name !== undefined) { 
                localVarFormParams.append('Name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (edgeGroups !== undefined) { 
                localVarFormParams.append('EdgeGroups', edgeGroups as any);
            }
    
            if (deploymentType !== undefined) { 
                localVarFormParams.append('DeploymentType', deploymentType as any);
            }
    
            if (registries !== undefined) { 
                localVarFormParams.append('Registries', registries as any);
            }
    
            if (useManifestNamespaces !== undefined) { 
                localVarFormParams.append('UseManifestNamespaces', useManifestNamespaces as any);
            }
    
            if (prePullImage !== undefined) { 
                localVarFormParams.append('PrePullImage', prePullImage as any);
            }
    
            if (retryDeploy !== undefined) { 
                localVarFormParams.append('RetryDeploy', retryDeploy as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a git repository
         * @param {EdgestacksEdgeStackFromGitRepositoryPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateRepository: async (body: EdgestacksEdgeStackFromGitRepositoryPayload, dryrun?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('edgeStackCreateRepository', 'body', body)
            const localVarPath = `/edge_stacks/create/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (dryrun !== undefined) {
                localVarQueryParameter['dryrun'] = dryrun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a text
         * @param {EdgestacksEdgeStackFromStringPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateString: async (body: EdgestacksEdgeStackFromStringPayload, dryrun?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('edgeStackCreateString', 'body', body)
            const localVarPath = `/edge_stacks/create/string`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (dryrun !== undefined) {
                localVarQueryParameter['dryrun'] = dryrun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeStackDelete', 'id', id)
            const localVarPath = `/edge_stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the stack file for an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackFile: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeStackFile', 'id', id)
            const localVarPath = `/edge_stacks/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackInspect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeStackInspect', 'id', id)
            const localVarPath = `/edge_stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of EdgeStacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/edge_stacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Delete an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {number} environmentId Environment identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        edgeStackStatusDelete: async (id: number, environmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeStackStatusDelete', 'id', id)
            // verify required parameter 'environmentId' is not null or undefined
            assertParamExists('edgeStackStatusDelete', 'environmentId', environmentId)
            const localVarPath = `/edge_stacks/{id}/status/{environmentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"environmentId"}}`, encodeURIComponent(String(environmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Update an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateStatusPayload} body EdgeStack status payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackStatusUpdate: async (id: number, body: EdgestacksUpdateStatusPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeStackStatusUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('edgeStackStatusUpdate', 'body', body)
            const localVarPath = `/edge_stacks/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateEdgeStackPayload} body EdgeStack data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackUpdate: async (id: number, body: EdgestacksUpdateEdgeStackPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edgeStackUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('edgeStackUpdate', 'body', body)
            const localVarPath = `/edge_stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet: async (id: number, stackId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointsIdEdgeStacksStackIdGet', 'id', id)
            // verify required parameter 'stackId' is not null or undefined
            assertParamExists('endpointsIdEdgeStacksStackIdGet', 'stackId', stackId)
            const localVarPath = `/endpoints/{id}/edge/stacks/{stackId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"stackId"}}`, encodeURIComponent(String(stackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EdgeStacksApi - functional programming interface
 * @export
 */
export const EdgeStacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EdgeStacksApiAxiosParamCreator(configuration)
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack
         * @param {'file' | 'string' | 'repository'} method Creation Method
         * @param {object} body for body documentation see the relevant /edge_stacks/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async edgeStackCreate(method: 'file' | 'string' | 'repository', body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeStackCreate(method, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from file
         * @param {string} name Name of the stack
         * @param {File} file Content of the Stack file
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {number} deploymentType deploy type 0 - \\\&#39;compose\\\&#39;, 1 - \\\&#39;kubernetes\\\&#39;, 2 - \\\&#39;nomad\\\&#39;
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {string} [registries] JSON stringified array of Registry ids to use for this stack
         * @param {boolean} [useManifestNamespaces] Uses the manifest\\\&#39;s namespaces instead of the default one, relevant only for kube environments
         * @param {boolean} [prePullImage] Pre Pull image
         * @param {boolean} [retryDeploy] Retry deploy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeStackCreateFile(name: string, file: File, edgeGroups: string, deploymentType: number, dryrun?: string, registries?: string, useManifestNamespaces?: boolean, prePullImage?: boolean, retryDeploy?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeStackCreateFile(name, file, edgeGroups, deploymentType, dryrun, registries, useManifestNamespaces, prePullImage, retryDeploy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a git repository
         * @param {EdgestacksEdgeStackFromGitRepositoryPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeStackCreateRepository(body: EdgestacksEdgeStackFromGitRepositoryPayload, dryrun?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeStackCreateRepository(body, dryrun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a text
         * @param {EdgestacksEdgeStackFromStringPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeStackCreateString(body: EdgestacksEdgeStackFromStringPayload, dryrun?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeStackCreateString(body, dryrun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeStackDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeStackDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the stack file for an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeStackFile(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EdgestacksStackFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeStackFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeStackInspect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeStackInspect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of EdgeStacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeStackList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerEdgeStack>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeStackList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Delete an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {number} environmentId Environment identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async edgeStackStatusDelete(id: number, environmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeStackStatusDelete(id, environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Update an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateStatusPayload} body EdgeStack status payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeStackStatusUpdate(id: number, body: EdgestacksUpdateStatusPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeStackStatusUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateEdgeStackPayload} body EdgeStack data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edgeStackUpdate(id: number, body: EdgestacksUpdateEdgeStackPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEdgeStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeStackUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EdgeStackPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsIdEdgeStacksStackIdGet(id, stackId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EdgeStacksApi - factory interface
 * @export
 */
export const EdgeStacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EdgeStacksApiFp(configuration)
    return {
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack
         * @param {'file' | 'string' | 'repository'} method Creation Method
         * @param {object} body for body documentation see the relevant /edge_stacks/create/{method} endpoint
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        edgeStackCreate(method: 'file' | 'string' | 'repository', body: object, options?: any): AxiosPromise<PortainerEdgeStack> {
            return localVarFp.edgeStackCreate(method, body, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from file
         * @param {string} name Name of the stack
         * @param {File} file Content of the Stack file
         * @param {string} edgeGroups JSON stringified array of Edge Groups ids
         * @param {number} deploymentType deploy type 0 - \\\&#39;compose\\\&#39;, 1 - \\\&#39;kubernetes\\\&#39;, 2 - \\\&#39;nomad\\\&#39;
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {string} [registries] JSON stringified array of Registry ids to use for this stack
         * @param {boolean} [useManifestNamespaces] Uses the manifest\\\&#39;s namespaces instead of the default one, relevant only for kube environments
         * @param {boolean} [prePullImage] Pre Pull image
         * @param {boolean} [retryDeploy] Retry deploy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateFile(name: string, file: File, edgeGroups: string, deploymentType: number, dryrun?: string, registries?: string, useManifestNamespaces?: boolean, prePullImage?: boolean, retryDeploy?: boolean, options?: any): AxiosPromise<PortainerEdgeStack> {
            return localVarFp.edgeStackCreateFile(name, file, edgeGroups, deploymentType, dryrun, registries, useManifestNamespaces, prePullImage, retryDeploy, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a git repository
         * @param {EdgestacksEdgeStackFromGitRepositoryPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateRepository(body: EdgestacksEdgeStackFromGitRepositoryPayload, dryrun?: string, options?: any): AxiosPromise<PortainerEdgeStack> {
            return localVarFp.edgeStackCreateRepository(body, dryrun, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Create an EdgeStack from a text
         * @param {EdgestacksEdgeStackFromStringPayload} body stack config
         * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackCreateString(body: EdgestacksEdgeStackFromStringPayload, dryrun?: string, options?: any): AxiosPromise<PortainerEdgeStack> {
            return localVarFp.edgeStackCreateString(body, dryrun, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Delete an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.edgeStackDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the stack file for an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackFile(id: number, options?: any): AxiosPromise<EdgestacksStackFileResponse> {
            return localVarFp.edgeStackFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Inspect an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackInspect(id: number, options?: any): AxiosPromise<PortainerEdgeStack> {
            return localVarFp.edgeStackInspect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of EdgeStacks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackList(options?: any): AxiosPromise<Array<PortainerEdgeStack>> {
            return localVarFp.edgeStackList(options).then((request) => request(axios, basePath));
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Delete an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {number} environmentId Environment identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        edgeStackStatusDelete(id: number, environmentId: number, options?: any): AxiosPromise<PortainerEdgeStack> {
            return localVarFp.edgeStackStatusDelete(id, environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Authorized only if the request is done by an Edge Environment(Endpoint)
         * @summary Update an EdgeStack status
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateStatusPayload} body EdgeStack status payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackStatusUpdate(id: number, body: EdgestacksUpdateStatusPayload, options?: any): AxiosPromise<PortainerEdgeStack> {
            return localVarFp.edgeStackStatusUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Update an EdgeStack
         * @param {number} id EdgeStack Id
         * @param {EdgestacksUpdateEdgeStackPayload} body EdgeStack data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edgeStackUpdate(id: number, body: EdgestacksUpdateEdgeStackPayload, options?: any): AxiosPromise<PortainerEdgeStack> {
            return localVarFp.edgeStackUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: any): AxiosPromise<EdgeStackPayload> {
            return localVarFp.endpointsIdEdgeStacksStackIdGet(id, stackId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EdgeStacksApi - object-oriented interface
 * @export
 * @class EdgeStacksApi
 * @extends {BaseAPI}
 */
export class EdgeStacksApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Create an EdgeStack
     * @param {'file' | 'string' | 'repository'} method Creation Method
     * @param {object} body for body documentation see the relevant /edge_stacks/create/{method} endpoint
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackCreate(method: 'file' | 'string' | 'repository', body: object, options?: AxiosRequestConfig) {
        return EdgeStacksApiFp(this.configuration).edgeStackCreate(method, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Create an EdgeStack from file
     * @param {string} name Name of the stack
     * @param {File} file Content of the Stack file
     * @param {string} edgeGroups JSON stringified array of Edge Groups ids
     * @param {number} deploymentType deploy type 0 - \\\&#39;compose\\\&#39;, 1 - \\\&#39;kubernetes\\\&#39;, 2 - \\\&#39;nomad\\\&#39;
     * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
     * @param {string} [registries] JSON stringified array of Registry ids to use for this stack
     * @param {boolean} [useManifestNamespaces] Uses the manifest\\\&#39;s namespaces instead of the default one, relevant only for kube environments
     * @param {boolean} [prePullImage] Pre Pull image
     * @param {boolean} [retryDeploy] Retry deploy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackCreateFile(name: string, file: File, edgeGroups: string, deploymentType: number, dryrun?: string, registries?: string, useManifestNamespaces?: boolean, prePullImage?: boolean, retryDeploy?: boolean, options?: AxiosRequestConfig) {
        return EdgeStacksApiFp(this.configuration).edgeStackCreateFile(name, file, edgeGroups, deploymentType, dryrun, registries, useManifestNamespaces, prePullImage, retryDeploy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Create an EdgeStack from a git repository
     * @param {EdgestacksEdgeStackFromGitRepositoryPayload} body stack config
     * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackCreateRepository(body: EdgestacksEdgeStackFromGitRepositoryPayload, dryrun?: string, options?: AxiosRequestConfig) {
        return EdgeStacksApiFp(this.configuration).edgeStackCreateRepository(body, dryrun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Create an EdgeStack from a text
     * @param {EdgestacksEdgeStackFromStringPayload} body stack config
     * @param {string} [dryrun] if true, will not create an edge stack, but just will check the settings and return a non-persisted edge stack object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackCreateString(body: EdgestacksEdgeStackFromStringPayload, dryrun?: string, options?: AxiosRequestConfig) {
        return EdgeStacksApiFp(this.configuration).edgeStackCreateString(body, dryrun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Delete an EdgeStack
     * @param {number} id EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackDelete(id: number, options?: AxiosRequestConfig) {
        return EdgeStacksApiFp(this.configuration).edgeStackDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Fetches the stack file for an EdgeStack
     * @param {number} id EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackFile(id: number, options?: AxiosRequestConfig) {
        return EdgeStacksApiFp(this.configuration).edgeStackFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Inspect an EdgeStack
     * @param {number} id EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackInspect(id: number, options?: AxiosRequestConfig) {
        return EdgeStacksApiFp(this.configuration).edgeStackInspect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Fetches the list of EdgeStacks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackList(options?: AxiosRequestConfig) {
        return EdgeStacksApiFp(this.configuration).edgeStackList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authorized only if the request is done by an Edge Environment(Endpoint)
     * @summary Delete an EdgeStack status
     * @param {number} id EdgeStack Id
     * @param {number} environmentId Environment identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackStatusDelete(id: number, environmentId: number, options?: AxiosRequestConfig) {
        return EdgeStacksApiFp(this.configuration).edgeStackStatusDelete(id, environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authorized only if the request is done by an Edge Environment(Endpoint)
     * @summary Update an EdgeStack status
     * @param {number} id EdgeStack Id
     * @param {EdgestacksUpdateStatusPayload} body EdgeStack status payload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackStatusUpdate(id: number, body: EdgestacksUpdateStatusPayload, options?: AxiosRequestConfig) {
        return EdgeStacksApiFp(this.configuration).edgeStackStatusUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Update an EdgeStack
     * @param {number} id EdgeStack Id
     * @param {EdgestacksUpdateEdgeStackPayload} body EdgeStack data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public edgeStackUpdate(id: number, body: EdgestacksUpdateEdgeStackPayload, options?: AxiosRequestConfig) {
        return EdgeStacksApiFp(this.configuration).edgeStackUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: public
     * @summary Inspect an Edge Stack for an Environment(Endpoint)
     * @param {number} id environment(endpoint) Id
     * @param {number} stackId EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeStacksApi
     */
    public endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: AxiosRequestConfig) {
        return EdgeStacksApiFp(this.configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EdgeTemplatesApi - axios parameter creator
 * @export
 */
export const EdgeTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of Edge Templates
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        edgeTemplateList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/edge_templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EdgeTemplatesApi - functional programming interface
 * @export
 */
export const EdgeTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EdgeTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of Edge Templates
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async edgeTemplateList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edgeTemplateList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EdgeTemplatesApi - factory interface
 * @export
 */
export const EdgeTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EdgeTemplatesApiFp(configuration)
    return {
        /**
         * **Access policy**: administrator
         * @summary Fetches the list of Edge Templates
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        edgeTemplateList(options?: any): AxiosPromise<Array<PortainerTemplate>> {
            return localVarFp.edgeTemplateList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EdgeTemplatesApi - object-oriented interface
 * @export
 * @class EdgeTemplatesApi
 * @extends {BaseAPI}
 */
export class EdgeTemplatesApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Fetches the list of Edge Templates
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EdgeTemplatesApi
     */
    public edgeTemplateList(options?: AxiosRequestConfig) {
        return EdgeTemplatesApiFp(this.configuration).edgeTemplateList(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EndpointGroupsApi - axios parameter creator
 * @export
 */
export const EndpointGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add an environment(endpoint) to an environment(endpoint) group **Access policy**: administrator
         * @summary Add an environment(endpoint) to an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupAddEndpoint: async (id: number, endpointId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointGroupAddEndpoint', 'id', id)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('endpointGroupAddEndpoint', 'endpointId', endpointId)
            const localVarPath = `/endpoint_groups/{id}/endpoints/{endpointId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"endpointId"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an environment(endpoint) group. **Access policy**: administrator
         * @summary Remove an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointGroupDelete', 'id', id)
            const localVarPath = `/endpoint_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: administrator
         * @summary Removes environment(endpoint) from an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDeleteEndpoint: async (id: number, endpointId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointGroupDeleteEndpoint', 'id', id)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('endpointGroupDeleteEndpoint', 'endpointId', endpointId)
            const localVarPath = `/endpoint_groups/{id}/endpoints/{endpointId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"endpointId"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all environment(endpoint) groups based on the current user authorizations. Will return all environment(endpoint) groups if using an administrator account otherwise it will only return authorized environment(endpoint) groups. **Access policy**: restricted
         * @summary List Environment(Endpoint) groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/endpoint_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an environment(endpoint) group. **Access policy**: administrator
         * @summary Update an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {EndpointgroupsEndpointGroupUpdatePayload} body EndpointGroup details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupUpdate: async (id: number, body: EndpointgroupsEndpointGroupUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointGroupUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('endpointGroupUpdate', 'body', body)
            const localVarPath = `/endpoint_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details abont an environment(endpoint) group. **Access policy**: administrator
         * @summary Inspect an Environment(Endpoint) group
         * @param {number} id Environment(Endpoint) group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsIdGet: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointGroupsIdGet', 'id', id)
            const localVarPath = `/endpoint_groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new environment(endpoint) group. **Access policy**: administrator
         * @summary Create an Environment(Endpoint) Group
         * @param {EndpointgroupsEndpointGroupCreatePayload} body Environment(Endpoint) Group details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsPost: async (body: EndpointgroupsEndpointGroupCreatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('endpointGroupsPost', 'body', body)
            const localVarPath = `/endpoint_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EndpointGroupsApi - functional programming interface
 * @export
 */
export const EndpointGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EndpointGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add an environment(endpoint) to an environment(endpoint) group **Access policy**: administrator
         * @summary Add an environment(endpoint) to an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointGroupAddEndpoint(id: number, endpointId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointGroupAddEndpoint(id, endpointId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove an environment(endpoint) group. **Access policy**: administrator
         * @summary Remove an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointGroupDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointGroupDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: administrator
         * @summary Removes environment(endpoint) from an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointGroupDeleteEndpoint(id: number, endpointId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointGroupDeleteEndpoint(id, endpointId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all environment(endpoint) groups based on the current user authorizations. Will return all environment(endpoint) groups if using an administrator account otherwise it will only return authorized environment(endpoint) groups. **Access policy**: restricted
         * @summary List Environment(Endpoint) groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointGroupList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerEndpointGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointGroupList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an environment(endpoint) group. **Access policy**: administrator
         * @summary Update an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {EndpointgroupsEndpointGroupUpdatePayload} body EndpointGroup details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointGroupUpdate(id: number, body: EndpointgroupsEndpointGroupUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEndpointGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointGroupUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve details abont an environment(endpoint) group. **Access policy**: administrator
         * @summary Inspect an Environment(Endpoint) group
         * @param {number} id Environment(Endpoint) group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointGroupsIdGet(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEndpointGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointGroupsIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new environment(endpoint) group. **Access policy**: administrator
         * @summary Create an Environment(Endpoint) Group
         * @param {EndpointgroupsEndpointGroupCreatePayload} body Environment(Endpoint) Group details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointGroupsPost(body: EndpointgroupsEndpointGroupCreatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEndpointGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointGroupsPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EndpointGroupsApi - factory interface
 * @export
 */
export const EndpointGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EndpointGroupsApiFp(configuration)
    return {
        /**
         * Add an environment(endpoint) to an environment(endpoint) group **Access policy**: administrator
         * @summary Add an environment(endpoint) to an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupAddEndpoint(id: number, endpointId: number, options?: any): AxiosPromise<void> {
            return localVarFp.endpointGroupAddEndpoint(id, endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an environment(endpoint) group. **Access policy**: administrator
         * @summary Remove an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.endpointGroupDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: administrator
         * @summary Removes environment(endpoint) from an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {number} endpointId Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupDeleteEndpoint(id: number, endpointId: number, options?: any): AxiosPromise<void> {
            return localVarFp.endpointGroupDeleteEndpoint(id, endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all environment(endpoint) groups based on the current user authorizations. Will return all environment(endpoint) groups if using an administrator account otherwise it will only return authorized environment(endpoint) groups. **Access policy**: restricted
         * @summary List Environment(Endpoint) groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupList(options?: any): AxiosPromise<Array<PortainerEndpointGroup>> {
            return localVarFp.endpointGroupList(options).then((request) => request(axios, basePath));
        },
        /**
         * Update an environment(endpoint) group. **Access policy**: administrator
         * @summary Update an environment(endpoint) group
         * @param {number} id EndpointGroup identifier
         * @param {EndpointgroupsEndpointGroupUpdatePayload} body EndpointGroup details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupUpdate(id: number, body: EndpointgroupsEndpointGroupUpdatePayload, options?: any): AxiosPromise<PortainerEndpointGroup> {
            return localVarFp.endpointGroupUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details abont an environment(endpoint) group. **Access policy**: administrator
         * @summary Inspect an Environment(Endpoint) group
         * @param {number} id Environment(Endpoint) group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsIdGet(id: number, options?: any): AxiosPromise<PortainerEndpointGroup> {
            return localVarFp.endpointGroupsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new environment(endpoint) group. **Access policy**: administrator
         * @summary Create an Environment(Endpoint) Group
         * @param {EndpointgroupsEndpointGroupCreatePayload} body Environment(Endpoint) Group details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointGroupsPost(body: EndpointgroupsEndpointGroupCreatePayload, options?: any): AxiosPromise<PortainerEndpointGroup> {
            return localVarFp.endpointGroupsPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EndpointGroupsApi - object-oriented interface
 * @export
 * @class EndpointGroupsApi
 * @extends {BaseAPI}
 */
export class EndpointGroupsApi extends BaseAPI {
    /**
     * Add an environment(endpoint) to an environment(endpoint) group **Access policy**: administrator
     * @summary Add an environment(endpoint) to an environment(endpoint) group
     * @param {number} id EndpointGroup identifier
     * @param {number} endpointId Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    public endpointGroupAddEndpoint(id: number, endpointId: number, options?: AxiosRequestConfig) {
        return EndpointGroupsApiFp(this.configuration).endpointGroupAddEndpoint(id, endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an environment(endpoint) group. **Access policy**: administrator
     * @summary Remove an environment(endpoint) group
     * @param {number} id EndpointGroup identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    public endpointGroupDelete(id: number, options?: AxiosRequestConfig) {
        return EndpointGroupsApiFp(this.configuration).endpointGroupDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: administrator
     * @summary Removes environment(endpoint) from an environment(endpoint) group
     * @param {number} id EndpointGroup identifier
     * @param {number} endpointId Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    public endpointGroupDeleteEndpoint(id: number, endpointId: number, options?: AxiosRequestConfig) {
        return EndpointGroupsApiFp(this.configuration).endpointGroupDeleteEndpoint(id, endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all environment(endpoint) groups based on the current user authorizations. Will return all environment(endpoint) groups if using an administrator account otherwise it will only return authorized environment(endpoint) groups. **Access policy**: restricted
     * @summary List Environment(Endpoint) groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    public endpointGroupList(options?: AxiosRequestConfig) {
        return EndpointGroupsApiFp(this.configuration).endpointGroupList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an environment(endpoint) group. **Access policy**: administrator
     * @summary Update an environment(endpoint) group
     * @param {number} id EndpointGroup identifier
     * @param {EndpointgroupsEndpointGroupUpdatePayload} body EndpointGroup details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    public endpointGroupUpdate(id: number, body: EndpointgroupsEndpointGroupUpdatePayload, options?: AxiosRequestConfig) {
        return EndpointGroupsApiFp(this.configuration).endpointGroupUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details abont an environment(endpoint) group. **Access policy**: administrator
     * @summary Inspect an Environment(Endpoint) group
     * @param {number} id Environment(Endpoint) group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    public endpointGroupsIdGet(id: number, options?: AxiosRequestConfig) {
        return EndpointGroupsApiFp(this.configuration).endpointGroupsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new environment(endpoint) group. **Access policy**: administrator
     * @summary Create an Environment(Endpoint) Group
     * @param {EndpointgroupsEndpointGroupCreatePayload} body Environment(Endpoint) Group details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointGroupsApi
     */
    public endpointGroupsPost(body: EndpointgroupsEndpointGroupCreatePayload, options?: AxiosRequestConfig) {
        return EndpointGroupsApiFp(this.configuration).endpointGroupsPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EndpointsApi - axios parameter creator
 * @export
 */
export const EndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * De-association an edge environment(endpoint). **Access policy**: administrator
         * @summary De-association an edge environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointAssociationDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointAssociationDelete', 'id', id)
            const localVarPath = `/endpoints/{id}/association`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new environment(endpoint) that will be used to manage an environment(endpoint). **Access policy**: administrator
         * @summary Create a new environment(endpoint)
         * @param {string} name Name that will be used to identify this environment(endpoint) (example: my-environment)
         * @param {number} endpointCreationType Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment)
         * @param {string} edgeTunnelServerAddress URL or IP address that will be used to establish a reverse tunnel
         * @param {string} [uRL] URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment)
         * @param {string} [publicURL] URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375)
         * @param {number} [groupID] Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned).
         * @param {boolean} [tLS] Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipVerify] Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipClientVerify] Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {File} [tLSCACertFile] TLS CA certificate file
         * @param {File} [tLSCertFile] TLS client certificate file
         * @param {File} [tLSKeyFile] TLS client key file
         * @param {string} [azureApplicationID] Azure application ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureTenantID] Azure tenant ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureAuthenticationKey] Azure authentication key. Required if environment(endpoint) type is set to 3
         * @param {Array<number>} [tagIds] List of tag identifiers to which this environment(endpoint) is associated
         * @param {number} [edgeCheckinInterval] The check in interval for edge agent (in seconds)
         * @param {string} [gpus] List of GPUs - json stringified array of {name, value} structs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreate: async (name: string, endpointCreationType: number, edgeTunnelServerAddress: string, uRL?: string, publicURL?: string, groupID?: number, tLS?: boolean, tLSSkipVerify?: boolean, tLSSkipClientVerify?: boolean, tLSCACertFile?: File, tLSCertFile?: File, tLSKeyFile?: File, azureApplicationID?: string, azureTenantID?: string, azureAuthenticationKey?: string, tagIds?: Array<number>, edgeCheckinInterval?: number, gpus?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('endpointCreate', 'name', name)
            // verify required parameter 'endpointCreationType' is not null or undefined
            assertParamExists('endpointCreate', 'endpointCreationType', endpointCreationType)
            // verify required parameter 'edgeTunnelServerAddress' is not null or undefined
            assertParamExists('endpointCreate', 'edgeTunnelServerAddress', edgeTunnelServerAddress)
            const localVarPath = `/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (name !== undefined) { 
                localVarFormParams.append('Name', name as any);
            }
    
            if (endpointCreationType !== undefined) { 
                localVarFormParams.append('EndpointCreationType', endpointCreationType as any);
            }
    
            if (uRL !== undefined) { 
                localVarFormParams.append('URL', uRL as any);
            }
    
            if (publicURL !== undefined) { 
                localVarFormParams.append('PublicURL', publicURL as any);
            }
    
            if (groupID !== undefined) { 
                localVarFormParams.append('GroupID', groupID as any);
            }
    
            if (tLS !== undefined) { 
                localVarFormParams.append('TLS', tLS as any);
            }
    
            if (tLSSkipVerify !== undefined) { 
                localVarFormParams.append('TLSSkipVerify', tLSSkipVerify as any);
            }
    
            if (tLSSkipClientVerify !== undefined) { 
                localVarFormParams.append('TLSSkipClientVerify', tLSSkipClientVerify as any);
            }
    
            if (tLSCACertFile !== undefined) { 
                localVarFormParams.append('TLSCACertFile', tLSCACertFile as any);
            }
    
            if (tLSCertFile !== undefined) { 
                localVarFormParams.append('TLSCertFile', tLSCertFile as any);
            }
    
            if (tLSKeyFile !== undefined) { 
                localVarFormParams.append('TLSKeyFile', tLSKeyFile as any);
            }
    
            if (azureApplicationID !== undefined) { 
                localVarFormParams.append('AzureApplicationID', azureApplicationID as any);
            }
    
            if (azureTenantID !== undefined) { 
                localVarFormParams.append('AzureTenantID', azureTenantID as any);
            }
    
            if (azureAuthenticationKey !== undefined) { 
                localVarFormParams.append('AzureAuthenticationKey', azureAuthenticationKey as any);
            }
                if (tagIds) {
                localVarFormParams.append('TagIds', tagIds.join(COLLECTION_FORMATS.csv));
            }

    
            if (edgeCheckinInterval !== undefined) { 
                localVarFormParams.append('EdgeCheckinInterval', edgeCheckinInterval as any);
            }
    
            if (edgeTunnelServerAddress !== undefined) { 
                localVarFormParams.append('EdgeTunnelServerAddress', edgeTunnelServerAddress as any);
            }
    
            if (gpus !== undefined) { 
                localVarFormParams.append('Gpus', gpus as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or retrieve the endpoint for an EdgeID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreateGlobalKey: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/endpoints/global-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an environment(endpoint). **Access policy**: administrator
         * @summary Remove an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointDelete', 'id', id)
            const localVarPath = `/endpoints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get docker pull limits for a docker hub registry in the environment **Access policy**:
         * @summary fetch docker pull limits
         * @param {number} id endpoint ID
         * @param {number} registryId registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDockerhubStatus: async (id: number, registryId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointDockerhubStatus', 'id', id)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('endpointDockerhubStatus', 'registryId', registryId)
            const localVarPath = `/endpoints/{id}/dockerhub/{registryId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * environment(endpoint) for edge agent to check status of environment(endpoint) **Access policy**: restricted only to Edge environments(endpoints)
         * @summary Get environment(endpoint) status
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointEdgeStatusInspect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointEdgeStatusInspect', 'id', id)
            const localVarPath = `/endpoints/{id}/edge/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * force update a docker service **Access policy**: authenticated
         * @summary force update a docker service
         * @param {number} id endpoint identifier
         * @param {EndpointsForceUpdateServicePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointForceUpdateService: async (id: number, body: EndpointsForceUpdateServicePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointForceUpdateService', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('endpointForceUpdateService', 'body', body)
            const localVarPath = `/endpoints/{id}/forceupdateservice`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about an environment(endpoint). **Access policy**: restricted
         * @summary Inspect an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointInspect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointInspect', 'id', id)
            const localVarPath = `/endpoints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all environments(endpoints) based on the current user authorizations. Will return all environments(endpoints) if using an administrator or team leader account otherwise it will only return authorized environments(endpoints). **Access policy**: restricted
         * @summary List environments(endpoints)
         * @param {number} [start] Start searching from
         * @param {number} [limit] Limit results to this value
         * @param {number} [order] Order sorted results by desc/asc
         * @param {string} [search] Search query
         * @param {Array<number>} [groupIds] List environments(endpoints) of these groups
         * @param {Array<number>} [status] List environments(endpoints) by this status
         * @param {Array<number>} [types] List environments(endpoints) of this type
         * @param {Array<number>} [tagIds] search environments(endpoints) with these tags (depends on tagsPartialMatch)
         * @param {boolean} [tagsPartialMatch] If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags
         * @param {Array<number>} [endpointIds] will return only these environments(endpoints)
         * @param {boolean} [provisioned] If true, will return environment(endpoint) that were provisioned
         * @param {Array<string>} [agentVersions] will return only environments with on of these agent versions
         * @param {boolean} [edgeAsync] if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents)
         * @param {boolean} [edgeDeviceUntrusted] if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents)
         * @param {number} [edgeCheckInPassedSeconds] if bigger then zero, show only edge agents that checked-in in the last provided seconds (relevant only for edge agents)
         * @param {boolean} [excludeSnapshots] if true, the snapshot data won\&#39;t be retrieved
         * @param {string} [name] will return only environments(endpoints) with this name
         * @param {string} [edgeStackStatus] only applied when edgeStackId exists. Filter the returned environments based on their deployment status in the stack (not the environment status!)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointList: async (start?: number, limit?: number, order?: number, search?: string, groupIds?: Array<number>, status?: Array<number>, types?: Array<number>, tagIds?: Array<number>, tagsPartialMatch?: boolean, endpointIds?: Array<number>, provisioned?: boolean, agentVersions?: Array<string>, edgeAsync?: boolean, edgeDeviceUntrusted?: boolean, edgeCheckInPassedSeconds?: number, excludeSnapshots?: boolean, name?: string, edgeStackStatus?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (groupIds) {
                localVarQueryParameter['groupIds'] = groupIds;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (tagIds) {
                localVarQueryParameter['tagIds'] = tagIds;
            }

            if (tagsPartialMatch !== undefined) {
                localVarQueryParameter['tagsPartialMatch'] = tagsPartialMatch;
            }

            if (endpointIds) {
                localVarQueryParameter['endpointIds'] = endpointIds;
            }

            if (provisioned !== undefined) {
                localVarQueryParameter['provisioned'] = provisioned;
            }

            if (agentVersions) {
                localVarQueryParameter['agentVersions'] = agentVersions;
            }

            if (edgeAsync !== undefined) {
                localVarQueryParameter['edgeAsync'] = edgeAsync;
            }

            if (edgeDeviceUntrusted !== undefined) {
                localVarQueryParameter['edgeDeviceUntrusted'] = edgeDeviceUntrusted;
            }

            if (edgeCheckInPassedSeconds !== undefined) {
                localVarQueryParameter['edgeCheckInPassedSeconds'] = edgeCheckInPassedSeconds;
            }

            if (excludeSnapshots !== undefined) {
                localVarQueryParameter['excludeSnapshots'] = excludeSnapshots;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (edgeStackStatus !== undefined) {
                localVarQueryParameter['edgeStackStatus'] = edgeStackStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all registries based on the current user authorizations in current environment. **Access policy**: authenticated
         * @summary List Registries on environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] required if kubernetes environment, will show registries by namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistriesList: async (id: number, namespace?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointRegistriesList', 'id', id)
            const localVarPath = `/endpoints/{id}/registries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary update registry access for environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {number} registryId Registry identifier
         * @param {EndpointsRegistryAccessPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistryAccess: async (id: number, registryId: number, body: EndpointsRegistryAccessPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointRegistryAccess', 'id', id)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('endpointRegistryAccess', 'registryId', registryId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('endpointRegistryAccess', 'body', body)
            const localVarPath = `/endpoints/{id}/registries/{registryId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update settings for an environment(endpoint). **Access policy**: authenticated
         * @summary Update settings for an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointSettingsUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSettingsUpdate: async (id: number, body: EndpointsEndpointSettingsUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointSettingsUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('endpointSettingsUpdate', 'body', body)
            const localVarPath = `/endpoints/{id}/settings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Snapshots an environment(endpoint) **Access policy**: administrator
         * @summary Snapshots an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshot: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointSnapshot', 'id', id)
            const localVarPath = `/endpoints/{id}/snapshot`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Snapshot all environments(endpoints) **Access policy**: administrator
         * @summary Snapshot all environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshots: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/endpoints/snapshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an environment(endpoint). **Access policy**: authenticated
         * @summary Update an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdate: async (id: number, body: EndpointsEndpointUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('endpointUpdate', 'body', body)
            const localVarPath = `/endpoints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update relations for a list of environments Edge groups, tags and environment group can be updated.  **Access policy**: administrator
         * @summary Update relations for a list of environments
         * @param {EndpointsEndpointUpdateRelationsPayload} body Environment relations data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdateRelations: async (body: EndpointsEndpointUpdateRelationsPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('endpointUpdateRelations', 'body', body)
            const localVarPath = `/endpoints/relations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload a file under a specific path on the file system of an environment (endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} path The destination path to upload the file to
         * @param {File} file The file to upload
         * @param {string} [volumeID] Optional volume identifier to upload the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdDockerV2BrowsePutPost: async (id: number, path: string, file: File, volumeID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointsIdDockerV2BrowsePutPost', 'id', id)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('endpointsIdDockerV2BrowsePutPost', 'path', path)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('endpointsIdDockerV2BrowsePutPost', 'file', file)
            const localVarPath = `/endpoints/{id}/docker/v2/browse/put`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (volumeID !== undefined) {
                localVarQueryParameter['volumeID'] = volumeID;
            }


            if (path !== undefined) { 
                localVarFormParams.append('Path', path as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost: async (id: number, jobID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointsIdEdgeJobsJobIDLogsPost', 'id', id)
            // verify required parameter 'jobID' is not null or undefined
            assertParamExists('endpointsIdEdgeJobsJobIDLogsPost', 'jobID', jobID)
            const localVarPath = `/endpoints/{id}/edge/jobs/{jobID}/logs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"jobID"}}`, encodeURIComponent(String(jobID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet: async (id: number, stackId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('endpointsIdEdgeStacksStackIdGet', 'id', id)
            // verify required parameter 'stackId' is not null or undefined
            assertParamExists('endpointsIdEdgeStacksStackIdGet', 'stackId', stackId)
            const localVarPath = `/endpoints/{id}/edge/stacks/{stackId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"stackId"}}`, encodeURIComponent(String(stackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EndpointsApi - functional programming interface
 * @export
 */
export const EndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * De-association an edge environment(endpoint). **Access policy**: administrator
         * @summary De-association an edge environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointAssociationDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointAssociationDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new environment(endpoint) that will be used to manage an environment(endpoint). **Access policy**: administrator
         * @summary Create a new environment(endpoint)
         * @param {string} name Name that will be used to identify this environment(endpoint) (example: my-environment)
         * @param {number} endpointCreationType Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment)
         * @param {string} edgeTunnelServerAddress URL or IP address that will be used to establish a reverse tunnel
         * @param {string} [uRL] URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment)
         * @param {string} [publicURL] URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375)
         * @param {number} [groupID] Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned).
         * @param {boolean} [tLS] Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipVerify] Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipClientVerify] Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {File} [tLSCACertFile] TLS CA certificate file
         * @param {File} [tLSCertFile] TLS client certificate file
         * @param {File} [tLSKeyFile] TLS client key file
         * @param {string} [azureApplicationID] Azure application ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureTenantID] Azure tenant ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureAuthenticationKey] Azure authentication key. Required if environment(endpoint) type is set to 3
         * @param {Array<number>} [tagIds] List of tag identifiers to which this environment(endpoint) is associated
         * @param {number} [edgeCheckinInterval] The check in interval for edge agent (in seconds)
         * @param {string} [gpus] List of GPUs - json stringified array of {name, value} structs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointCreate(name: string, endpointCreationType: number, edgeTunnelServerAddress: string, uRL?: string, publicURL?: string, groupID?: number, tLS?: boolean, tLSSkipVerify?: boolean, tLSSkipClientVerify?: boolean, tLSCACertFile?: File, tLSCertFile?: File, tLSKeyFile?: File, azureApplicationID?: string, azureTenantID?: string, azureAuthenticationKey?: string, tagIds?: Array<number>, edgeCheckinInterval?: number, gpus?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointCreate(name, endpointCreationType, edgeTunnelServerAddress, uRL, publicURL, groupID, tLS, tLSSkipVerify, tLSSkipClientVerify, tLSCACertFile, tLSCertFile, tLSKeyFile, azureApplicationID, azureTenantID, azureAuthenticationKey, tagIds, edgeCheckinInterval, gpus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create or retrieve the endpoint for an EdgeID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointCreateGlobalKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndpointsEndpointCreateGlobalKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointCreateGlobalKey(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove an environment(endpoint). **Access policy**: administrator
         * @summary Remove an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get docker pull limits for a docker hub registry in the environment **Access policy**:
         * @summary fetch docker pull limits
         * @param {number} id endpoint ID
         * @param {number} registryId registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointDockerhubStatus(id: number, registryId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndpointsDockerhubStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointDockerhubStatus(id, registryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * environment(endpoint) for edge agent to check status of environment(endpoint) **Access policy**: restricted only to Edge environments(endpoints)
         * @summary Get environment(endpoint) status
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointEdgeStatusInspect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndpointedgeEndpointEdgeStatusInspectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointEdgeStatusInspect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * force update a docker service **Access policy**: authenticated
         * @summary force update a docker service
         * @param {number} id endpoint identifier
         * @param {EndpointsForceUpdateServicePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointForceUpdateService(id: number, body: EndpointsForceUpdateServicePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SwarmServiceUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointForceUpdateService(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve details about an environment(endpoint). **Access policy**: restricted
         * @summary Inspect an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointInspect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointInspect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all environments(endpoints) based on the current user authorizations. Will return all environments(endpoints) if using an administrator or team leader account otherwise it will only return authorized environments(endpoints). **Access policy**: restricted
         * @summary List environments(endpoints)
         * @param {number} [start] Start searching from
         * @param {number} [limit] Limit results to this value
         * @param {number} [order] Order sorted results by desc/asc
         * @param {string} [search] Search query
         * @param {Array<number>} [groupIds] List environments(endpoints) of these groups
         * @param {Array<number>} [status] List environments(endpoints) by this status
         * @param {Array<number>} [types] List environments(endpoints) of this type
         * @param {Array<number>} [tagIds] search environments(endpoints) with these tags (depends on tagsPartialMatch)
         * @param {boolean} [tagsPartialMatch] If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags
         * @param {Array<number>} [endpointIds] will return only these environments(endpoints)
         * @param {boolean} [provisioned] If true, will return environment(endpoint) that were provisioned
         * @param {Array<string>} [agentVersions] will return only environments with on of these agent versions
         * @param {boolean} [edgeAsync] if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents)
         * @param {boolean} [edgeDeviceUntrusted] if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents)
         * @param {number} [edgeCheckInPassedSeconds] if bigger then zero, show only edge agents that checked-in in the last provided seconds (relevant only for edge agents)
         * @param {boolean} [excludeSnapshots] if true, the snapshot data won\&#39;t be retrieved
         * @param {string} [name] will return only environments(endpoints) with this name
         * @param {string} [edgeStackStatus] only applied when edgeStackId exists. Filter the returned environments based on their deployment status in the stack (not the environment status!)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointList(start?: number, limit?: number, order?: number, search?: string, groupIds?: Array<number>, status?: Array<number>, types?: Array<number>, tagIds?: Array<number>, tagsPartialMatch?: boolean, endpointIds?: Array<number>, provisioned?: boolean, agentVersions?: Array<string>, edgeAsync?: boolean, edgeDeviceUntrusted?: boolean, edgeCheckInPassedSeconds?: number, excludeSnapshots?: boolean, name?: string, edgeStackStatus?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerEndpoint>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointList(start, limit, order, search, groupIds, status, types, tagIds, tagsPartialMatch, endpointIds, provisioned, agentVersions, edgeAsync, edgeDeviceUntrusted, edgeCheckInPassedSeconds, excludeSnapshots, name, edgeStackStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all registries based on the current user authorizations in current environment. **Access policy**: authenticated
         * @summary List Registries on environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] required if kubernetes environment, will show registries by namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointRegistriesList(id: number, namespace?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerRegistry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointRegistriesList(id, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: authenticated
         * @summary update registry access for environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {number} registryId Registry identifier
         * @param {EndpointsRegistryAccessPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointRegistryAccess(id: number, registryId: number, body: EndpointsRegistryAccessPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointRegistryAccess(id, registryId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update settings for an environment(endpoint). **Access policy**: authenticated
         * @summary Update settings for an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointSettingsUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointSettingsUpdate(id: number, body: EndpointsEndpointSettingsUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointSettingsUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Snapshots an environment(endpoint) **Access policy**: administrator
         * @summary Snapshots an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointSnapshot(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointSnapshot(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Snapshot all environments(endpoints) **Access policy**: administrator
         * @summary Snapshot all environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointSnapshots(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointSnapshots(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an environment(endpoint). **Access policy**: authenticated
         * @summary Update an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointUpdate(id: number, body: EndpointsEndpointUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update relations for a list of environments Edge groups, tags and environment group can be updated.  **Access policy**: administrator
         * @summary Update relations for a list of environments
         * @param {EndpointsEndpointUpdateRelationsPayload} body Environment relations data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointUpdateRelations(body: EndpointsEndpointUpdateRelationsPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointUpdateRelations(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload a file under a specific path on the file system of an environment (endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} path The destination path to upload the file to
         * @param {File} file The file to upload
         * @param {string} [volumeID] Optional volume identifier to upload the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointsIdDockerV2BrowsePutPost(id: number, path: string, file: File, volumeID?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsIdDockerV2BrowsePutPost(id, path, file, volumeID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointsIdEdgeJobsJobIDLogsPost(id: number, jobID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EdgeStackPayload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsIdEdgeStacksStackIdGet(id, stackId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EndpointsApi - factory interface
 * @export
 */
export const EndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EndpointsApiFp(configuration)
    return {
        /**
         * De-association an edge environment(endpoint). **Access policy**: administrator
         * @summary De-association an edge environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointAssociationDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.endpointAssociationDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new environment(endpoint) that will be used to manage an environment(endpoint). **Access policy**: administrator
         * @summary Create a new environment(endpoint)
         * @param {string} name Name that will be used to identify this environment(endpoint) (example: my-environment)
         * @param {number} endpointCreationType Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment)
         * @param {string} edgeTunnelServerAddress URL or IP address that will be used to establish a reverse tunnel
         * @param {string} [uRL] URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment)
         * @param {string} [publicURL] URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375)
         * @param {number} [groupID] Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned).
         * @param {boolean} [tLS] Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipVerify] Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {boolean} [tLSSkipClientVerify] Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
         * @param {File} [tLSCACertFile] TLS CA certificate file
         * @param {File} [tLSCertFile] TLS client certificate file
         * @param {File} [tLSKeyFile] TLS client key file
         * @param {string} [azureApplicationID] Azure application ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureTenantID] Azure tenant ID. Required if environment(endpoint) type is set to 3
         * @param {string} [azureAuthenticationKey] Azure authentication key. Required if environment(endpoint) type is set to 3
         * @param {Array<number>} [tagIds] List of tag identifiers to which this environment(endpoint) is associated
         * @param {number} [edgeCheckinInterval] The check in interval for edge agent (in seconds)
         * @param {string} [gpus] List of GPUs - json stringified array of {name, value} structs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreate(name: string, endpointCreationType: number, edgeTunnelServerAddress: string, uRL?: string, publicURL?: string, groupID?: number, tLS?: boolean, tLSSkipVerify?: boolean, tLSSkipClientVerify?: boolean, tLSCACertFile?: File, tLSCertFile?: File, tLSKeyFile?: File, azureApplicationID?: string, azureTenantID?: string, azureAuthenticationKey?: string, tagIds?: Array<number>, edgeCheckinInterval?: number, gpus?: string, options?: any): AxiosPromise<PortainerEndpoint> {
            return localVarFp.endpointCreate(name, endpointCreationType, edgeTunnelServerAddress, uRL, publicURL, groupID, tLS, tLSSkipVerify, tLSSkipClientVerify, tLSCACertFile, tLSCertFile, tLSKeyFile, azureApplicationID, azureTenantID, azureAuthenticationKey, tagIds, edgeCheckinInterval, gpus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create or retrieve the endpoint for an EdgeID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointCreateGlobalKey(options?: any): AxiosPromise<EndpointsEndpointCreateGlobalKeyResponse> {
            return localVarFp.endpointCreateGlobalKey(options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an environment(endpoint). **Access policy**: administrator
         * @summary Remove an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.endpointDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * get docker pull limits for a docker hub registry in the environment **Access policy**:
         * @summary fetch docker pull limits
         * @param {number} id endpoint ID
         * @param {number} registryId registry ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointDockerhubStatus(id: number, registryId: number, options?: any): AxiosPromise<EndpointsDockerhubStatusResponse> {
            return localVarFp.endpointDockerhubStatus(id, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * environment(endpoint) for edge agent to check status of environment(endpoint) **Access policy**: restricted only to Edge environments(endpoints)
         * @summary Get environment(endpoint) status
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointEdgeStatusInspect(id: number, options?: any): AxiosPromise<EndpointedgeEndpointEdgeStatusInspectResponse> {
            return localVarFp.endpointEdgeStatusInspect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * force update a docker service **Access policy**: authenticated
         * @summary force update a docker service
         * @param {number} id endpoint identifier
         * @param {EndpointsForceUpdateServicePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointForceUpdateService(id: number, body: EndpointsForceUpdateServicePayload, options?: any): AxiosPromise<SwarmServiceUpdateResponse> {
            return localVarFp.endpointForceUpdateService(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details about an environment(endpoint). **Access policy**: restricted
         * @summary Inspect an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointInspect(id: number, options?: any): AxiosPromise<PortainerEndpoint> {
            return localVarFp.endpointInspect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all environments(endpoints) based on the current user authorizations. Will return all environments(endpoints) if using an administrator or team leader account otherwise it will only return authorized environments(endpoints). **Access policy**: restricted
         * @summary List environments(endpoints)
         * @param {number} [start] Start searching from
         * @param {number} [limit] Limit results to this value
         * @param {number} [order] Order sorted results by desc/asc
         * @param {string} [search] Search query
         * @param {Array<number>} [groupIds] List environments(endpoints) of these groups
         * @param {Array<number>} [status] List environments(endpoints) by this status
         * @param {Array<number>} [types] List environments(endpoints) of this type
         * @param {Array<number>} [tagIds] search environments(endpoints) with these tags (depends on tagsPartialMatch)
         * @param {boolean} [tagsPartialMatch] If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags
         * @param {Array<number>} [endpointIds] will return only these environments(endpoints)
         * @param {boolean} [provisioned] If true, will return environment(endpoint) that were provisioned
         * @param {Array<string>} [agentVersions] will return only environments with on of these agent versions
         * @param {boolean} [edgeAsync] if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents)
         * @param {boolean} [edgeDeviceUntrusted] if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents)
         * @param {number} [edgeCheckInPassedSeconds] if bigger then zero, show only edge agents that checked-in in the last provided seconds (relevant only for edge agents)
         * @param {boolean} [excludeSnapshots] if true, the snapshot data won\&#39;t be retrieved
         * @param {string} [name] will return only environments(endpoints) with this name
         * @param {string} [edgeStackStatus] only applied when edgeStackId exists. Filter the returned environments based on their deployment status in the stack (not the environment status!)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointList(start?: number, limit?: number, order?: number, search?: string, groupIds?: Array<number>, status?: Array<number>, types?: Array<number>, tagIds?: Array<number>, tagsPartialMatch?: boolean, endpointIds?: Array<number>, provisioned?: boolean, agentVersions?: Array<string>, edgeAsync?: boolean, edgeDeviceUntrusted?: boolean, edgeCheckInPassedSeconds?: number, excludeSnapshots?: boolean, name?: string, edgeStackStatus?: string, options?: any): AxiosPromise<Array<PortainerEndpoint>> {
            return localVarFp.endpointList(start, limit, order, search, groupIds, status, types, tagIds, tagsPartialMatch, endpointIds, provisioned, agentVersions, edgeAsync, edgeDeviceUntrusted, edgeCheckInPassedSeconds, excludeSnapshots, name, edgeStackStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * List all registries based on the current user authorizations in current environment. **Access policy**: authenticated
         * @summary List Registries on environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] required if kubernetes environment, will show registries by namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistriesList(id: number, namespace?: string, options?: any): AxiosPromise<Array<PortainerRegistry>> {
            return localVarFp.endpointRegistriesList(id, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: authenticated
         * @summary update registry access for environment
         * @param {number} id Environment(Endpoint) identifier
         * @param {number} registryId Registry identifier
         * @param {EndpointsRegistryAccessPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointRegistryAccess(id: number, registryId: number, body: EndpointsRegistryAccessPayload, options?: any): AxiosPromise<void> {
            return localVarFp.endpointRegistryAccess(id, registryId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update settings for an environment(endpoint). **Access policy**: authenticated
         * @summary Update settings for an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointSettingsUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSettingsUpdate(id: number, body: EndpointsEndpointSettingsUpdatePayload, options?: any): AxiosPromise<PortainerEndpoint> {
            return localVarFp.endpointSettingsUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Snapshots an environment(endpoint) **Access policy**: administrator
         * @summary Snapshots an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshot(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.endpointSnapshot(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Snapshot all environments(endpoints) **Access policy**: administrator
         * @summary Snapshot all environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointSnapshots(options?: any): AxiosPromise<void> {
            return localVarFp.endpointSnapshots(options).then((request) => request(axios, basePath));
        },
        /**
         * Update an environment(endpoint). **Access policy**: authenticated
         * @summary Update an environment(endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {EndpointsEndpointUpdatePayload} body Environment(Endpoint) details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdate(id: number, body: EndpointsEndpointUpdatePayload, options?: any): AxiosPromise<PortainerEndpoint> {
            return localVarFp.endpointUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update relations for a list of environments Edge groups, tags and environment group can be updated.  **Access policy**: administrator
         * @summary Update relations for a list of environments
         * @param {EndpointsEndpointUpdateRelationsPayload} body Environment relations data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointUpdateRelations(body: EndpointsEndpointUpdateRelationsPayload, options?: any): AxiosPromise<void> {
            return localVarFp.endpointUpdateRelations(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload a file under a specific path on the file system of an environment (endpoint)
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} path The destination path to upload the file to
         * @param {File} file The file to upload
         * @param {string} [volumeID] Optional volume identifier to upload the file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdDockerV2BrowsePutPost(id: number, path: string, file: File, volumeID?: string, options?: any): AxiosPromise<void> {
            return localVarFp.endpointsIdDockerV2BrowsePutPost(id, path, file, volumeID, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: public
         * @summary Inspect an EdgeJob Log
         * @param {number} id environment(endpoint) Id
         * @param {number} jobID Job Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeJobsJobIDLogsPost(id: number, jobID: number, options?: any): AxiosPromise<void> {
            return localVarFp.endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: public
         * @summary Inspect an Edge Stack for an Environment(Endpoint)
         * @param {number} id environment(endpoint) Id
         * @param {number} stackId EdgeStack Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: any): AxiosPromise<EdgeStackPayload> {
            return localVarFp.endpointsIdEdgeStacksStackIdGet(id, stackId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EndpointsApi - object-oriented interface
 * @export
 * @class EndpointsApi
 * @extends {BaseAPI}
 */
export class EndpointsApi extends BaseAPI {
    /**
     * De-association an edge environment(endpoint). **Access policy**: administrator
     * @summary De-association an edge environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointAssociationDelete(id: number, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointAssociationDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new environment(endpoint) that will be used to manage an environment(endpoint). **Access policy**: administrator
     * @summary Create a new environment(endpoint)
     * @param {string} name Name that will be used to identify this environment(endpoint) (example: my-environment)
     * @param {number} endpointCreationType Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment)
     * @param {string} edgeTunnelServerAddress URL or IP address that will be used to establish a reverse tunnel
     * @param {string} [uRL] URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment)
     * @param {string} [publicURL] URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375)
     * @param {number} [groupID] Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned).
     * @param {boolean} [tLS] Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment)
     * @param {boolean} [tLSSkipVerify] Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
     * @param {boolean} [tLSSkipClientVerify] Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment)
     * @param {File} [tLSCACertFile] TLS CA certificate file
     * @param {File} [tLSCertFile] TLS client certificate file
     * @param {File} [tLSKeyFile] TLS client key file
     * @param {string} [azureApplicationID] Azure application ID. Required if environment(endpoint) type is set to 3
     * @param {string} [azureTenantID] Azure tenant ID. Required if environment(endpoint) type is set to 3
     * @param {string} [azureAuthenticationKey] Azure authentication key. Required if environment(endpoint) type is set to 3
     * @param {Array<number>} [tagIds] List of tag identifiers to which this environment(endpoint) is associated
     * @param {number} [edgeCheckinInterval] The check in interval for edge agent (in seconds)
     * @param {string} [gpus] List of GPUs - json stringified array of {name, value} structs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointCreate(name: string, endpointCreationType: number, edgeTunnelServerAddress: string, uRL?: string, publicURL?: string, groupID?: number, tLS?: boolean, tLSSkipVerify?: boolean, tLSSkipClientVerify?: boolean, tLSCACertFile?: File, tLSCertFile?: File, tLSKeyFile?: File, azureApplicationID?: string, azureTenantID?: string, azureAuthenticationKey?: string, tagIds?: Array<number>, edgeCheckinInterval?: number, gpus?: string, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointCreate(name, endpointCreationType, edgeTunnelServerAddress, uRL, publicURL, groupID, tLS, tLSSkipVerify, tLSSkipClientVerify, tLSCACertFile, tLSCertFile, tLSKeyFile, azureApplicationID, azureTenantID, azureAuthenticationKey, tagIds, edgeCheckinInterval, gpus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create or retrieve the endpoint for an EdgeID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointCreateGlobalKey(options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointCreateGlobalKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an environment(endpoint). **Access policy**: administrator
     * @summary Remove an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointDelete(id: number, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get docker pull limits for a docker hub registry in the environment **Access policy**:
     * @summary fetch docker pull limits
     * @param {number} id endpoint ID
     * @param {number} registryId registry ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointDockerhubStatus(id: number, registryId: number, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointDockerhubStatus(id, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * environment(endpoint) for edge agent to check status of environment(endpoint) **Access policy**: restricted only to Edge environments(endpoints)
     * @summary Get environment(endpoint) status
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointEdgeStatusInspect(id: number, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointEdgeStatusInspect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * force update a docker service **Access policy**: authenticated
     * @summary force update a docker service
     * @param {number} id endpoint identifier
     * @param {EndpointsForceUpdateServicePayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointForceUpdateService(id: number, body: EndpointsForceUpdateServicePayload, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointForceUpdateService(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details about an environment(endpoint). **Access policy**: restricted
     * @summary Inspect an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointInspect(id: number, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointInspect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all environments(endpoints) based on the current user authorizations. Will return all environments(endpoints) if using an administrator or team leader account otherwise it will only return authorized environments(endpoints). **Access policy**: restricted
     * @summary List environments(endpoints)
     * @param {number} [start] Start searching from
     * @param {number} [limit] Limit results to this value
     * @param {number} [order] Order sorted results by desc/asc
     * @param {string} [search] Search query
     * @param {Array<number>} [groupIds] List environments(endpoints) of these groups
     * @param {Array<number>} [status] List environments(endpoints) by this status
     * @param {Array<number>} [types] List environments(endpoints) of this type
     * @param {Array<number>} [tagIds] search environments(endpoints) with these tags (depends on tagsPartialMatch)
     * @param {boolean} [tagsPartialMatch] If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags
     * @param {Array<number>} [endpointIds] will return only these environments(endpoints)
     * @param {boolean} [provisioned] If true, will return environment(endpoint) that were provisioned
     * @param {Array<string>} [agentVersions] will return only environments with on of these agent versions
     * @param {boolean} [edgeAsync] if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents)
     * @param {boolean} [edgeDeviceUntrusted] if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents)
     * @param {number} [edgeCheckInPassedSeconds] if bigger then zero, show only edge agents that checked-in in the last provided seconds (relevant only for edge agents)
     * @param {boolean} [excludeSnapshots] if true, the snapshot data won\&#39;t be retrieved
     * @param {string} [name] will return only environments(endpoints) with this name
     * @param {string} [edgeStackStatus] only applied when edgeStackId exists. Filter the returned environments based on their deployment status in the stack (not the environment status!)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointList(start?: number, limit?: number, order?: number, search?: string, groupIds?: Array<number>, status?: Array<number>, types?: Array<number>, tagIds?: Array<number>, tagsPartialMatch?: boolean, endpointIds?: Array<number>, provisioned?: boolean, agentVersions?: Array<string>, edgeAsync?: boolean, edgeDeviceUntrusted?: boolean, edgeCheckInPassedSeconds?: number, excludeSnapshots?: boolean, name?: string, edgeStackStatus?: string, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointList(start, limit, order, search, groupIds, status, types, tagIds, tagsPartialMatch, endpointIds, provisioned, agentVersions, edgeAsync, edgeDeviceUntrusted, edgeCheckInPassedSeconds, excludeSnapshots, name, edgeStackStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all registries based on the current user authorizations in current environment. **Access policy**: authenticated
     * @summary List Registries on environment
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} [namespace] required if kubernetes environment, will show registries by namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointRegistriesList(id: number, namespace?: string, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointRegistriesList(id, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: authenticated
     * @summary update registry access for environment
     * @param {number} id Environment(Endpoint) identifier
     * @param {number} registryId Registry identifier
     * @param {EndpointsRegistryAccessPayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointRegistryAccess(id: number, registryId: number, body: EndpointsRegistryAccessPayload, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointRegistryAccess(id, registryId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update settings for an environment(endpoint). **Access policy**: authenticated
     * @summary Update settings for an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {EndpointsEndpointSettingsUpdatePayload} body Environment(Endpoint) details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointSettingsUpdate(id: number, body: EndpointsEndpointSettingsUpdatePayload, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointSettingsUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Snapshots an environment(endpoint) **Access policy**: administrator
     * @summary Snapshots an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointSnapshot(id: number, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointSnapshot(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Snapshot all environments(endpoints) **Access policy**: administrator
     * @summary Snapshot all environments(endpoints)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointSnapshots(options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointSnapshots(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an environment(endpoint). **Access policy**: authenticated
     * @summary Update an environment(endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {EndpointsEndpointUpdatePayload} body Environment(Endpoint) details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointUpdate(id: number, body: EndpointsEndpointUpdatePayload, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update relations for a list of environments Edge groups, tags and environment group can be updated.  **Access policy**: administrator
     * @summary Update relations for a list of environments
     * @param {EndpointsEndpointUpdateRelationsPayload} body Environment relations data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointUpdateRelations(body: EndpointsEndpointUpdateRelationsPayload, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointUpdateRelations(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
     * @summary Upload a file under a specific path on the file system of an environment (endpoint)
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} path The destination path to upload the file to
     * @param {File} file The file to upload
     * @param {string} [volumeID] Optional volume identifier to upload the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsIdDockerV2BrowsePutPost(id: number, path: string, file: File, volumeID?: string, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointsIdDockerV2BrowsePutPost(id, path, file, volumeID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: public
     * @summary Inspect an EdgeJob Log
     * @param {number} id environment(endpoint) Id
     * @param {number} jobID Job Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsIdEdgeJobsJobIDLogsPost(id: number, jobID: number, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointsIdEdgeJobsJobIDLogsPost(id, jobID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: public
     * @summary Inspect an Edge Stack for an Environment(Endpoint)
     * @param {number} id environment(endpoint) Id
     * @param {number} stackId EdgeStack Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsIdEdgeStacksStackIdGet(id: number, stackId: number, options?: AxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointsIdEdgeStacksStackIdGet(id, stackId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GitopsApi - axios parameter creator
 * @export
 */
export const GitopsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the compose file content based on git repository configuration **Access policy**: authenticated
         * @summary preview the content of target file in the git repository
         * @param {GitopsRepositoryFilePreviewPayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitOperationRepoFilePreview: async (body: GitopsRepositoryFilePreviewPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('gitOperationRepoFilePreview', 'body', body)
            const localVarPath = `/gitops/repo/file/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GitopsApi - functional programming interface
 * @export
 */
export const GitopsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GitopsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the compose file content based on git repository configuration **Access policy**: authenticated
         * @summary preview the content of target file in the git repository
         * @param {GitopsRepositoryFilePreviewPayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gitOperationRepoFilePreview(body: GitopsRepositoryFilePreviewPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GitopsFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gitOperationRepoFilePreview(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GitopsApi - factory interface
 * @export
 */
export const GitopsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GitopsApiFp(configuration)
    return {
        /**
         * Retrieve the compose file content based on git repository configuration **Access policy**: authenticated
         * @summary preview the content of target file in the git repository
         * @param {GitopsRepositoryFilePreviewPayload} body Template details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gitOperationRepoFilePreview(body: GitopsRepositoryFilePreviewPayload, options?: any): AxiosPromise<GitopsFileResponse> {
            return localVarFp.gitOperationRepoFilePreview(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GitopsApi - object-oriented interface
 * @export
 * @class GitopsApi
 * @extends {BaseAPI}
 */
export class GitopsApi extends BaseAPI {
    /**
     * Retrieve the compose file content based on git repository configuration **Access policy**: authenticated
     * @summary preview the content of target file in the git repository
     * @param {GitopsRepositoryFilePreviewPayload} body Template details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GitopsApi
     */
    public gitOperationRepoFilePreview(body: GitopsRepositoryFilePreviewPayload, options?: AxiosRequestConfig) {
        return GitopsApiFp(this.configuration).gitOperationRepoFilePreview(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HelmApi - axios parameter creator
 * @export
 */
export const HelmApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary Delete Helm Release
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} release The name of the release/application to uninstall
         * @param {string} [namespace] An optional namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmDelete: async (id: number, release: string, namespace?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('helmDelete', 'id', id)
            // verify required parameter 'release' is not null or undefined
            assertParamExists('helmDelete', 'release', release)
            const localVarPath = `/endpoints/{id}/kubernetes/helm/{release}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"release"}}`, encodeURIComponent(String(release)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Install Helm Chart
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmInstallChartPayload} payload Chart details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmInstall: async (id: number, payload: HelmInstallChartPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('helmInstall', 'id', id)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('helmInstall', 'payload', payload)
            const localVarPath = `/endpoints/{id}/kubernetes/helm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary List Helm Releases
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] specify an optional namespace
         * @param {string} [filter] specify an optional filter
         * @param {string} [selector] specify an optional selector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmList: async (id: number, namespace?: string, filter?: string, selector?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('helmList', 'id', id)
            const localVarPath = `/endpoints/{id}/kubernetes/helm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (selector !== undefined) {
                localVarQueryParameter['selector'] = selector;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Search Helm Charts
         * @param {string} repo Helm repository URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmRepoSearch: async (repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('helmRepoSearch', 'repo', repo)
            const localVarPath = `/templates/helm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (repo !== undefined) {
                localVarQueryParameter['repo'] = repo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Show Helm Chart Information
         * @param {string} repo Helm repository URL
         * @param {string} chart Chart name
         * @param {string} command chart/values/readme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmShow: async (repo: string, chart: string, command: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('helmShow', 'repo', repo)
            // verify required parameter 'chart' is not null or undefined
            assertParamExists('helmShow', 'chart', chart)
            // verify required parameter 'command' is not null or undefined
            assertParamExists('helmShow', 'command', command)
            const localVarPath = `/templates/helm/{command}`
                .replace(`{${"command"}}`, encodeURIComponent(String(command)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (repo !== undefined) {
                localVarQueryParameter['repo'] = repo;
            }

            if (chart !== undefined) {
                localVarQueryParameter['chart'] = chart;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoriesList: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('helmUserRepositoriesList', 'id', id)
            const localVarPath = `/users/{id}/helm/repositories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        helmUserRepositoriesListDeprecated: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('helmUserRepositoriesListDeprecated', 'id', id)
            const localVarPath = `/endpoints/{id}/kubernetes/helm/repositories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id User identifier
         * @param {UsersAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryCreate: async (id: number, payload: UsersAddHelmRepoUrlPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('helmUserRepositoryCreate', 'id', id)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('helmUserRepositoryCreate', 'payload', payload)
            const localVarPath = `/users/{id}/helm/repositories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        helmUserRepositoryCreateDeprecated: async (id: number, payload: HelmAddHelmRepoUrlPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('helmUserRepositoryCreateDeprecated', 'id', id)
            // verify required parameter 'payload' is not null or undefined
            assertParamExists('helmUserRepositoryCreateDeprecated', 'payload', payload)
            const localVarPath = `/endpoints/{id}/kubernetes/helm/repositories`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a users helm repositoryies
         * @param {number} id User identifier
         * @param {number} repositoryID Repository identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryDelete: async (id: number, repositoryID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('helmUserRepositoryDelete', 'id', id)
            // verify required parameter 'repositoryID' is not null or undefined
            assertParamExists('helmUserRepositoryDelete', 'repositoryID', repositoryID)
            const localVarPath = `/users/{id}/helm/repositories/{repositoryID}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"repositoryID"}}`, encodeURIComponent(String(repositoryID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelmApi - functional programming interface
 * @export
 */
export const HelmApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelmApiAxiosParamCreator(configuration)
    return {
        /**
         * **Access policy**: authenticated
         * @summary Delete Helm Release
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} release The name of the release/application to uninstall
         * @param {string} [namespace] An optional namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helmDelete(id: number, release: string, namespace?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helmDelete(id, release, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: authenticated
         * @summary Install Helm Chart
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmInstallChartPayload} payload Chart details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helmInstall(id: number, payload: HelmInstallChartPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReleaseRelease>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helmInstall(id, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: authenticated
         * @summary List Helm Releases
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] specify an optional namespace
         * @param {string} [filter] specify an optional filter
         * @param {string} [selector] specify an optional selector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helmList(id: number, namespace?: string, filter?: string, selector?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ReleaseReleaseElement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helmList(id, namespace, filter, selector, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: authenticated
         * @summary Search Helm Charts
         * @param {string} repo Helm repository URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helmRepoSearch(repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helmRepoSearch(repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: authenticated
         * @summary Show Helm Chart Information
         * @param {string} repo Helm repository URL
         * @param {string} chart Chart name
         * @param {string} command chart/values/readme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helmShow(repo: string, chart: string, command: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helmShow(repo, chart, command, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helmUserRepositoriesList(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersHelmUserRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helmUserRepositoriesList(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async helmUserRepositoriesListDeprecated(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelmHelmUserRepositoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helmUserRepositoriesListDeprecated(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id User identifier
         * @param {UsersAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helmUserRepositoryCreate(id: number, payload: UsersAddHelmRepoUrlPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerHelmUserRepository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helmUserRepositoryCreate(id, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async helmUserRepositoryCreateDeprecated(id: number, payload: HelmAddHelmRepoUrlPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerHelmUserRepository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helmUserRepositoryCreateDeprecated(id, payload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a users helm repositoryies
         * @param {number} id User identifier
         * @param {number} repositoryID Repository identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helmUserRepositoryDelete(id: number, repositoryID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helmUserRepositoryDelete(id, repositoryID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HelmApi - factory interface
 * @export
 */
export const HelmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelmApiFp(configuration)
    return {
        /**
         * **Access policy**: authenticated
         * @summary Delete Helm Release
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} release The name of the release/application to uninstall
         * @param {string} [namespace] An optional namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmDelete(id: number, release: string, namespace?: string, options?: any): AxiosPromise<void> {
            return localVarFp.helmDelete(id, release, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: authenticated
         * @summary Install Helm Chart
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmInstallChartPayload} payload Chart details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmInstall(id: number, payload: HelmInstallChartPayload, options?: any): AxiosPromise<ReleaseRelease> {
            return localVarFp.helmInstall(id, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: authenticated
         * @summary List Helm Releases
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} [namespace] specify an optional namespace
         * @param {string} [filter] specify an optional filter
         * @param {string} [selector] specify an optional selector
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmList(id: number, namespace?: string, filter?: string, selector?: string, options?: any): AxiosPromise<Array<ReleaseReleaseElement>> {
            return localVarFp.helmList(id, namespace, filter, selector, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: authenticated
         * @summary Search Helm Charts
         * @param {string} repo Helm repository URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmRepoSearch(repo: string, options?: any): AxiosPromise<string> {
            return localVarFp.helmRepoSearch(repo, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: authenticated
         * @summary Show Helm Chart Information
         * @param {string} repo Helm repository URL
         * @param {string} chart Chart name
         * @param {string} command chart/values/readme
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmShow(repo: string, chart: string, command: string, options?: any): AxiosPromise<string> {
            return localVarFp.helmShow(repo, chart, command, options).then((request) => request(axios, basePath));
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoriesList(id: number, options?: any): AxiosPromise<UsersHelmUserRepositoryResponse> {
            return localVarFp.helmUserRepositoriesList(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Inspect a user helm repositories. **Access policy**: authenticated
         * @summary List a users helm repositories
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        helmUserRepositoriesListDeprecated(id: number, options?: any): AxiosPromise<HelmHelmUserRepositoryResponse> {
            return localVarFp.helmUserRepositoriesListDeprecated(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id User identifier
         * @param {UsersAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryCreate(id: number, payload: UsersAddHelmRepoUrlPayload, options?: any): AxiosPromise<PortainerHelmUserRepository> {
            return localVarFp.helmUserRepositoryCreate(id, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a user helm repository. **Access policy**: authenticated
         * @summary Create a user helm repository
         * @param {number} id Environment(Endpoint) identifier
         * @param {HelmAddHelmRepoUrlPayload} payload Helm Repository
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        helmUserRepositoryCreateDeprecated(id: number, payload: HelmAddHelmRepoUrlPayload, options?: any): AxiosPromise<PortainerHelmUserRepository> {
            return localVarFp.helmUserRepositoryCreateDeprecated(id, payload, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a users helm repositoryies
         * @param {number} id User identifier
         * @param {number} repositoryID Repository identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helmUserRepositoryDelete(id: number, repositoryID: number, options?: any): AxiosPromise<void> {
            return localVarFp.helmUserRepositoryDelete(id, repositoryID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelmApi - object-oriented interface
 * @export
 * @class HelmApi
 * @extends {BaseAPI}
 */
export class HelmApi extends BaseAPI {
    /**
     * **Access policy**: authenticated
     * @summary Delete Helm Release
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} release The name of the release/application to uninstall
     * @param {string} [namespace] An optional namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmDelete(id: number, release: string, namespace?: string, options?: AxiosRequestConfig) {
        return HelmApiFp(this.configuration).helmDelete(id, release, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: authenticated
     * @summary Install Helm Chart
     * @param {number} id Environment(Endpoint) identifier
     * @param {HelmInstallChartPayload} payload Chart details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmInstall(id: number, payload: HelmInstallChartPayload, options?: AxiosRequestConfig) {
        return HelmApiFp(this.configuration).helmInstall(id, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: authenticated
     * @summary List Helm Releases
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} [namespace] specify an optional namespace
     * @param {string} [filter] specify an optional filter
     * @param {string} [selector] specify an optional selector
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmList(id: number, namespace?: string, filter?: string, selector?: string, options?: AxiosRequestConfig) {
        return HelmApiFp(this.configuration).helmList(id, namespace, filter, selector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: authenticated
     * @summary Search Helm Charts
     * @param {string} repo Helm repository URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmRepoSearch(repo: string, options?: AxiosRequestConfig) {
        return HelmApiFp(this.configuration).helmRepoSearch(repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: authenticated
     * @summary Show Helm Chart Information
     * @param {string} repo Helm repository URL
     * @param {string} chart Chart name
     * @param {string} command chart/values/readme
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmShow(repo: string, chart: string, command: string, options?: AxiosRequestConfig) {
        return HelmApiFp(this.configuration).helmShow(repo, chart, command, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inspect a user helm repositories. **Access policy**: authenticated
     * @summary List a users helm repositories
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmUserRepositoriesList(id: number, options?: AxiosRequestConfig) {
        return HelmApiFp(this.configuration).helmUserRepositoriesList(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inspect a user helm repositories. **Access policy**: authenticated
     * @summary List a users helm repositories
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmUserRepositoriesListDeprecated(id: number, options?: AxiosRequestConfig) {
        return HelmApiFp(this.configuration).helmUserRepositoriesListDeprecated(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a user helm repository. **Access policy**: authenticated
     * @summary Create a user helm repository
     * @param {number} id User identifier
     * @param {UsersAddHelmRepoUrlPayload} payload Helm Repository
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmUserRepositoryCreate(id: number, payload: UsersAddHelmRepoUrlPayload, options?: AxiosRequestConfig) {
        return HelmApiFp(this.configuration).helmUserRepositoryCreate(id, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a user helm repository. **Access policy**: authenticated
     * @summary Create a user helm repository
     * @param {number} id Environment(Endpoint) identifier
     * @param {HelmAddHelmRepoUrlPayload} payload Helm Repository
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmUserRepositoryCreateDeprecated(id: number, payload: HelmAddHelmRepoUrlPayload, options?: AxiosRequestConfig) {
        return HelmApiFp(this.configuration).helmUserRepositoryCreateDeprecated(id, payload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: authenticated
     * @summary Delete a users helm repositoryies
     * @param {number} id User identifier
     * @param {number} repositoryID Repository identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelmApi
     */
    public helmUserRepositoryDelete(id: number, repositoryID: number, options?: AxiosRequestConfig) {
        return HelmApiFp(this.configuration).helmUserRepositoryDelete(id, repositoryID, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IntelApi - axios parameter creator
 * @export
 */
export const IntelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * creates a new FDO Profile **Access policy**: administrator
         * @summary creates a new FDO Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fdo/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * deletes a FDO Profile **Access policy**: administrator
         * @summary deletes a FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProfile', 'id', id)
            const localVarPath = `/fdo/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute out of band action on an AMT managed device **Access policy**: administrator
         * @summary Execute out of band action on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceActionPayload} body Device Action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAction: async (id: number, deviceId: number, body: OpenamtDeviceActionPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deviceAction', 'id', id)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('deviceAction', 'deviceId', deviceId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('deviceAction', 'body', body)
            const localVarPath = `/open_amt/{id}/devices/{deviceId}/action`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable features on an AMT managed device **Access policy**: administrator
         * @summary Enable features on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceFeaturesPayload} body Device Features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceFeatures: async (id: number, deviceId: number, body: OpenamtDeviceFeaturesPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deviceFeatures', 'id', id)
            // verify required parameter 'deviceId' is not null or undefined
            assertParamExists('deviceFeatures', 'deviceId', deviceId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('deviceFeatures', 'body', body)
            const localVarPath = `/open_amt/{id}/devices_features/{deviceId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * duplicated an existing FDO Profile **Access policy**: administrator
         * @summary duplicated an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicate: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('duplicate', 'id', id)
            const localVarPath = `/fdo/profiles/{id}/duplicate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable Portainer\'s FDO capabilities **Access policy**: administrator
         * @summary Enable Portainer\'s FDO capabilities
         * @param {FdoFdoConfigurePayload} body FDO Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigure: async (body: FdoFdoConfigurePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('fdoConfigure', 'body', body)
            const localVarPath = `/fdo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * configures an FDO device **Access policy**: administrator
         * @summary configures an FDO device
         * @param {number} guid Guid
         * @param {FdoDeviceConfigurePayload} body Device Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigureDevice: async (guid: number, body: FdoDeviceConfigurePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'guid' is not null or undefined
            assertParamExists('fdoConfigureDevice', 'guid', guid)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('fdoConfigureDevice', 'body', body)
            const localVarPath = `/fdo/configure/{guid}`
                .replace(`{${"guid"}}`, encodeURIComponent(String(guid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all known FDO vouchers **Access policy**: administrator
         * @summary List all known FDO vouchers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoListAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fdo/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * retrieves a given FDO profile information and content **Access policy**: administrator
         * @summary retrieves a given FDO profile information and content
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileInspect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fdoProfileInspect', 'id', id)
            const localVarPath = `/fdo/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * retrieves all FDO profiles **Access policy**: administrator
         * @summary retrieves all FDO profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fdo/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * register an FDO device **Access policy**: administrator
         * @summary register an FDO device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoRegisterDevice: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fdo/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activate OpenAMT device and associate to agent endpoint **Access policy**: administrator
         * @summary Activate OpenAMT device and associate to agent endpoint
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTActivate: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('openAMTActivate', 'id', id)
            const localVarPath = `/open_amt/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable Portainer\'s OpenAMT capabilities **Access policy**: administrator
         * @summary Enable Portainer\'s OpenAMT capabilities
         * @param {OpenamtOpenAMTConfigurePayload} body OpenAMT Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTConfigure: async (body: OpenamtOpenAMTConfigurePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('openAMTConfigure', 'body', body)
            const localVarPath = `/open_amt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch OpenAMT managed devices information for endpoint **Access policy**: administrator
         * @summary Fetch OpenAMT managed devices information for endpoint
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTDevices: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('openAMTDevices', 'id', id)
            const localVarPath = `/open_amt/{id}/devices`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request OpenAMT info from a node **Access policy**: administrator
         * @summary Request OpenAMT info from a node
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTHostInfo: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('openAMTHostInfo', 'id', id)
            const localVarPath = `/open_amt/{id}/info`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * updates an existing FDO Profile **Access policy**: administrator
         * @summary updates an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProfile', 'id', id)
            const localVarPath = `/fdo/profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntelApi - functional programming interface
 * @export
 */
export const IntelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntelApiAxiosParamCreator(configuration)
    return {
        /**
         * creates a new FDO Profile **Access policy**: administrator
         * @summary creates a new FDO Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfile(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfile(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * deletes a FDO Profile **Access policy**: administrator
         * @summary deletes a FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfile(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Execute out of band action on an AMT managed device **Access policy**: administrator
         * @summary Execute out of band action on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceActionPayload} body Device Action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceAction(id: number, deviceId: number, body: OpenamtDeviceActionPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deviceAction(id, deviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable features on an AMT managed device **Access policy**: administrator
         * @summary Enable features on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceFeaturesPayload} body Device Features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceFeatures(id: number, deviceId: number, body: OpenamtDeviceFeaturesPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deviceFeatures(id, deviceId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * duplicated an existing FDO Profile **Access policy**: administrator
         * @summary duplicated an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async duplicate(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.duplicate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable Portainer\'s FDO capabilities **Access policy**: administrator
         * @summary Enable Portainer\'s FDO capabilities
         * @param {FdoFdoConfigurePayload} body FDO Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fdoConfigure(body: FdoFdoConfigurePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fdoConfigure(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * configures an FDO device **Access policy**: administrator
         * @summary configures an FDO device
         * @param {number} guid Guid
         * @param {FdoDeviceConfigurePayload} body Device Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fdoConfigureDevice(guid: number, body: FdoDeviceConfigurePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fdoConfigureDevice(guid, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all known FDO vouchers **Access policy**: administrator
         * @summary List all known FDO vouchers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fdoListAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fdoListAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * retrieves a given FDO profile information and content **Access policy**: administrator
         * @summary retrieves a given FDO profile information and content
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fdoProfileInspect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fdoProfileInspect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * retrieves all FDO profiles **Access policy**: administrator
         * @summary retrieves all FDO profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fdoProfileList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fdoProfileList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * register an FDO device **Access policy**: administrator
         * @summary register an FDO device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fdoRegisterDevice(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fdoRegisterDevice(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Activate OpenAMT device and associate to agent endpoint **Access policy**: administrator
         * @summary Activate OpenAMT device and associate to agent endpoint
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openAMTActivate(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openAMTActivate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable Portainer\'s OpenAMT capabilities **Access policy**: administrator
         * @summary Enable Portainer\'s OpenAMT capabilities
         * @param {OpenamtOpenAMTConfigurePayload} body OpenAMT Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openAMTConfigure(body: OpenamtOpenAMTConfigurePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openAMTConfigure(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetch OpenAMT managed devices information for endpoint **Access policy**: administrator
         * @summary Fetch OpenAMT managed devices information for endpoint
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openAMTDevices(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openAMTDevices(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Request OpenAMT info from a node **Access policy**: administrator
         * @summary Request OpenAMT info from a node
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openAMTHostInfo(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openAMTHostInfo(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * updates an existing FDO Profile **Access policy**: administrator
         * @summary updates an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfile(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IntelApi - factory interface
 * @export
 */
export const IntelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntelApiFp(configuration)
    return {
        /**
         * creates a new FDO Profile **Access policy**: administrator
         * @summary creates a new FDO Profile
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfile(options?: any): AxiosPromise<void> {
            return localVarFp.createProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * deletes a FDO Profile **Access policy**: administrator
         * @summary deletes a FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfile(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProfile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute out of band action on an AMT managed device **Access policy**: administrator
         * @summary Execute out of band action on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceActionPayload} body Device Action
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceAction(id: number, deviceId: number, body: OpenamtDeviceActionPayload, options?: any): AxiosPromise<void> {
            return localVarFp.deviceAction(id, deviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable features on an AMT managed device **Access policy**: administrator
         * @summary Enable features on an AMT managed device
         * @param {number} id Environment identifier
         * @param {number} deviceId Device identifier
         * @param {OpenamtDeviceFeaturesPayload} body Device Features
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceFeatures(id: number, deviceId: number, body: OpenamtDeviceFeaturesPayload, options?: any): AxiosPromise<void> {
            return localVarFp.deviceFeatures(id, deviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * duplicated an existing FDO Profile **Access policy**: administrator
         * @summary duplicated an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicate(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.duplicate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable Portainer\'s FDO capabilities **Access policy**: administrator
         * @summary Enable Portainer\'s FDO capabilities
         * @param {FdoFdoConfigurePayload} body FDO Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigure(body: FdoFdoConfigurePayload, options?: any): AxiosPromise<void> {
            return localVarFp.fdoConfigure(body, options).then((request) => request(axios, basePath));
        },
        /**
         * configures an FDO device **Access policy**: administrator
         * @summary configures an FDO device
         * @param {number} guid Guid
         * @param {FdoDeviceConfigurePayload} body Device Configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoConfigureDevice(guid: number, body: FdoDeviceConfigurePayload, options?: any): AxiosPromise<void> {
            return localVarFp.fdoConfigureDevice(guid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * List all known FDO vouchers **Access policy**: administrator
         * @summary List all known FDO vouchers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoListAll(options?: any): AxiosPromise<void> {
            return localVarFp.fdoListAll(options).then((request) => request(axios, basePath));
        },
        /**
         * retrieves a given FDO profile information and content **Access policy**: administrator
         * @summary retrieves a given FDO profile information and content
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileInspect(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.fdoProfileInspect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * retrieves all FDO profiles **Access policy**: administrator
         * @summary retrieves all FDO profiles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoProfileList(options?: any): AxiosPromise<void> {
            return localVarFp.fdoProfileList(options).then((request) => request(axios, basePath));
        },
        /**
         * register an FDO device **Access policy**: administrator
         * @summary register an FDO device
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdoRegisterDevice(options?: any): AxiosPromise<void> {
            return localVarFp.fdoRegisterDevice(options).then((request) => request(axios, basePath));
        },
        /**
         * Activate OpenAMT device and associate to agent endpoint **Access policy**: administrator
         * @summary Activate OpenAMT device and associate to agent endpoint
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTActivate(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.openAMTActivate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable Portainer\'s OpenAMT capabilities **Access policy**: administrator
         * @summary Enable Portainer\'s OpenAMT capabilities
         * @param {OpenamtOpenAMTConfigurePayload} body OpenAMT Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTConfigure(body: OpenamtOpenAMTConfigurePayload, options?: any): AxiosPromise<void> {
            return localVarFp.openAMTConfigure(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch OpenAMT managed devices information for endpoint **Access policy**: administrator
         * @summary Fetch OpenAMT managed devices information for endpoint
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTDevices(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.openAMTDevices(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Request OpenAMT info from a node **Access policy**: administrator
         * @summary Request OpenAMT info from a node
         * @param {number} id Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openAMTHostInfo(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.openAMTHostInfo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * updates an existing FDO Profile **Access policy**: administrator
         * @summary updates an existing FDO Profile
         * @param {number} id FDO Profile identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfile(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.updateProfile(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntelApi - object-oriented interface
 * @export
 * @class IntelApi
 * @extends {BaseAPI}
 */
export class IntelApi extends BaseAPI {
    /**
     * creates a new FDO Profile **Access policy**: administrator
     * @summary creates a new FDO Profile
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public createProfile(options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).createProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * deletes a FDO Profile **Access policy**: administrator
     * @summary deletes a FDO Profile
     * @param {number} id FDO Profile identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public deleteProfile(id: number, options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).deleteProfile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute out of band action on an AMT managed device **Access policy**: administrator
     * @summary Execute out of band action on an AMT managed device
     * @param {number} id Environment identifier
     * @param {number} deviceId Device identifier
     * @param {OpenamtDeviceActionPayload} body Device Action
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public deviceAction(id: number, deviceId: number, body: OpenamtDeviceActionPayload, options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).deviceAction(id, deviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable features on an AMT managed device **Access policy**: administrator
     * @summary Enable features on an AMT managed device
     * @param {number} id Environment identifier
     * @param {number} deviceId Device identifier
     * @param {OpenamtDeviceFeaturesPayload} body Device Features
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public deviceFeatures(id: number, deviceId: number, body: OpenamtDeviceFeaturesPayload, options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).deviceFeatures(id, deviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * duplicated an existing FDO Profile **Access policy**: administrator
     * @summary duplicated an existing FDO Profile
     * @param {number} id FDO Profile identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public duplicate(id: number, options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).duplicate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable Portainer\'s FDO capabilities **Access policy**: administrator
     * @summary Enable Portainer\'s FDO capabilities
     * @param {FdoFdoConfigurePayload} body FDO Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public fdoConfigure(body: FdoFdoConfigurePayload, options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).fdoConfigure(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * configures an FDO device **Access policy**: administrator
     * @summary configures an FDO device
     * @param {number} guid Guid
     * @param {FdoDeviceConfigurePayload} body Device Configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public fdoConfigureDevice(guid: number, body: FdoDeviceConfigurePayload, options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).fdoConfigureDevice(guid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all known FDO vouchers **Access policy**: administrator
     * @summary List all known FDO vouchers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public fdoListAll(options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).fdoListAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * retrieves a given FDO profile information and content **Access policy**: administrator
     * @summary retrieves a given FDO profile information and content
     * @param {number} id FDO Profile identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public fdoProfileInspect(id: number, options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).fdoProfileInspect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * retrieves all FDO profiles **Access policy**: administrator
     * @summary retrieves all FDO profiles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public fdoProfileList(options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).fdoProfileList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * register an FDO device **Access policy**: administrator
     * @summary register an FDO device
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public fdoRegisterDevice(options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).fdoRegisterDevice(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activate OpenAMT device and associate to agent endpoint **Access policy**: administrator
     * @summary Activate OpenAMT device and associate to agent endpoint
     * @param {number} id Environment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public openAMTActivate(id: number, options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).openAMTActivate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable Portainer\'s OpenAMT capabilities **Access policy**: administrator
     * @summary Enable Portainer\'s OpenAMT capabilities
     * @param {OpenamtOpenAMTConfigurePayload} body OpenAMT Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public openAMTConfigure(body: OpenamtOpenAMTConfigurePayload, options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).openAMTConfigure(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch OpenAMT managed devices information for endpoint **Access policy**: administrator
     * @summary Fetch OpenAMT managed devices information for endpoint
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public openAMTDevices(id: number, options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).openAMTDevices(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request OpenAMT info from a node **Access policy**: administrator
     * @summary Request OpenAMT info from a node
     * @param {number} id Environment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public openAMTHostInfo(id: number, options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).openAMTHostInfo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * updates an existing FDO Profile **Access policy**: administrator
     * @summary updates an existing FDO Profile
     * @param {number} id FDO Profile identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntelApi
     */
    public updateProfile(id: number, options?: AxiosRequestConfig) {
        return IntelApiFp(this.configuration).updateProfile(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * KubernetesApi - axios parameter creator
 * @export
 */
export const KubernetesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a kubernetes ingress by namespace for the provided environment **Access policy**: authenticated
         * @summary Create a kubernetes ingress by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesIngress: async (id: number, namespace: string, body: KubernetesK8sIngressInfo, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createKubernetesIngress', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('createKubernetesIngress', 'namespace', namespace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createKubernetesIngress', 'body', body)
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Create a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sNamespaceDetails} body Namespace configuration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesNamespace: async (id: number, body: KubernetesK8sNamespaceDetails, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createKubernetesNamespace', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createKubernetesNamespace', 'body', body)
            const localVarPath = `/kubernetes/{id}/namespaces`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Create a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesService: async (id: number, namespace: string, body: KubernetesK8sServiceInfo, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createKubernetesService', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('createKubernetesService', 'namespace', namespace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createKubernetesService', 'body', body)
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/services`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete kubernetes ingresses for the provided environment **Access policy**: authenticated
         * @summary Delete kubernetes ingresses
         * @param {number} id Environment (Endpoint) identifier
         * @param {{ [key: string]: Array<string>; }} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesIngresses: async (id: number, body: { [key: string]: Array<string>; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteKubernetesIngresses', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('deleteKubernetesIngresses', 'body', body)
            const localVarPath = `/kubernetes/{id}/ingresses/delete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Delete kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesNamespace: async (id: number, namespace: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteKubernetesNamespace', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('deleteKubernetesNamespace', 'namespace', namespace)
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the provided list of kubernetes services **Access policy**: authenticated
         * @summary Delete kubernetes services
         * @param {number} id Environment (Endpoint) identifier
         * @param {{ [key: string]: Array<string>; }} body A map where the key is the namespace and the value is an array of services to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesServices: async (id: number, body: { [key: string]: Array<string>; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteKubernetesServices', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('deleteKubernetesServices', 'body', body)
            const localVarPath = `/kubernetes/{id}/services/delete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate a kubeconfig file enabling client communication with k8s api server **Access policy**: authenticated
         * @summary Generate a kubeconfig file enabling client communication with k8s api server
         * @param {Array<number>} [ids] will include only these environments(endpoints)
         * @param {Array<number>} [excludeIds] will exclude these environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesConfig: async (ids?: Array<number>, excludeIds?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/kubernetes/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (excludeIds) {
                localVarQueryParameter['excludeIds'] = excludeIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all ConfigMaps and Secrets for a given namespace **Access policy**: authenticated
         * @summary Get ConfigMaps and Secrets
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getKubernetesConfigMapsAndSecrets: async (id: number, namespace: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKubernetesConfigMapsAndSecrets', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getKubernetesConfigMapsAndSecrets', 'namespace', namespace)
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/configuration`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of ingress controllers for the given environment **Access policy**: authenticated
         * @summary Get a list of ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {boolean} [allowedOnly] Only return allowed ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllers: async (id: number, allowedOnly?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKubernetesIngressControllers', 'id', id)
            const localVarPath = `/kubernetes/{id}/ingresscontrollers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (allowedOnly !== undefined) {
                localVarQueryParameter['allowedOnly'] = allowedOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of ingress controllers for the given environment in the provided namespace **Access policy**: authenticated
         * @summary Get a list ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllersByNamespace: async (id: number, namespace: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKubernetesIngressControllersByNamespace', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getKubernetesIngressControllersByNamespace', 'namespace', namespace)
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresscontrollers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get kubernetes ingresses by namespace for the provided environment **Access policy**: authenticated
         * @summary Get kubernetes ingresses by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<KubernetesK8sIngressInfo>} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngresses: async (id: number, namespace: string, body: Array<KubernetesK8sIngressInfo>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKubernetesIngresses', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getKubernetesIngresses', 'namespace', namespace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('getKubernetesIngresses', 'body', body)
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of nodes with their live metrics **Access policy**: authenticated
         * @summary Get a list of nodes with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllNodes: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKubernetesMetricsForAllNodes', 'id', id)
            const localVarPath = `/kubernetes/{id}/metrics/nodes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of pods with their live metrics **Access policy**: authenticated
         * @summary Get a list of pods with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllPods: async (id: number, namespace: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKubernetesMetricsForAllPods', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getKubernetesMetricsForAllPods', 'namespace', namespace)
            const localVarPath = `/kubernetes/{id}/metrics/pods/{namespace}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get live metrics for a node **Access policy**: authenticated
         * @summary Get live metrics for a node
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} name Node identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForNode: async (id: number, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKubernetesMetricsForNode', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getKubernetesMetricsForNode', 'name', name)
            const localVarPath = `/kubernetes/{id}/metrics/nodes/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get live metrics for a pod **Access policy**: authenticated
         * @summary Get live metrics for a pod
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {string} name Pod identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForPod: async (id: number, namespace: string, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKubernetesMetricsForPod', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getKubernetesMetricsForPod', 'namespace', namespace)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getKubernetesMetricsForPod', 'name', name)
            const localVarPath = `/kubernetes/{id}/metrics/pods/{namespace}/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get kubernetes namespace details for the provided namespace within the given environment **Access policy**: authenticated
         * @summary Get kubernetes namespace details
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespace: async (id: number, namespace: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKubernetesNamespace', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getKubernetesNamespace', 'namespace', namespace)
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all kubernetes namespaces in the cluster **Access policy**: authenticated
         * @summary Get a list of kubernetes namespaces
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespaces: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKubernetesNamespaces', 'id', id)
            const localVarPath = `/kubernetes/{id}/namespaces`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get CPU and memory limits of all nodes within k8s cluster **Access policy**: authenticated
         * @summary Get CPU and memory limits of all nodes within k8s cluster
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNodesLimits: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKubernetesNodesLimits', 'id', id)
            const localVarPath = `/kubernetes/{id}/nodes_limits`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of kubernetes services for a given namespace **Access policy**: authenticated
         * @summary Get a list of kubernetes services for a given namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {boolean} [lookupapplications] Lookup applications associated with each service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesServices: async (id: number, namespace: string, lookupapplications?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getKubernetesServices', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getKubernetesServices', 'namespace', namespace)
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/services`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (lookupapplications !== undefined) {
                localVarQueryParameter['lookupapplications'] = lookupapplications;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Toggle the system state for a namespace **Access policy**: administrator or environment(endpoint) admin
         * @summary Toggle the system state for a namespace
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesNamespacesToggleSystemPayload} body Update details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kubernetesNamespacesToggleSystem: async (id: number, namespace: string, body: KubernetesNamespacesToggleSystemPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('kubernetesNamespacesToggleSystem', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('kubernetesNamespacesToggleSystem', 'namespace', namespace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('kubernetesNamespacesToggleSystem', 'body', body)
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/system`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update kubernetes ingress rule for the provided environment **Access policy**: authenticated
         * @summary Update kubernetes ingress rule
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngress: async (id: number, namespace: string, body: KubernetesK8sIngressInfo, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKubernetesIngress', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateKubernetesIngress', 'namespace', namespace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateKubernetesIngress', 'body', body)
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update (block/unblock) ingress controllers **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllers: async (id: number, body: Array<Array<KubernetesK8sIngressController>>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKubernetesIngressControllers', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateKubernetesIngressControllers', 'body', body)
            const localVarPath = `/kubernetes/{id}/ingresscontrollers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update (block/unblock) ingress controllers by namespace for the provided environment **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllersByNamespace: async (id: number, namespace: string, body: Array<Array<KubernetesK8sIngressController>>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKubernetesIngressControllersByNamespace', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateKubernetesIngressControllersByNamespace', 'namespace', namespace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateKubernetesIngressControllersByNamespace', 'body', body)
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/ingresscontrollers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Updates a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {KubernetesK8sNamespaceDetails} body Namespace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesNamespace: async (id: number, namespace: string, body: KubernetesK8sNamespaceDetails, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKubernetesNamespace', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateKubernetesNamespace', 'namespace', namespace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateKubernetesNamespace', 'body', body)
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Update a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesService: async (id: number, namespace: string, body: KubernetesK8sServiceInfo, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKubernetesService', 'id', id)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('updateKubernetesService', 'namespace', namespace)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('updateKubernetesService', 'body', body)
            const localVarPath = `/kubernetes/{id}/namespaces/{namespace}/services`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KubernetesApi - functional programming interface
 * @export
 */
export const KubernetesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KubernetesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a kubernetes ingress by namespace for the provided environment **Access policy**: authenticated
         * @summary Create a kubernetes ingress by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKubernetesIngress(id: number, namespace: string, body: KubernetesK8sIngressInfo, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKubernetesIngress(id, namespace, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Create a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sNamespaceDetails} body Namespace configuration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKubernetesNamespace(id: number, body: KubernetesK8sNamespaceDetails, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKubernetesNamespace(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Create a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKubernetesService(id: number, namespace: string, body: KubernetesK8sServiceInfo, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKubernetesService(id, namespace, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete kubernetes ingresses for the provided environment **Access policy**: authenticated
         * @summary Delete kubernetes ingresses
         * @param {number} id Environment (Endpoint) identifier
         * @param {{ [key: string]: Array<string>; }} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKubernetesIngresses(id: number, body: { [key: string]: Array<string>; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKubernetesIngresses(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Delete kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKubernetesNamespace(id: number, namespace: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKubernetesNamespace(id, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the provided list of kubernetes services **Access policy**: authenticated
         * @summary Delete kubernetes services
         * @param {number} id Environment (Endpoint) identifier
         * @param {{ [key: string]: Array<string>; }} body A map where the key is the namespace and the value is an array of services to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKubernetesServices(id: number, body: { [key: string]: Array<string>; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKubernetesServices(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate a kubeconfig file enabling client communication with k8s api server **Access policy**: authenticated
         * @summary Generate a kubeconfig file enabling client communication with k8s api server
         * @param {Array<number>} [ids] will include only these environments(endpoints)
         * @param {Array<number>} [excludeIds] will exclude these environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKubernetesConfig(ids?: Array<number>, excludeIds?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKubernetesConfig(ids, excludeIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all ConfigMaps and Secrets for a given namespace **Access policy**: authenticated
         * @summary Get ConfigMaps and Secrets
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getKubernetesConfigMapsAndSecrets(id: number, namespace: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<KubernetesK8sConfigMapOrSecret>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKubernetesConfigMapsAndSecrets(id, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of ingress controllers for the given environment **Access policy**: authenticated
         * @summary Get a list of ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {boolean} [allowedOnly] Only return allowed ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKubernetesIngressControllers(id: number, allowedOnly?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KubernetesK8sIngressController>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKubernetesIngressControllers(id, allowedOnly, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of ingress controllers for the given environment in the provided namespace **Access policy**: authenticated
         * @summary Get a list ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKubernetesIngressControllersByNamespace(id: number, namespace: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KubernetesK8sIngressController>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKubernetesIngressControllersByNamespace(id, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get kubernetes ingresses by namespace for the provided environment **Access policy**: authenticated
         * @summary Get kubernetes ingresses by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<KubernetesK8sIngressInfo>} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKubernetesIngresses(id: number, namespace: string, body: Array<KubernetesK8sIngressInfo>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKubernetesIngresses(id, namespace, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of nodes with their live metrics **Access policy**: authenticated
         * @summary Get a list of nodes with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKubernetesMetricsForAllNodes(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1beta1NodeMetricsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKubernetesMetricsForAllNodes(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of pods with their live metrics **Access policy**: authenticated
         * @summary Get a list of pods with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKubernetesMetricsForAllPods(id: number, namespace: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1beta1PodMetricsList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKubernetesMetricsForAllPods(id, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get live metrics for a node **Access policy**: authenticated
         * @summary Get live metrics for a node
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} name Node identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKubernetesMetricsForNode(id: number, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1beta1NodeMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKubernetesMetricsForNode(id, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get live metrics for a pod **Access policy**: authenticated
         * @summary Get live metrics for a pod
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {string} name Pod identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKubernetesMetricsForPod(id: number, namespace: string, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1beta1PodMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKubernetesMetricsForPod(id, namespace, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get kubernetes namespace details for the provided namespace within the given environment **Access policy**: authenticated
         * @summary Get kubernetes namespace details
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKubernetesNamespace(id: number, namespace: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerK8sNamespaceInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKubernetesNamespace(id, namespace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of all kubernetes namespaces in the cluster **Access policy**: authenticated
         * @summary Get a list of kubernetes namespaces
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKubernetesNamespaces(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: PortainerK8sNamespaceInfo; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKubernetesNamespaces(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get CPU and memory limits of all nodes within k8s cluster **Access policy**: authenticated
         * @summary Get CPU and memory limits of all nodes within k8s cluster
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKubernetesNodesLimits(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: PortainerK8sNodeLimits; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKubernetesNodesLimits(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a list of kubernetes services for a given namespace **Access policy**: authenticated
         * @summary Get a list of kubernetes services for a given namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {boolean} [lookupapplications] Lookup applications associated with each service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKubernetesServices(id: number, namespace: string, lookupapplications?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KubernetesK8sServiceInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKubernetesServices(id, namespace, lookupapplications, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Toggle the system state for a namespace **Access policy**: administrator or environment(endpoint) admin
         * @summary Toggle the system state for a namespace
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesNamespacesToggleSystemPayload} body Update details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kubernetesNamespacesToggleSystem(id: number, namespace: string, body: KubernetesNamespacesToggleSystemPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.kubernetesNamespacesToggleSystem(id, namespace, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update kubernetes ingress rule for the provided environment **Access policy**: authenticated
         * @summary Update kubernetes ingress rule
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKubernetesIngress(id: number, namespace: string, body: KubernetesK8sIngressInfo, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKubernetesIngress(id, namespace, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update (block/unblock) ingress controllers **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKubernetesIngressControllers(id: number, body: Array<Array<KubernetesK8sIngressController>>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKubernetesIngressControllers(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update (block/unblock) ingress controllers by namespace for the provided environment **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKubernetesIngressControllersByNamespace(id: number, namespace: string, body: Array<Array<KubernetesK8sIngressController>>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKubernetesIngressControllersByNamespace(id, namespace, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Updates a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {KubernetesK8sNamespaceDetails} body Namespace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKubernetesNamespace(id: number, namespace: string, body: KubernetesK8sNamespaceDetails, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKubernetesNamespace(id, namespace, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Update a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKubernetesService(id: number, namespace: string, body: KubernetesK8sServiceInfo, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKubernetesService(id, namespace, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * KubernetesApi - factory interface
 * @export
 */
export const KubernetesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KubernetesApiFp(configuration)
    return {
        /**
         * Create a kubernetes ingress by namespace for the provided environment **Access policy**: authenticated
         * @summary Create a kubernetes ingress by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesIngress(id: number, namespace: string, body: KubernetesK8sIngressInfo, options?: any): AxiosPromise<string> {
            return localVarFp.createKubernetesIngress(id, namespace, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Create a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {KubernetesK8sNamespaceDetails} body Namespace configuration details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesNamespace(id: number, body: KubernetesK8sNamespaceDetails, options?: any): AxiosPromise<string> {
            return localVarFp.createKubernetesNamespace(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Create a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKubernetesService(id: number, namespace: string, body: KubernetesK8sServiceInfo, options?: any): AxiosPromise<void> {
            return localVarFp.createKubernetesService(id, namespace, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete kubernetes ingresses for the provided environment **Access policy**: authenticated
         * @summary Delete kubernetes ingresses
         * @param {number} id Environment (Endpoint) identifier
         * @param {{ [key: string]: Array<string>; }} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesIngresses(id: number, body: { [key: string]: Array<string>; }, options?: any): AxiosPromise<string> {
            return localVarFp.deleteKubernetesIngresses(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Delete kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesNamespace(id: number, namespace: string, options?: any): AxiosPromise<string> {
            return localVarFp.deleteKubernetesNamespace(id, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the provided list of kubernetes services **Access policy**: authenticated
         * @summary Delete kubernetes services
         * @param {number} id Environment (Endpoint) identifier
         * @param {{ [key: string]: Array<string>; }} body A map where the key is the namespace and the value is an array of services to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKubernetesServices(id: number, body: { [key: string]: Array<string>; }, options?: any): AxiosPromise<void> {
            return localVarFp.deleteKubernetesServices(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate a kubeconfig file enabling client communication with k8s api server **Access policy**: authenticated
         * @summary Generate a kubeconfig file enabling client communication with k8s api server
         * @param {Array<number>} [ids] will include only these environments(endpoints)
         * @param {Array<number>} [excludeIds] will exclude these environments(endpoints)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesConfig(ids?: Array<number>, excludeIds?: Array<number>, options?: any): AxiosPromise<void> {
            return localVarFp.getKubernetesConfig(ids, excludeIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all ConfigMaps and Secrets for a given namespace **Access policy**: authenticated
         * @summary Get ConfigMaps and Secrets
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getKubernetesConfigMapsAndSecrets(id: number, namespace: string, options?: any): AxiosPromise<Array<Array<KubernetesK8sConfigMapOrSecret>>> {
            return localVarFp.getKubernetesConfigMapsAndSecrets(id, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of ingress controllers for the given environment **Access policy**: authenticated
         * @summary Get a list of ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {boolean} [allowedOnly] Only return allowed ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllers(id: number, allowedOnly?: boolean, options?: any): AxiosPromise<Array<KubernetesK8sIngressController>> {
            return localVarFp.getKubernetesIngressControllers(id, allowedOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of ingress controllers for the given environment in the provided namespace **Access policy**: authenticated
         * @summary Get a list ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngressControllersByNamespace(id: number, namespace: string, options?: any): AxiosPromise<Array<KubernetesK8sIngressController>> {
            return localVarFp.getKubernetesIngressControllersByNamespace(id, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Get kubernetes ingresses by namespace for the provided environment **Access policy**: authenticated
         * @summary Get kubernetes ingresses by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<KubernetesK8sIngressInfo>} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesIngresses(id: number, namespace: string, body: Array<KubernetesK8sIngressInfo>, options?: any): AxiosPromise<string> {
            return localVarFp.getKubernetesIngresses(id, namespace, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of nodes with their live metrics **Access policy**: authenticated
         * @summary Get a list of nodes with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllNodes(id: number, options?: any): AxiosPromise<V1beta1NodeMetricsList> {
            return localVarFp.getKubernetesMetricsForAllNodes(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of pods with their live metrics **Access policy**: authenticated
         * @summary Get a list of pods with their live metrics
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForAllPods(id: number, namespace: string, options?: any): AxiosPromise<V1beta1PodMetricsList> {
            return localVarFp.getKubernetesMetricsForAllPods(id, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Get live metrics for a node **Access policy**: authenticated
         * @summary Get live metrics for a node
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} name Node identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForNode(id: number, name: string, options?: any): AxiosPromise<V1beta1NodeMetrics> {
            return localVarFp.getKubernetesMetricsForNode(id, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get live metrics for a pod **Access policy**: authenticated
         * @summary Get live metrics for a pod
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {string} name Pod identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesMetricsForPod(id: number, namespace: string, name: string, options?: any): AxiosPromise<V1beta1PodMetrics> {
            return localVarFp.getKubernetesMetricsForPod(id, namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get kubernetes namespace details for the provided namespace within the given environment **Access policy**: authenticated
         * @summary Get kubernetes namespace details
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespace(id: number, namespace: string, options?: any): AxiosPromise<PortainerK8sNamespaceInfo> {
            return localVarFp.getKubernetesNamespace(id, namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all kubernetes namespaces in the cluster **Access policy**: authenticated
         * @summary Get a list of kubernetes namespaces
         * @param {number} id Environment (Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNamespaces(id: number, options?: any): AxiosPromise<{ [key: string]: PortainerK8sNamespaceInfo; }> {
            return localVarFp.getKubernetesNamespaces(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get CPU and memory limits of all nodes within k8s cluster **Access policy**: authenticated
         * @summary Get CPU and memory limits of all nodes within k8s cluster
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesNodesLimits(id: number, options?: any): AxiosPromise<{ [key: string]: PortainerK8sNodeLimits; }> {
            return localVarFp.getKubernetesNodesLimits(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of kubernetes services for a given namespace **Access policy**: authenticated
         * @summary Get a list of kubernetes services for a given namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {boolean} [lookupapplications] Lookup applications associated with each service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKubernetesServices(id: number, namespace: string, lookupapplications?: boolean, options?: any): AxiosPromise<Array<KubernetesK8sServiceInfo>> {
            return localVarFp.getKubernetesServices(id, namespace, lookupapplications, options).then((request) => request(axios, basePath));
        },
        /**
         * Toggle the system state for a namespace **Access policy**: administrator or environment(endpoint) admin
         * @summary Toggle the system state for a namespace
         * @param {number} id Environment(Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesNamespacesToggleSystemPayload} body Update details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kubernetesNamespacesToggleSystem(id: number, namespace: string, body: KubernetesNamespacesToggleSystemPayload, options?: any): AxiosPromise<void> {
            return localVarFp.kubernetesNamespacesToggleSystem(id, namespace, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update kubernetes ingress rule for the provided environment **Access policy**: authenticated
         * @summary Update kubernetes ingress rule
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sIngressInfo} body Ingress details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngress(id: number, namespace: string, body: KubernetesK8sIngressInfo, options?: any): AxiosPromise<string> {
            return localVarFp.updateKubernetesIngress(id, namespace, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update (block/unblock) ingress controllers **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers
         * @param {number} id Environment (Endpoint) identifier
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllers(id: number, body: Array<Array<KubernetesK8sIngressController>>, options?: any): AxiosPromise<string> {
            return localVarFp.updateKubernetesIngressControllers(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update (block/unblock) ingress controllers by namespace for the provided environment **Access policy**: authenticated
         * @summary Update (block/unblock) ingress controllers by namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesIngressControllersByNamespace(id: number, namespace: string, body: Array<Array<KubernetesK8sIngressController>>, options?: any): AxiosPromise<string> {
            return localVarFp.updateKubernetesIngressControllersByNamespace(id, namespace, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a kubernetes namespace within the given environment **Access policy**: authenticated
         * @summary Updates a kubernetes namespace
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace
         * @param {KubernetesK8sNamespaceDetails} body Namespace details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesNamespace(id: number, namespace: string, body: KubernetesK8sNamespaceDetails, options?: any): AxiosPromise<string> {
            return localVarFp.updateKubernetesNamespace(id, namespace, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a kubernetes service within a given namespace **Access policy**: authenticated
         * @summary Update a kubernetes service
         * @param {number} id Environment (Endpoint) identifier
         * @param {string} namespace Namespace name
         * @param {KubernetesK8sServiceInfo} body Service definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKubernetesService(id: number, namespace: string, body: KubernetesK8sServiceInfo, options?: any): AxiosPromise<void> {
            return localVarFp.updateKubernetesService(id, namespace, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KubernetesApi - object-oriented interface
 * @export
 * @class KubernetesApi
 * @extends {BaseAPI}
 */
export class KubernetesApi extends BaseAPI {
    /**
     * Create a kubernetes ingress by namespace for the provided environment **Access policy**: authenticated
     * @summary Create a kubernetes ingress by namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesK8sIngressInfo} body Ingress details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public createKubernetesIngress(id: number, namespace: string, body: KubernetesK8sIngressInfo, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).createKubernetesIngress(id, namespace, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a kubernetes namespace within the given environment **Access policy**: authenticated
     * @summary Create a kubernetes namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {KubernetesK8sNamespaceDetails} body Namespace configuration details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public createKubernetesNamespace(id: number, body: KubernetesK8sNamespaceDetails, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).createKubernetesNamespace(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a kubernetes service within a given namespace **Access policy**: authenticated
     * @summary Create a kubernetes service
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesK8sServiceInfo} body Service definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public createKubernetesService(id: number, namespace: string, body: KubernetesK8sServiceInfo, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).createKubernetesService(id, namespace, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete kubernetes ingresses for the provided environment **Access policy**: authenticated
     * @summary Delete kubernetes ingresses
     * @param {number} id Environment (Endpoint) identifier
     * @param {{ [key: string]: Array<string>; }} body Ingress details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public deleteKubernetesIngresses(id: number, body: { [key: string]: Array<string>; }, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).deleteKubernetesIngresses(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a kubernetes namespace within the given environment **Access policy**: authenticated
     * @summary Delete kubernetes namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public deleteKubernetesNamespace(id: number, namespace: string, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).deleteKubernetesNamespace(id, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the provided list of kubernetes services **Access policy**: authenticated
     * @summary Delete kubernetes services
     * @param {number} id Environment (Endpoint) identifier
     * @param {{ [key: string]: Array<string>; }} body A map where the key is the namespace and the value is an array of services to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public deleteKubernetesServices(id: number, body: { [key: string]: Array<string>; }, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).deleteKubernetesServices(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate a kubeconfig file enabling client communication with k8s api server **Access policy**: authenticated
     * @summary Generate a kubeconfig file enabling client communication with k8s api server
     * @param {Array<number>} [ids] will include only these environments(endpoints)
     * @param {Array<number>} [excludeIds] will exclude these environments(endpoints)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesConfig(ids?: Array<number>, excludeIds?: Array<number>, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).getKubernetesConfig(ids, excludeIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all ConfigMaps and Secrets for a given namespace **Access policy**: authenticated
     * @summary Get ConfigMaps and Secrets
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesConfigMapsAndSecrets(id: number, namespace: string, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).getKubernetesConfigMapsAndSecrets(id, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of ingress controllers for the given environment **Access policy**: authenticated
     * @summary Get a list of ingress controllers
     * @param {number} id Environment (Endpoint) identifier
     * @param {boolean} [allowedOnly] Only return allowed ingress controllers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesIngressControllers(id: number, allowedOnly?: boolean, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).getKubernetesIngressControllers(id, allowedOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of ingress controllers for the given environment in the provided namespace **Access policy**: authenticated
     * @summary Get a list ingress controllers by namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesIngressControllersByNamespace(id: number, namespace: string, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).getKubernetesIngressControllersByNamespace(id, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get kubernetes ingresses by namespace for the provided environment **Access policy**: authenticated
     * @summary Get kubernetes ingresses by namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {Array<KubernetesK8sIngressInfo>} body Ingress details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesIngresses(id: number, namespace: string, body: Array<KubernetesK8sIngressInfo>, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).getKubernetesIngresses(id, namespace, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of nodes with their live metrics **Access policy**: authenticated
     * @summary Get a list of nodes with their live metrics
     * @param {number} id Environment (Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesMetricsForAllNodes(id: number, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).getKubernetesMetricsForAllNodes(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of pods with their live metrics **Access policy**: authenticated
     * @summary Get a list of pods with their live metrics
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesMetricsForAllPods(id: number, namespace: string, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).getKubernetesMetricsForAllPods(id, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get live metrics for a node **Access policy**: authenticated
     * @summary Get live metrics for a node
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} name Node identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesMetricsForNode(id: number, name: string, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).getKubernetesMetricsForNode(id, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get live metrics for a pod **Access policy**: authenticated
     * @summary Get live metrics for a pod
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {string} name Pod identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesMetricsForPod(id: number, namespace: string, name: string, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).getKubernetesMetricsForPod(id, namespace, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get kubernetes namespace details for the provided namespace within the given environment **Access policy**: authenticated
     * @summary Get kubernetes namespace details
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesNamespace(id: number, namespace: string, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).getKubernetesNamespace(id, namespace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all kubernetes namespaces in the cluster **Access policy**: authenticated
     * @summary Get a list of kubernetes namespaces
     * @param {number} id Environment (Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesNamespaces(id: number, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).getKubernetesNamespaces(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get CPU and memory limits of all nodes within k8s cluster **Access policy**: authenticated
     * @summary Get CPU and memory limits of all nodes within k8s cluster
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesNodesLimits(id: number, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).getKubernetesNodesLimits(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of kubernetes services for a given namespace **Access policy**: authenticated
     * @summary Get a list of kubernetes services for a given namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {boolean} [lookupapplications] Lookup applications associated with each service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public getKubernetesServices(id: number, namespace: string, lookupapplications?: boolean, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).getKubernetesServices(id, namespace, lookupapplications, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Toggle the system state for a namespace **Access policy**: administrator or environment(endpoint) admin
     * @summary Toggle the system state for a namespace
     * @param {number} id Environment(Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesNamespacesToggleSystemPayload} body Update details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public kubernetesNamespacesToggleSystem(id: number, namespace: string, body: KubernetesNamespacesToggleSystemPayload, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).kubernetesNamespacesToggleSystem(id, namespace, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update kubernetes ingress rule for the provided environment **Access policy**: authenticated
     * @summary Update kubernetes ingress rule
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesK8sIngressInfo} body Ingress details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public updateKubernetesIngress(id: number, namespace: string, body: KubernetesK8sIngressInfo, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).updateKubernetesIngress(id, namespace, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update (block/unblock) ingress controllers **Access policy**: authenticated
     * @summary Update (block/unblock) ingress controllers
     * @param {number} id Environment (Endpoint) identifier
     * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public updateKubernetesIngressControllers(id: number, body: Array<Array<KubernetesK8sIngressController>>, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).updateKubernetesIngressControllers(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update (block/unblock) ingress controllers by namespace for the provided environment **Access policy**: authenticated
     * @summary Update (block/unblock) ingress controllers by namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {Array<Array<KubernetesK8sIngressController>>} body Ingress controllers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public updateKubernetesIngressControllersByNamespace(id: number, namespace: string, body: Array<Array<KubernetesK8sIngressController>>, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).updateKubernetesIngressControllersByNamespace(id, namespace, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a kubernetes namespace within the given environment **Access policy**: authenticated
     * @summary Updates a kubernetes namespace
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace
     * @param {KubernetesK8sNamespaceDetails} body Namespace details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public updateKubernetesNamespace(id: number, namespace: string, body: KubernetesK8sNamespaceDetails, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).updateKubernetesNamespace(id, namespace, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a kubernetes service within a given namespace **Access policy**: authenticated
     * @summary Update a kubernetes service
     * @param {number} id Environment (Endpoint) identifier
     * @param {string} namespace Namespace name
     * @param {KubernetesK8sServiceInfo} body Service definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KubernetesApi
     */
    public updateKubernetesService(id: number, namespace: string, body: KubernetesK8sServiceInfo, options?: AxiosRequestConfig) {
        return KubernetesApiFp(this.configuration).updateKubernetesService(id, namespace, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LdapApi - axios parameter creator
 * @export
 */
export const LdapApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Test LDAP connectivity using LDAP details **Access policy**: administrator
         * @summary Test LDAP connectivity
         * @param {LdapCheckPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lDAPCheck: async (body: LdapCheckPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('lDAPCheck', 'body', body)
            const localVarPath = `/ldap/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LdapApi - functional programming interface
 * @export
 */
export const LdapApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LdapApiAxiosParamCreator(configuration)
    return {
        /**
         * Test LDAP connectivity using LDAP details **Access policy**: administrator
         * @summary Test LDAP connectivity
         * @param {LdapCheckPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lDAPCheck(body: LdapCheckPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lDAPCheck(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LdapApi - factory interface
 * @export
 */
export const LdapApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LdapApiFp(configuration)
    return {
        /**
         * Test LDAP connectivity using LDAP details **Access policy**: administrator
         * @summary Test LDAP connectivity
         * @param {LdapCheckPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lDAPCheck(body: LdapCheckPayload, options?: any): AxiosPromise<void> {
            return localVarFp.lDAPCheck(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LdapApi - object-oriented interface
 * @export
 * @class LdapApi
 * @extends {BaseAPI}
 */
export class LdapApi extends BaseAPI {
    /**
     * Test LDAP connectivity using LDAP details **Access policy**: administrator
     * @summary Test LDAP connectivity
     * @param {LdapCheckPayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LdapApi
     */
    public lDAPCheck(body: LdapCheckPayload, options?: AxiosRequestConfig) {
        return LdapApiFp(this.configuration).lDAPCheck(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MotdApi - axios parameter creator
 * @export
 */
export const MotdApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: restricted
         * @summary fetches the message of the day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mOTD: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/motd`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MotdApi - functional programming interface
 * @export
 */
export const MotdApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MotdApiAxiosParamCreator(configuration)
    return {
        /**
         * **Access policy**: restricted
         * @summary fetches the message of the day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mOTD(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MotdMotdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mOTD(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MotdApi - factory interface
 * @export
 */
export const MotdApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MotdApiFp(configuration)
    return {
        /**
         * **Access policy**: restricted
         * @summary fetches the message of the day
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mOTD(options?: any): AxiosPromise<MotdMotdResponse> {
            return localVarFp.mOTD(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MotdApi - object-oriented interface
 * @export
 * @class MotdApi
 * @extends {BaseAPI}
 */
export class MotdApi extends BaseAPI {
    /**
     * **Access policy**: restricted
     * @summary fetches the message of the day
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MotdApi
     */
    public mOTD(options?: AxiosRequestConfig) {
        return MotdApiFp(this.configuration).mOTD(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RbacEnabledApi - axios parameter creator
 * @export
 */
export const RbacEnabledApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if RBAC is enabled in the current Kubernetes cluster. **Access policy**: administrator
         * @summary Check if RBAC is enabled
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRBACEnabled: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('isRBACEnabled', 'id', id)
            const localVarPath = `/kubernetes/{id}/rbac_enabled`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RbacEnabledApi - functional programming interface
 * @export
 */
export const RbacEnabledApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RbacEnabledApiAxiosParamCreator(configuration)
    return {
        /**
         * Check if RBAC is enabled in the current Kubernetes cluster. **Access policy**: administrator
         * @summary Check if RBAC is enabled
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isRBACEnabled(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isRBACEnabled(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RbacEnabledApi - factory interface
 * @export
 */
export const RbacEnabledApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RbacEnabledApiFp(configuration)
    return {
        /**
         * Check if RBAC is enabled in the current Kubernetes cluster. **Access policy**: administrator
         * @summary Check if RBAC is enabled
         * @param {number} id Environment(Endpoint) identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isRBACEnabled(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.isRBACEnabled(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RbacEnabledApi - object-oriented interface
 * @export
 * @class RbacEnabledApi
 * @extends {BaseAPI}
 */
export class RbacEnabledApi extends BaseAPI {
    /**
     * Check if RBAC is enabled in the current Kubernetes cluster. **Access policy**: administrator
     * @summary Check if RBAC is enabled
     * @param {number} id Environment(Endpoint) identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacEnabledApi
     */
    public isRBACEnabled(id: number, options?: AxiosRequestConfig) {
        return RbacEnabledApiFp(this.configuration).isRBACEnabled(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RegistriesApi - axios parameter creator
 * @export
 */
export const RegistriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Configures a registry. **Access policy**: restricted
         * @summary Configures a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryConfigurePayload} body Registry configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryConfigure: async (id: number, body: RegistriesRegistryConfigurePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('registryConfigure', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('registryConfigure', 'body', body)
            const localVarPath = `/registries/{id}/configure`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new registry. **Access policy**: restricted
         * @summary Create a new registry
         * @param {RegistriesRegistryCreatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryCreate: async (body: RegistriesRegistryCreatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('registryCreate', 'body', body)
            const localVarPath = `/registries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a registry **Access policy**: restricted
         * @summary Remove a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('registryDelete', 'id', id)
            const localVarPath = `/registries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a registry. **Access policy**: restricted
         * @summary Inspect a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryInspect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('registryInspect', 'id', id)
            const localVarPath = `/registries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all registries based on the current user authorizations. Will return all registries if using an administrator account otherwise it will only return authorized registries. **Access policy**: restricted
         * @summary List Registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/registries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a registry **Access policy**: restricted
         * @summary Update a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryUpdatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryUpdate: async (id: number, body: RegistriesRegistryUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('registryUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('registryUpdate', 'body', body)
            const localVarPath = `/registries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegistriesApi - functional programming interface
 * @export
 */
export const RegistriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegistriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Configures a registry. **Access policy**: restricted
         * @summary Configures a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryConfigurePayload} body Registry configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryConfigure(id: number, body: RegistriesRegistryConfigurePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryConfigure(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new registry. **Access policy**: restricted
         * @summary Create a new registry
         * @param {RegistriesRegistryCreatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryCreate(body: RegistriesRegistryCreatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerRegistry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a registry **Access policy**: restricted
         * @summary Remove a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve details about a registry. **Access policy**: restricted
         * @summary Inspect a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryInspect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerRegistry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryInspect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all registries based on the current user authorizations. Will return all registries if using an administrator account otherwise it will only return authorized registries. **Access policy**: restricted
         * @summary List Registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerRegistry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a registry **Access policy**: restricted
         * @summary Update a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryUpdatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registryUpdate(id: number, body: RegistriesRegistryUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerRegistry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registryUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RegistriesApi - factory interface
 * @export
 */
export const RegistriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegistriesApiFp(configuration)
    return {
        /**
         * Configures a registry. **Access policy**: restricted
         * @summary Configures a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryConfigurePayload} body Registry configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryConfigure(id: number, body: RegistriesRegistryConfigurePayload, options?: any): AxiosPromise<void> {
            return localVarFp.registryConfigure(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new registry. **Access policy**: restricted
         * @summary Create a new registry
         * @param {RegistriesRegistryCreatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryCreate(body: RegistriesRegistryCreatePayload, options?: any): AxiosPromise<PortainerRegistry> {
            return localVarFp.registryCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a registry **Access policy**: restricted
         * @summary Remove a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.registryDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details about a registry. **Access policy**: restricted
         * @summary Inspect a registry
         * @param {number} id Registry identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryInspect(id: number, options?: any): AxiosPromise<PortainerRegistry> {
            return localVarFp.registryInspect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all registries based on the current user authorizations. Will return all registries if using an administrator account otherwise it will only return authorized registries. **Access policy**: restricted
         * @summary List Registries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryList(options?: any): AxiosPromise<Array<PortainerRegistry>> {
            return localVarFp.registryList(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a registry **Access policy**: restricted
         * @summary Update a registry
         * @param {number} id Registry identifier
         * @param {RegistriesRegistryUpdatePayload} body Registry details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registryUpdate(id: number, body: RegistriesRegistryUpdatePayload, options?: any): AxiosPromise<PortainerRegistry> {
            return localVarFp.registryUpdate(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegistriesApi - object-oriented interface
 * @export
 * @class RegistriesApi
 * @extends {BaseAPI}
 */
export class RegistriesApi extends BaseAPI {
    /**
     * Configures a registry. **Access policy**: restricted
     * @summary Configures a registry
     * @param {number} id Registry identifier
     * @param {RegistriesRegistryConfigurePayload} body Registry configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registryConfigure(id: number, body: RegistriesRegistryConfigurePayload, options?: AxiosRequestConfig) {
        return RegistriesApiFp(this.configuration).registryConfigure(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new registry. **Access policy**: restricted
     * @summary Create a new registry
     * @param {RegistriesRegistryCreatePayload} body Registry details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registryCreate(body: RegistriesRegistryCreatePayload, options?: AxiosRequestConfig) {
        return RegistriesApiFp(this.configuration).registryCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a registry **Access policy**: restricted
     * @summary Remove a registry
     * @param {number} id Registry identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registryDelete(id: number, options?: AxiosRequestConfig) {
        return RegistriesApiFp(this.configuration).registryDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details about a registry. **Access policy**: restricted
     * @summary Inspect a registry
     * @param {number} id Registry identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registryInspect(id: number, options?: AxiosRequestConfig) {
        return RegistriesApiFp(this.configuration).registryInspect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all registries based on the current user authorizations. Will return all registries if using an administrator account otherwise it will only return authorized registries. **Access policy**: restricted
     * @summary List Registries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registryList(options?: AxiosRequestConfig) {
        return RegistriesApiFp(this.configuration).registryList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a registry **Access policy**: restricted
     * @summary Update a registry
     * @param {number} id Registry identifier
     * @param {RegistriesRegistryUpdatePayload} body Registry details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegistriesApi
     */
    public registryUpdate(id: number, body: RegistriesRegistryUpdatePayload, options?: AxiosRequestConfig) {
        return RegistriesApiFp(this.configuration).registryUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ResourceControlsApi - axios parameter creator
 * @export
 */
export const ResourceControlsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new resource control to restrict access to a Docker resource. **Access policy**: administrator
         * @summary Create a new resource control
         * @param {ResourcecontrolsResourceControlCreatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlCreate: async (body: ResourcecontrolsResourceControlCreatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('resourceControlCreate', 'body', body)
            const localVarPath = `/resource_controls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a resource control. **Access policy**: administrator
         * @summary Remove a resource control
         * @param {number} id Resource control identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resourceControlDelete', 'id', id)
            const localVarPath = `/resource_controls/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a resource control **Access policy**: authenticated
         * @summary Update a resource control
         * @param {number} id Resource control identifier
         * @param {ResourcecontrolsResourceControlUpdatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlUpdate: async (id: number, body: ResourcecontrolsResourceControlUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resourceControlUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('resourceControlUpdate', 'body', body)
            const localVarPath = `/resource_controls/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceControlsApi - functional programming interface
 * @export
 */
export const ResourceControlsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceControlsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new resource control to restrict access to a Docker resource. **Access policy**: administrator
         * @summary Create a new resource control
         * @param {ResourcecontrolsResourceControlCreatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceControlCreate(body: ResourcecontrolsResourceControlCreatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerResourceControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourceControlCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a resource control. **Access policy**: administrator
         * @summary Remove a resource control
         * @param {number} id Resource control identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceControlDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourceControlDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a resource control **Access policy**: authenticated
         * @summary Update a resource control
         * @param {number} id Resource control identifier
         * @param {ResourcecontrolsResourceControlUpdatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resourceControlUpdate(id: number, body: ResourcecontrolsResourceControlUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerResourceControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resourceControlUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ResourceControlsApi - factory interface
 * @export
 */
export const ResourceControlsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceControlsApiFp(configuration)
    return {
        /**
         * Create a new resource control to restrict access to a Docker resource. **Access policy**: administrator
         * @summary Create a new resource control
         * @param {ResourcecontrolsResourceControlCreatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlCreate(body: ResourcecontrolsResourceControlCreatePayload, options?: any): AxiosPromise<PortainerResourceControl> {
            return localVarFp.resourceControlCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a resource control. **Access policy**: administrator
         * @summary Remove a resource control
         * @param {number} id Resource control identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.resourceControlDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a resource control **Access policy**: authenticated
         * @summary Update a resource control
         * @param {number} id Resource control identifier
         * @param {ResourcecontrolsResourceControlUpdatePayload} body Resource control details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resourceControlUpdate(id: number, body: ResourcecontrolsResourceControlUpdatePayload, options?: any): AxiosPromise<PortainerResourceControl> {
            return localVarFp.resourceControlUpdate(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceControlsApi - object-oriented interface
 * @export
 * @class ResourceControlsApi
 * @extends {BaseAPI}
 */
export class ResourceControlsApi extends BaseAPI {
    /**
     * Create a new resource control to restrict access to a Docker resource. **Access policy**: administrator
     * @summary Create a new resource control
     * @param {ResourcecontrolsResourceControlCreatePayload} body Resource control details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceControlsApi
     */
    public resourceControlCreate(body: ResourcecontrolsResourceControlCreatePayload, options?: AxiosRequestConfig) {
        return ResourceControlsApiFp(this.configuration).resourceControlCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a resource control. **Access policy**: administrator
     * @summary Remove a resource control
     * @param {number} id Resource control identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceControlsApi
     */
    public resourceControlDelete(id: number, options?: AxiosRequestConfig) {
        return ResourceControlsApiFp(this.configuration).resourceControlDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a resource control **Access policy**: authenticated
     * @summary Update a resource control
     * @param {number} id Resource control identifier
     * @param {ResourcecontrolsResourceControlUpdatePayload} body Resource control details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceControlsApi
     */
    public resourceControlUpdate(id: number, body: ResourcecontrolsResourceControlUpdatePayload, options?: AxiosRequestConfig) {
        return ResourceControlsApiFp(this.configuration).resourceControlUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all roles available for use **Access policy**: administrator
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * List all roles available for use **Access policy**: administrator
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roleList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerRole>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roleList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * List all roles available for use **Access policy**: administrator
         * @summary List roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleList(options?: any): AxiosPromise<Array<PortainerRole>> {
            return localVarFp.roleList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * List all roles available for use **Access policy**: administrator
     * @summary List roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public roleList(options?: AxiosRequestConfig) {
        return RolesApiFp(this.configuration).roleList(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve Portainer settings. **Access policy**: administrator
         * @summary Retrieve Portainer settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsInspect: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve public settings. Returns a small set of settings that are not reserved to administrators only. **Access policy**: public
         * @summary Retrieve Portainer public settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPublic: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update Portainer settings. **Access policy**: administrator
         * @summary Update Portainer settings
         * @param {SettingsSettingsUpdatePayload} body New settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsUpdate: async (body: SettingsSettingsUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('settingsUpdate', 'body', body)
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve Portainer settings. **Access policy**: administrator
         * @summary Retrieve Portainer settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsInspect(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsInspect(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve public settings. Returns a small set of settings that are not reserved to administrators only. **Access policy**: public
         * @summary Retrieve Portainer public settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsPublic(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsPublicSettingsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsPublic(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update Portainer settings. **Access policy**: administrator
         * @summary Update Portainer settings
         * @param {SettingsSettingsUpdatePayload} body New settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsUpdate(body: SettingsSettingsUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * Retrieve Portainer settings. **Access policy**: administrator
         * @summary Retrieve Portainer settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsInspect(options?: any): AxiosPromise<PortainerSettings> {
            return localVarFp.settingsInspect(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve public settings. Returns a small set of settings that are not reserved to administrators only. **Access policy**: public
         * @summary Retrieve Portainer public settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsPublic(options?: any): AxiosPromise<SettingsPublicSettingsResponse> {
            return localVarFp.settingsPublic(options).then((request) => request(axios, basePath));
        },
        /**
         * Update Portainer settings. **Access policy**: administrator
         * @summary Update Portainer settings
         * @param {SettingsSettingsUpdatePayload} body New settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsUpdate(body: SettingsSettingsUpdatePayload, options?: any): AxiosPromise<PortainerSettings> {
            return localVarFp.settingsUpdate(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * Retrieve Portainer settings. **Access policy**: administrator
     * @summary Retrieve Portainer settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsInspect(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsInspect(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve public settings. Returns a small set of settings that are not reserved to administrators only. **Access policy**: public
     * @summary Retrieve Portainer public settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsPublic(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsPublic(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update Portainer settings. **Access policy**: administrator
     * @summary Update Portainer settings
     * @param {SettingsSettingsUpdatePayload} body New settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsUpdate(body: SettingsSettingsUpdatePayload, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SslApi - axios parameter creator
 * @export
 */
export const SslApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the ssl settings. **Access policy**: administrator
         * @summary Inspect the ssl settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLInspect: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ssl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the ssl settings. **Access policy**: administrator
         * @summary Update the ssl settings
         * @param {SslSslUpdatePayload} body SSL Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLUpdate: async (body: SslSslUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('sSLUpdate', 'body', body)
            const localVarPath = `/ssl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SslApi - functional programming interface
 * @export
 */
export const SslApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SslApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the ssl settings. **Access policy**: administrator
         * @summary Inspect the ssl settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sSLInspect(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerSSLSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sSLInspect(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the ssl settings. **Access policy**: administrator
         * @summary Update the ssl settings
         * @param {SslSslUpdatePayload} body SSL Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sSLUpdate(body: SslSslUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sSLUpdate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SslApi - factory interface
 * @export
 */
export const SslApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SslApiFp(configuration)
    return {
        /**
         * Retrieve the ssl settings. **Access policy**: administrator
         * @summary Inspect the ssl settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLInspect(options?: any): AxiosPromise<PortainerSSLSettings> {
            return localVarFp.sSLInspect(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the ssl settings. **Access policy**: administrator
         * @summary Update the ssl settings
         * @param {SslSslUpdatePayload} body SSL Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sSLUpdate(body: SslSslUpdatePayload, options?: any): AxiosPromise<void> {
            return localVarFp.sSLUpdate(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SslApi - object-oriented interface
 * @export
 * @class SslApi
 * @extends {BaseAPI}
 */
export class SslApi extends BaseAPI {
    /**
     * Retrieve the ssl settings. **Access policy**: administrator
     * @summary Inspect the ssl settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SslApi
     */
    public sSLInspect(options?: AxiosRequestConfig) {
        return SslApiFp(this.configuration).sSLInspect(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the ssl settings. **Access policy**: administrator
     * @summary Update the ssl settings
     * @param {SslSslUpdatePayload} body SSL Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SslApi
     */
    public sSLUpdate(body: SslSslUpdatePayload, options?: AxiosRequestConfig) {
        return SslApiFp(this.configuration).sSLUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StacksApi - axios parameter creator
 * @export
 */
export const StacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: administrator
         * @summary Associate an orphaned stack to a new environment(endpoint)
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {number} swarmId Swarm identifier
         * @param {boolean} orphanedRunning Indicates whether the stack is orphaned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackAssociate: async (id: number, endpointId: number, swarmId: number, orphanedRunning: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stackAssociate', 'id', id)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackAssociate', 'endpointId', endpointId)
            // verify required parameter 'swarmId' is not null or undefined
            assertParamExists('stackAssociate', 'swarmId', swarmId)
            // verify required parameter 'orphanedRunning' is not null or undefined
            assertParamExists('stackAssociate', 'orphanedRunning', orphanedRunning)
            const localVarPath = `/stacks/{id}/associate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            if (swarmId !== undefined) {
                localVarQueryParameter['swarmId'] = swarmId;
            }

            if (orphanedRunning !== undefined) {
                localVarQueryParameter['orphanedRunning'] = orphanedRunning;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment(endpoint) specified via the environment(endpoint) identifier. **Access policy**: authenticated
         * @summary Deploy a new stack
         * @param {1 | 2 | 3} type Stack deployment type. Possible values: 1 (Swarm stack), 2 (Compose stack) or 3 (Kubernetes stack).
         * @param {'string' | 'file' | 'repository' | 'url'} method Stack deployment method. Possible values: file, string, repository or url.
         * @param {number} endpointId Identifier of the environment(endpoint) that will be used to deploy the stack
         * @param {object} body for body documentation see the relevant /stacks/create/{type}/{method} endpoint
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stackCreate: async (type: 1 | 2 | 3, method: 'string' | 'file' | 'repository' | 'url', endpointId: number, body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('stackCreate', 'type', type)
            // verify required parameter 'method' is not null or undefined
            assertParamExists('stackCreate', 'method', method)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackCreate', 'endpointId', endpointId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('stackCreate', 'body', body)
            const localVarPath = `/stacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} name Name of the stack
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{\\\&#39;name\\\&#39;: \\\&#39;name\\\&#39;, \\\&#39;value\\\&#39;: \\\&#39;value\\\&#39;}].
         * @param {File} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneFile: async (endpointId: number, name: string, env?: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackCreateDockerStandaloneFile', 'endpointId', endpointId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('stackCreateDockerStandaloneFile', 'name', name)
            const localVarPath = `/stacks/create/standalone/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


            if (name !== undefined) { 
                localVarFormParams.append('Name', name as any);
            }
    
            if (env !== undefined) { 
                localVarFormParams.append('Env', env as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksComposeStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneRepository: async (endpointId: number, body: StacksComposeStackFromGitRepositoryPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackCreateDockerStandaloneRepository', 'endpointId', endpointId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('stackCreateDockerStandaloneRepository', 'body', body)
            const localVarPath = `/stacks/create/standalone/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a text
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksComposeStackFromFileContentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneString: async (endpointId: number, body: StacksComposeStackFromFileContentPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackCreateDockerStandaloneString', 'endpointId', endpointId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('stackCreateDockerStandaloneString', 'body', body)
            const localVarPath = `/stacks/create/standalone/string`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [name] Name of the stack
         * @param {string} [swarmID] Swarm cluster identifier.
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{\\\&#39;name\\\&#39;: \\\&#39;name\\\&#39;, \\\&#39;value\\\&#39;: \\\&#39;value\\\&#39;}]. Optional
         * @param {File} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmFile: async (endpointId: number, name?: string, swarmID?: string, env?: string, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackCreateDockerSwarmFile', 'endpointId', endpointId)
            const localVarPath = `/stacks/create/swarm/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


            if (name !== undefined) { 
                localVarFormParams.append('Name', name as any);
            }
    
            if (swarmID !== undefined) { 
                localVarFormParams.append('SwarmID', swarmID as any);
            }
    
            if (env !== undefined) { 
                localVarFormParams.append('Env', env as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a git repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksSwarmStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmRepository: async (endpointId: number, body: StacksSwarmStackFromGitRepositoryPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackCreateDockerSwarmRepository', 'endpointId', endpointId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('stackCreateDockerSwarmRepository', 'body', body)
            const localVarPath = `/stacks/create/swarm/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a text
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksSwarmStackFromFileContentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmString: async (endpointId: number, body: StacksSwarmStackFromFileContentPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackCreateDockerSwarmString', 'endpointId', endpointId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('stackCreateDockerSwarmString', 'body', body)
            const localVarPath = `/stacks/create/swarm/string`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksKubernetesStringDeploymentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesFile: async (endpointId: number, body: StacksKubernetesStringDeploymentPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackCreateKubernetesFile', 'endpointId', endpointId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('stackCreateKubernetesFile', 'body', body)
            const localVarPath = `/stacks/create/kubernetes/string`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a git repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksKubernetesGitDeploymentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesGit: async (endpointId: number, body: StacksKubernetesGitDeploymentPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackCreateKubernetesGit', 'endpointId', endpointId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('stackCreateKubernetesGit', 'body', body)
            const localVarPath = `/stacks/create/kubernetes/repository`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a url
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksKubernetesManifestURLDeploymentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesUrl: async (endpointId: number, body: StacksKubernetesManifestURLDeploymentPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackCreateKubernetesUrl', 'endpointId', endpointId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('stackCreateKubernetesUrl', 'body', body)
            const localVarPath = `/stacks/create/kubernetes/url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackDelete: async (id: number, endpointId: number, external?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stackDelete', 'id', id)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackDelete', 'endpointId', endpointId)
            const localVarPath = `/stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (external !== undefined) {
                localVarQueryParameter['external'] = external;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove Kubernetes stacks by name
         * @param {string} name Stack name
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackDeleteKubernetesByName: async (name: string, endpointId: number, external?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('stackDeleteKubernetesByName', 'name', name)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackDeleteKubernetesByName', 'endpointId', endpointId)
            const localVarPath = `/stacks/name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (external !== undefined) {
                localVarQueryParameter['external'] = external;
            }

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Stack file content. **Access policy**: restricted
         * @summary Retrieve the content of the Stack file for the specified stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackFileInspect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stackFileInspect', 'id', id)
            const localVarPath = `/stacks/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pull and redeploy a stack via Git **Access policy**: authenticated
         * @summary Redeploy a stack
         * @param {number} id Stack identifier
         * @param {StacksStackGitRedployPayload} body Git configs for pull and redeploy of a stack. **StackName** may only be populated for Kuberenetes stacks, and if specified with a blank string, it will be set to blank
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackGitRedeploy: async (id: number, body: StacksStackGitRedployPayload, endpointId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stackGitRedeploy', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('stackGitRedeploy', 'body', body)
            const localVarPath = `/stacks/{id}/git/redeploy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a stack. **Access policy**: restricted
         * @summary Inspect a stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackInspect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stackInspect', 'id', id)
            const localVarPath = `/stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all stacks based on the current user authorizations. Will return all stacks if using an administrator account otherwise it will only return the list of stacks the user have access to. Limited stacks will not be returned by this endpoint. **Access policy**: authenticated
         * @summary List stacks
         * @param {string} [filters] Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {\&#39;SwarmID\&#39;: \&#39;jpofkc0i9uo9wtx1zesuk649w\&#39;} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackList: async (filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack. **Access policy**: authenticated
         * @summary Migrate a stack to another environment(endpoint)
         * @param {number} id Stack identifier
         * @param {StacksStackMigratePayload} body Stack migration details
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackMigrate: async (id: number, body: StacksStackMigratePayload, endpointId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stackMigrate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('stackMigrate', 'body', body)
            const localVarPath = `/stacks/{id}/migrate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a stopped Stack. **Access policy**: authenticated
         * @summary Starts a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStart: async (id: number, endpointId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stackStart', 'id', id)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackStart', 'endpointId', endpointId)
            const localVarPath = `/stacks/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stops a stopped Stack. **Access policy**: authenticated
         * @summary Stops a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStop: async (id: number, endpointId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stackStop', 'id', id)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackStop', 'endpointId', endpointId)
            const localVarPath = `/stacks/{id}/stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a stack, only for file based stacks. **Access policy**: authenticated
         * @summary Update a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {StacksUpdateSwarmStackPayload} body Stack details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdate: async (id: number, endpointId: number, body: StacksUpdateSwarmStackPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stackUpdate', 'id', id)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('stackUpdate', 'endpointId', endpointId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('stackUpdate', 'body', body)
            const localVarPath = `/stacks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate **Access policy**: authenticated
         * @summary Update a stack\'s Git configs
         * @param {number} id Stack identifier
         * @param {StacksStackGitUpdatePayload} body Git configs for pull and redeploy a stack
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdateGit: async (id: number, body: StacksStackGitUpdatePayload, endpointId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stackUpdateGit', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('stackUpdateGit', 'body', body)
            const localVarPath = `/stacks/{id}/git`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: public
         * @summary Webhook for triggering stack updates from git
         * @param {string} webhookID Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookInvoke: async (webhookID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookID' is not null or undefined
            assertParamExists('webhookInvoke', 'webhookID', webhookID)
            const localVarPath = `/stacks/webhooks/{webhookID}`
                .replace(`{${"webhookID"}}`, encodeURIComponent(String(webhookID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StacksApi - functional programming interface
 * @export
 */
export const StacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StacksApiAxiosParamCreator(configuration)
    return {
        /**
         * **Access policy**: administrator
         * @summary Associate an orphaned stack to a new environment(endpoint)
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {number} swarmId Swarm identifier
         * @param {boolean} orphanedRunning Indicates whether the stack is orphaned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackAssociate(id: number, endpointId: number, swarmId: number, orphanedRunning: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackAssociate(id, endpointId, swarmId, orphanedRunning, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deploy a new stack into a Docker environment(endpoint) specified via the environment(endpoint) identifier. **Access policy**: authenticated
         * @summary Deploy a new stack
         * @param {1 | 2 | 3} type Stack deployment type. Possible values: 1 (Swarm stack), 2 (Compose stack) or 3 (Kubernetes stack).
         * @param {'string' | 'file' | 'repository' | 'url'} method Stack deployment method. Possible values: file, string, repository or url.
         * @param {number} endpointId Identifier of the environment(endpoint) that will be used to deploy the stack
         * @param {object} body for body documentation see the relevant /stacks/create/{type}/{method} endpoint
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stackCreate(type: 1 | 2 | 3, method: 'string' | 'file' | 'repository' | 'url', endpointId: number, body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackCreate(type, method, endpointId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} name Name of the stack
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{\\\&#39;name\\\&#39;: \\\&#39;name\\\&#39;, \\\&#39;value\\\&#39;: \\\&#39;value\\\&#39;}].
         * @param {File} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackCreateDockerStandaloneFile(endpointId: number, name: string, env?: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackCreateDockerStandaloneFile(endpointId, name, env, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksComposeStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackCreateDockerStandaloneRepository(endpointId: number, body: StacksComposeStackFromGitRepositoryPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackCreateDockerStandaloneRepository(endpointId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a text
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksComposeStackFromFileContentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackCreateDockerStandaloneString(endpointId: number, body: StacksComposeStackFromFileContentPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackCreateDockerStandaloneString(endpointId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [name] Name of the stack
         * @param {string} [swarmID] Swarm cluster identifier.
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{\\\&#39;name\\\&#39;: \\\&#39;name\\\&#39;, \\\&#39;value\\\&#39;: \\\&#39;value\\\&#39;}]. Optional
         * @param {File} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackCreateDockerSwarmFile(endpointId: number, name?: string, swarmID?: string, env?: string, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackCreateDockerSwarmFile(endpointId, name, swarmID, env, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a git repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksSwarmStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackCreateDockerSwarmRepository(endpointId: number, body: StacksSwarmStackFromGitRepositoryPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackCreateDockerSwarmRepository(endpointId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a text
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksSwarmStackFromFileContentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackCreateDockerSwarmString(endpointId: number, body: StacksSwarmStackFromFileContentPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackCreateDockerSwarmString(endpointId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksKubernetesStringDeploymentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackCreateKubernetesFile(endpointId: number, body: StacksKubernetesStringDeploymentPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackCreateKubernetesFile(endpointId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a git repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksKubernetesGitDeploymentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackCreateKubernetesGit(endpointId: number, body: StacksKubernetesGitDeploymentPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackCreateKubernetesGit(endpointId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a url
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksKubernetesManifestURLDeploymentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackCreateKubernetesUrl(endpointId: number, body: StacksKubernetesManifestURLDeploymentPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackCreateKubernetesUrl(endpointId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackDelete(id: number, endpointId: number, external?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackDelete(id, endpointId, external, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove Kubernetes stacks by name
         * @param {string} name Stack name
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackDeleteKubernetesByName(name: string, endpointId: number, external?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackDeleteKubernetesByName(name, endpointId, external, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Stack file content. **Access policy**: restricted
         * @summary Retrieve the content of the Stack file for the specified stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackFileInspect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StacksStackFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackFileInspect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Pull and redeploy a stack via Git **Access policy**: authenticated
         * @summary Redeploy a stack
         * @param {number} id Stack identifier
         * @param {StacksStackGitRedployPayload} body Git configs for pull and redeploy of a stack. **StackName** may only be populated for Kuberenetes stacks, and if specified with a blank string, it will be set to blank
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackGitRedeploy(id: number, body: StacksStackGitRedployPayload, endpointId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackGitRedeploy(id, body, endpointId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve details about a stack. **Access policy**: restricted
         * @summary Inspect a stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackInspect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackInspect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all stacks based on the current user authorizations. Will return all stacks if using an administrator account otherwise it will only return the list of stacks the user have access to. Limited stacks will not be returned by this endpoint. **Access policy**: authenticated
         * @summary List stacks
         * @param {string} [filters] Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {\&#39;SwarmID\&#39;: \&#39;jpofkc0i9uo9wtx1zesuk649w\&#39;} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackList(filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerStack>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackList(filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack. **Access policy**: authenticated
         * @summary Migrate a stack to another environment(endpoint)
         * @param {number} id Stack identifier
         * @param {StacksStackMigratePayload} body Stack migration details
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackMigrate(id: number, body: StacksStackMigratePayload, endpointId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackMigrate(id, body, endpointId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Starts a stopped Stack. **Access policy**: authenticated
         * @summary Starts a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackStart(id: number, endpointId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackStart(id, endpointId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Stops a stopped Stack. **Access policy**: authenticated
         * @summary Stops a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackStop(id: number, endpointId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackStop(id, endpointId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a stack, only for file based stacks. **Access policy**: authenticated
         * @summary Update a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {StacksUpdateSwarmStackPayload} body Stack details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackUpdate(id: number, endpointId: number, body: StacksUpdateSwarmStackPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackUpdate(id, endpointId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate **Access policy**: authenticated
         * @summary Update a stack\'s Git configs
         * @param {number} id Stack identifier
         * @param {StacksStackGitUpdatePayload} body Git configs for pull and redeploy a stack
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stackUpdateGit(id: number, body: StacksStackGitUpdatePayload, endpointId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerStack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stackUpdateGit(id, body, endpointId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: public
         * @summary Webhook for triggering stack updates from git
         * @param {string} webhookID Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhookInvoke(webhookID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhookInvoke(webhookID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StacksApi - factory interface
 * @export
 */
export const StacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StacksApiFp(configuration)
    return {
        /**
         * **Access policy**: administrator
         * @summary Associate an orphaned stack to a new environment(endpoint)
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {number} swarmId Swarm identifier
         * @param {boolean} orphanedRunning Indicates whether the stack is orphaned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackAssociate(id: number, endpointId: number, swarmId: number, orphanedRunning: boolean, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackAssociate(id, endpointId, swarmId, orphanedRunning, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy a new stack into a Docker environment(endpoint) specified via the environment(endpoint) identifier. **Access policy**: authenticated
         * @summary Deploy a new stack
         * @param {1 | 2 | 3} type Stack deployment type. Possible values: 1 (Swarm stack), 2 (Compose stack) or 3 (Kubernetes stack).
         * @param {'string' | 'file' | 'repository' | 'url'} method Stack deployment method. Possible values: file, string, repository or url.
         * @param {number} endpointId Identifier of the environment(endpoint) that will be used to deploy the stack
         * @param {object} body for body documentation see the relevant /stacks/create/{type}/{method} endpoint
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stackCreate(type: 1 | 2 | 3, method: 'string' | 'file' | 'repository' | 'url', endpointId: number, body: object, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackCreate(type, method, endpointId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} name Name of the stack
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{\\\&#39;name\\\&#39;: \\\&#39;name\\\&#39;, \\\&#39;value\\\&#39;: \\\&#39;value\\\&#39;}].
         * @param {File} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneFile(endpointId: number, name: string, env?: string, file?: File, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackCreateDockerStandaloneFile(endpointId, name, env, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksComposeStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneRepository(endpointId: number, body: StacksComposeStackFromGitRepositoryPayload, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackCreateDockerStandaloneRepository(endpointId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new compose stack from a text
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksComposeStackFromFileContentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerStandaloneString(endpointId: number, body: StacksComposeStackFromFileContentPayload, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackCreateDockerStandaloneString(endpointId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {string} [name] Name of the stack
         * @param {string} [swarmID] Swarm cluster identifier.
         * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{\\\&#39;name\\\&#39;: \\\&#39;name\\\&#39;, \\\&#39;value\\\&#39;: \\\&#39;value\\\&#39;}]. Optional
         * @param {File} [file] Stack file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmFile(endpointId: number, name?: string, swarmID?: string, env?: string, file?: File, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackCreateDockerSwarmFile(endpointId, name, swarmID, env, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a git repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksSwarmStackFromGitRepositoryPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmRepository(endpointId: number, body: StacksSwarmStackFromGitRepositoryPayload, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackCreateDockerSwarmRepository(endpointId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new swarm stack from a text
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksSwarmStackFromFileContentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateDockerSwarmString(endpointId: number, body: StacksSwarmStackFromFileContentPayload, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackCreateDockerSwarmString(endpointId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a file
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksKubernetesStringDeploymentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesFile(endpointId: number, body: StacksKubernetesStringDeploymentPayload, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackCreateKubernetesFile(endpointId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a git repository
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksKubernetesGitDeploymentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesGit(endpointId: number, body: StacksKubernetesGitDeploymentPayload, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackCreateKubernetesGit(endpointId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
         * @summary Deploy a new kubernetes stack from a url
         * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
         * @param {StacksKubernetesManifestURLDeploymentPayload} body stack config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackCreateKubernetesUrl(endpointId: number, body: StacksKubernetesManifestURLDeploymentPayload, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackCreateKubernetesUrl(endpointId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackDelete(id: number, endpointId: number, external?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.stackDelete(id, endpointId, external, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a stack. **Access policy**: restricted
         * @summary Remove Kubernetes stacks by name
         * @param {string} name Stack name
         * @param {number} endpointId Environment identifier
         * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackDeleteKubernetesByName(name: string, endpointId: number, external?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.stackDeleteKubernetesByName(name, endpointId, external, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Stack file content. **Access policy**: restricted
         * @summary Retrieve the content of the Stack file for the specified stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackFileInspect(id: number, options?: any): AxiosPromise<StacksStackFileResponse> {
            return localVarFp.stackFileInspect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Pull and redeploy a stack via Git **Access policy**: authenticated
         * @summary Redeploy a stack
         * @param {number} id Stack identifier
         * @param {StacksStackGitRedployPayload} body Git configs for pull and redeploy of a stack. **StackName** may only be populated for Kuberenetes stacks, and if specified with a blank string, it will be set to blank
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackGitRedeploy(id: number, body: StacksStackGitRedployPayload, endpointId?: number, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackGitRedeploy(id, body, endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details about a stack. **Access policy**: restricted
         * @summary Inspect a stack
         * @param {number} id Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackInspect(id: number, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackInspect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all stacks based on the current user authorizations. Will return all stacks if using an administrator account otherwise it will only return the list of stacks the user have access to. Limited stacks will not be returned by this endpoint. **Access policy**: authenticated
         * @summary List stacks
         * @param {string} [filters] Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {\&#39;SwarmID\&#39;: \&#39;jpofkc0i9uo9wtx1zesuk649w\&#39;} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackList(filters?: string, options?: any): AxiosPromise<Array<PortainerStack>> {
            return localVarFp.stackList(filters, options).then((request) => request(axios, basePath));
        },
        /**
         * Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack. **Access policy**: authenticated
         * @summary Migrate a stack to another environment(endpoint)
         * @param {number} id Stack identifier
         * @param {StacksStackMigratePayload} body Stack migration details
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackMigrate(id: number, body: StacksStackMigratePayload, endpointId?: number, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackMigrate(id, body, endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a stopped Stack. **Access policy**: authenticated
         * @summary Starts a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStart(id: number, endpointId: number, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackStart(id, endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * Stops a stopped Stack. **Access policy**: authenticated
         * @summary Stops a stopped Stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackStop(id: number, endpointId: number, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackStop(id, endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a stack, only for file based stacks. **Access policy**: authenticated
         * @summary Update a stack
         * @param {number} id Stack identifier
         * @param {number} endpointId Environment identifier
         * @param {StacksUpdateSwarmStackPayload} body Stack details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdate(id: number, endpointId: number, body: StacksUpdateSwarmStackPayload, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackUpdate(id, endpointId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate **Access policy**: authenticated
         * @summary Update a stack\'s Git configs
         * @param {number} id Stack identifier
         * @param {StacksStackGitUpdatePayload} body Git configs for pull and redeploy a stack
         * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stackUpdateGit(id: number, body: StacksStackGitUpdatePayload, endpointId?: number, options?: any): AxiosPromise<PortainerStack> {
            return localVarFp.stackUpdateGit(id, body, endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: public
         * @summary Webhook for triggering stack updates from git
         * @param {string} webhookID Stack identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhookInvoke(webhookID: string, options?: any): AxiosPromise<void> {
            return localVarFp.webhookInvoke(webhookID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StacksApi - object-oriented interface
 * @export
 * @class StacksApi
 * @extends {BaseAPI}
 */
export class StacksApi extends BaseAPI {
    /**
     * **Access policy**: administrator
     * @summary Associate an orphaned stack to a new environment(endpoint)
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {number} swarmId Swarm identifier
     * @param {boolean} orphanedRunning Indicates whether the stack is orphaned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackAssociate(id: number, endpointId: number, swarmId: number, orphanedRunning: boolean, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackAssociate(id, endpointId, swarmId, orphanedRunning, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy a new stack into a Docker environment(endpoint) specified via the environment(endpoint) identifier. **Access policy**: authenticated
     * @summary Deploy a new stack
     * @param {1 | 2 | 3} type Stack deployment type. Possible values: 1 (Swarm stack), 2 (Compose stack) or 3 (Kubernetes stack).
     * @param {'string' | 'file' | 'repository' | 'url'} method Stack deployment method. Possible values: file, string, repository or url.
     * @param {number} endpointId Identifier of the environment(endpoint) that will be used to deploy the stack
     * @param {object} body for body documentation see the relevant /stacks/create/{type}/{method} endpoint
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreate(type: 1 | 2 | 3, method: 'string' | 'file' | 'repository' | 'url', endpointId: number, body: object, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackCreate(type, method, endpointId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new compose stack from a file
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {string} name Name of the stack
     * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{\\\&#39;name\\\&#39;: \\\&#39;name\\\&#39;, \\\&#39;value\\\&#39;: \\\&#39;value\\\&#39;}].
     * @param {File} [file] Stack file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateDockerStandaloneFile(endpointId: number, name: string, env?: string, file?: File, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackCreateDockerStandaloneFile(endpointId, name, env, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new compose stack from repository
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {StacksComposeStackFromGitRepositoryPayload} body stack config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateDockerStandaloneRepository(endpointId: number, body: StacksComposeStackFromGitRepositoryPayload, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackCreateDockerStandaloneRepository(endpointId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new compose stack from a text
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {StacksComposeStackFromFileContentPayload} body stack config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateDockerStandaloneString(endpointId: number, body: StacksComposeStackFromFileContentPayload, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackCreateDockerStandaloneString(endpointId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new swarm stack from a file
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {string} [name] Name of the stack
     * @param {string} [swarmID] Swarm cluster identifier.
     * @param {string} [env] Environment variables passed during deployment, represented as a JSON array [{\\\&#39;name\\\&#39;: \\\&#39;name\\\&#39;, \\\&#39;value\\\&#39;: \\\&#39;value\\\&#39;}]. Optional
     * @param {File} [file] Stack file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateDockerSwarmFile(endpointId: number, name?: string, swarmID?: string, env?: string, file?: File, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackCreateDockerSwarmFile(endpointId, name, swarmID, env, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new swarm stack from a git repository
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {StacksSwarmStackFromGitRepositoryPayload} body stack config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateDockerSwarmRepository(endpointId: number, body: StacksSwarmStackFromGitRepositoryPayload, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackCreateDockerSwarmRepository(endpointId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new swarm stack from a text
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {StacksSwarmStackFromFileContentPayload} body stack config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateDockerSwarmString(endpointId: number, body: StacksSwarmStackFromFileContentPayload, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackCreateDockerSwarmString(endpointId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new kubernetes stack from a file
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {StacksKubernetesStringDeploymentPayload} body stack config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateKubernetesFile(endpointId: number, body: StacksKubernetesStringDeploymentPayload, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackCreateKubernetesFile(endpointId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new kubernetes stack from a git repository
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {StacksKubernetesGitDeploymentPayload} body stack config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateKubernetesGit(endpointId: number, body: StacksKubernetesGitDeploymentPayload, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackCreateKubernetesGit(endpointId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy a new stack into a Docker environment specified via the environment identifier. **Access policy**: authenticated
     * @summary Deploy a new kubernetes stack from a url
     * @param {number} endpointId Identifier of the environment that will be used to deploy the stack
     * @param {StacksKubernetesManifestURLDeploymentPayload} body stack config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackCreateKubernetesUrl(endpointId: number, body: StacksKubernetesManifestURLDeploymentPayload, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackCreateKubernetesUrl(endpointId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a stack. **Access policy**: restricted
     * @summary Remove a stack
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackDelete(id: number, endpointId: number, external?: boolean, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackDelete(id, endpointId, external, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a stack. **Access policy**: restricted
     * @summary Remove Kubernetes stacks by name
     * @param {string} name Stack name
     * @param {number} endpointId Environment identifier
     * @param {boolean} [external] Set to true to delete an external stack. Only external Swarm stacks are supported
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackDeleteKubernetesByName(name: string, endpointId: number, external?: boolean, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackDeleteKubernetesByName(name, endpointId, external, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Stack file content. **Access policy**: restricted
     * @summary Retrieve the content of the Stack file for the specified stack
     * @param {number} id Stack identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackFileInspect(id: number, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackFileInspect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pull and redeploy a stack via Git **Access policy**: authenticated
     * @summary Redeploy a stack
     * @param {number} id Stack identifier
     * @param {StacksStackGitRedployPayload} body Git configs for pull and redeploy of a stack. **StackName** may only be populated for Kuberenetes stacks, and if specified with a blank string, it will be set to blank
     * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackGitRedeploy(id: number, body: StacksStackGitRedployPayload, endpointId?: number, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackGitRedeploy(id, body, endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details about a stack. **Access policy**: restricted
     * @summary Inspect a stack
     * @param {number} id Stack identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackInspect(id: number, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackInspect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all stacks based on the current user authorizations. Will return all stacks if using an administrator account otherwise it will only return the list of stacks the user have access to. Limited stacks will not be returned by this endpoint. **Access policy**: authenticated
     * @summary List stacks
     * @param {string} [filters] Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {\&#39;SwarmID\&#39;: \&#39;jpofkc0i9uo9wtx1zesuk649w\&#39;} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackList(filters?: string, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackList(filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack. **Access policy**: authenticated
     * @summary Migrate a stack to another environment(endpoint)
     * @param {number} id Stack identifier
     * @param {StacksStackMigratePayload} body Stack migration details
     * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackMigrate(id: number, body: StacksStackMigratePayload, endpointId?: number, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackMigrate(id, body, endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts a stopped Stack. **Access policy**: authenticated
     * @summary Starts a stopped Stack
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackStart(id: number, endpointId: number, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackStart(id, endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stops a stopped Stack. **Access policy**: authenticated
     * @summary Stops a stopped Stack
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackStop(id: number, endpointId: number, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackStop(id, endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a stack, only for file based stacks. **Access policy**: authenticated
     * @summary Update a stack
     * @param {number} id Stack identifier
     * @param {number} endpointId Environment identifier
     * @param {StacksUpdateSwarmStackPayload} body Stack details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackUpdate(id: number, endpointId: number, body: StacksUpdateSwarmStackPayload, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackUpdate(id, endpointId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate **Access policy**: authenticated
     * @summary Update a stack\'s Git configs
     * @param {number} id Stack identifier
     * @param {StacksStackGitUpdatePayload} body Git configs for pull and redeploy a stack
     * @param {number} [endpointId] Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public stackUpdateGit(id: number, body: StacksStackGitUpdatePayload, endpointId?: number, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).stackUpdateGit(id, body, endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: public
     * @summary Webhook for triggering stack updates from git
     * @param {string} webhookID Stack identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StacksApi
     */
    public webhookInvoke(webhookID: string, options?: AxiosRequestConfig) {
        return StacksApiFp(this.configuration).webhookInvoke(webhookID, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deprecated: use the `/system/status` endpoint instead. Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        statusInspect: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deprecated: use the `/system/nodes` endpoint instead. **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        statusNodesCount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deprecated: use the `/system/version` endpoint instead. Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        version: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * Deprecated: use the `/system/status` endpoint instead. Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async statusInspect(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusInspect(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deprecated: use the `/system/nodes` endpoint instead. **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async statusNodesCount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemNodesCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusNodesCount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deprecated: use the `/system/version` endpoint instead. Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async version(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.version(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * Deprecated: use the `/system/status` endpoint instead. Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        statusInspect(options?: any): AxiosPromise<SystemStatus> {
            return localVarFp.statusInspect(options).then((request) => request(axios, basePath));
        },
        /**
         * Deprecated: use the `/system/nodes` endpoint instead. **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        statusNodesCount(options?: any): AxiosPromise<SystemNodesCountResponse> {
            return localVarFp.statusNodesCount(options).then((request) => request(axios, basePath));
        },
        /**
         * Deprecated: use the `/system/version` endpoint instead. Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        version(options?: any): AxiosPromise<SystemVersionResponse> {
            return localVarFp.version(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * Deprecated: use the `/system/status` endpoint instead. Retrieve Portainer status **Access policy**: public
     * @summary Check Portainer status
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusInspect(options?: AxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusInspect(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deprecated: use the `/system/nodes` endpoint instead. **Access policy**: authenticated
     * @summary Retrieve the count of nodes
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusNodesCount(options?: AxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusNodesCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deprecated: use the `/system/version` endpoint instead. Check if portainer has an update available **Access policy**: authenticated
     * @summary Check for portainer updates
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public version(options?: AxiosRequestConfig) {
        return StatusApiFp(this.configuration).version(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary Retrieve system info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemNodesCount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upgrade Portainer to BE **Access policy**: administrator
         * @summary Upgrade Portainer to BE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUpgrade: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/upgrade`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * **Access policy**: authenticated
         * @summary Retrieve system info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemSystemInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemNodesCount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemNodesCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemNodesCount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Upgrade Portainer to BE **Access policy**: administrator
         * @summary Upgrade Portainer to BE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemUpgrade(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemUpgrade(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemVersionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * **Access policy**: authenticated
         * @summary Retrieve system info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfo(options?: any): AxiosPromise<SystemSystemInfoResponse> {
            return localVarFp.systemInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: authenticated
         * @summary Retrieve the count of nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemNodesCount(options?: any): AxiosPromise<SystemNodesCountResponse> {
            return localVarFp.systemNodesCount(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve Portainer status **Access policy**: public
         * @summary Check Portainer status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemStatus(options?: any): AxiosPromise<SystemStatus> {
            return localVarFp.systemStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * Upgrade Portainer to BE **Access policy**: administrator
         * @summary Upgrade Portainer to BE
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUpgrade(options?: any): AxiosPromise<SystemStatus> {
            return localVarFp.systemUpgrade(options).then((request) => request(axios, basePath));
        },
        /**
         * Check if portainer has an update available **Access policy**: authenticated
         * @summary Check for portainer updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemVersion(options?: any): AxiosPromise<SystemVersionResponse> {
            return localVarFp.systemVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * **Access policy**: authenticated
     * @summary Retrieve system info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemInfo(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: authenticated
     * @summary Retrieve the count of nodes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemNodesCount(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemNodesCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve Portainer status **Access policy**: public
     * @summary Check Portainer status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemStatus(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upgrade Portainer to BE **Access policy**: administrator
     * @summary Upgrade Portainer to BE
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemUpgrade(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemUpgrade(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if portainer has an update available **Access policy**: authenticated
     * @summary Check for portainer updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemVersion(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemVersion(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new tag. **Access policy**: administrator
         * @summary Create a new tag
         * @param {TagsTagCreatePayload} body Tag details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagCreate: async (body: TagsTagCreatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('tagCreate', 'body', body)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a tag. **Access policy**: administrator
         * @summary Remove a tag
         * @param {number} id Tag identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tagDelete', 'id', id)
            const localVarPath = `/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List tags. **Access policy**: authenticated
         * @summary List tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new tag. **Access policy**: administrator
         * @summary Create a new tag
         * @param {TagsTagCreatePayload} body Tag details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagCreate(body: TagsTagCreatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a tag. **Access policy**: administrator
         * @summary Remove a tag
         * @param {number} id Tag identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List tags. **Access policy**: authenticated
         * @summary List tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerTag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Create a new tag. **Access policy**: administrator
         * @summary Create a new tag
         * @param {TagsTagCreatePayload} body Tag details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagCreate(body: TagsTagCreatePayload, options?: any): AxiosPromise<PortainerTag> {
            return localVarFp.tagCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a tag. **Access policy**: administrator
         * @summary Remove a tag
         * @param {number} id Tag identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.tagDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List tags. **Access policy**: authenticated
         * @summary List tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagList(options?: any): AxiosPromise<Array<PortainerTag>> {
            return localVarFp.tagList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Create a new tag. **Access policy**: administrator
     * @summary Create a new tag
     * @param {TagsTagCreatePayload} body Tag details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagCreate(body: TagsTagCreatePayload, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a tag. **Access policy**: administrator
     * @summary Remove a tag
     * @param {number} id Tag identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagDelete(id: number, options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List tags. **Access policy**: authenticated
     * @summary List tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagList(options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagList(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamMembershipsApi - axios parameter creator
 * @export
 */
export const TeamMembershipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new team memberships. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Create a new team membership
         * @param {TeammembershipsTeamMembershipCreatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipCreate: async (body: TeammembershipsTeamMembershipCreatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('teamMembershipCreate', 'body', body)
            const localVarPath = `/team_memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a team membership. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Remove a team membership
         * @param {number} id TeamMembership identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamMembershipDelete', 'id', id)
            const localVarPath = `/team_memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: administrator
         * @summary List team memberships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/team_memberships`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a team membership. Access is only available to administrators or leaders of the associated team. **Access policy**: administrator or leaders of the associated team
         * @summary Update a team membership
         * @param {number} id Team membership identifier
         * @param {TeammembershipsTeamMembershipUpdatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipUpdate: async (id: number, body: TeammembershipsTeamMembershipUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamMembershipUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('teamMembershipUpdate', 'body', body)
            const localVarPath = `/team_memberships/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: restricted
         * @summary List team memberships
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberships: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamMemberships', 'id', id)
            const localVarPath = `/teams/{id}/memberships`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamMembershipsApi - functional programming interface
 * @export
 */
export const TeamMembershipsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamMembershipsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new team memberships. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Create a new team membership
         * @param {TeammembershipsTeamMembershipCreatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamMembershipCreate(body: TeammembershipsTeamMembershipCreatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerTeamMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamMembershipCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a team membership. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Remove a team membership
         * @param {number} id TeamMembership identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamMembershipDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamMembershipDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: administrator
         * @summary List team memberships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamMembershipList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerTeamMembership>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamMembershipList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a team membership. Access is only available to administrators or leaders of the associated team. **Access policy**: administrator or leaders of the associated team
         * @summary Update a team membership
         * @param {number} id Team membership identifier
         * @param {TeammembershipsTeamMembershipUpdatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamMembershipUpdate(id: number, body: TeammembershipsTeamMembershipUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerTeamMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamMembershipUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: restricted
         * @summary List team memberships
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamMemberships(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerTeamMembership>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamMemberships(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamMembershipsApi - factory interface
 * @export
 */
export const TeamMembershipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamMembershipsApiFp(configuration)
    return {
        /**
         * Create a new team memberships. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Create a new team membership
         * @param {TeammembershipsTeamMembershipCreatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipCreate(body: TeammembershipsTeamMembershipCreatePayload, options?: any): AxiosPromise<PortainerTeamMembership> {
            return localVarFp.teamMembershipCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a team membership. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
         * @summary Remove a team membership
         * @param {number} id TeamMembership identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.teamMembershipDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: administrator
         * @summary List team memberships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipList(options?: any): AxiosPromise<Array<PortainerTeamMembership>> {
            return localVarFp.teamMembershipList(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a team membership. Access is only available to administrators or leaders of the associated team. **Access policy**: administrator or leaders of the associated team
         * @summary Update a team membership
         * @param {number} id Team membership identifier
         * @param {TeammembershipsTeamMembershipUpdatePayload} body Team membership details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMembershipUpdate(id: number, body: TeammembershipsTeamMembershipUpdatePayload, options?: any): AxiosPromise<PortainerTeamMembership> {
            return localVarFp.teamMembershipUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * List team memberships. Access is only available to administrators and team leaders. **Access policy**: restricted
         * @summary List team memberships
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamMemberships(id: number, options?: any): AxiosPromise<Array<PortainerTeamMembership>> {
            return localVarFp.teamMemberships(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamMembershipsApi - object-oriented interface
 * @export
 * @class TeamMembershipsApi
 * @extends {BaseAPI}
 */
export class TeamMembershipsApi extends BaseAPI {
    /**
     * Create a new team memberships. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
     * @summary Create a new team membership
     * @param {TeammembershipsTeamMembershipCreatePayload} body Team membership details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    public teamMembershipCreate(body: TeammembershipsTeamMembershipCreatePayload, options?: AxiosRequestConfig) {
        return TeamMembershipsApiFp(this.configuration).teamMembershipCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a team membership. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
     * @summary Remove a team membership
     * @param {number} id TeamMembership identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    public teamMembershipDelete(id: number, options?: AxiosRequestConfig) {
        return TeamMembershipsApiFp(this.configuration).teamMembershipDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List team memberships. Access is only available to administrators and team leaders. **Access policy**: administrator
     * @summary List team memberships
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    public teamMembershipList(options?: AxiosRequestConfig) {
        return TeamMembershipsApiFp(this.configuration).teamMembershipList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a team membership. Access is only available to administrators or leaders of the associated team. **Access policy**: administrator or leaders of the associated team
     * @summary Update a team membership
     * @param {number} id Team membership identifier
     * @param {TeammembershipsTeamMembershipUpdatePayload} body Team membership details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    public teamMembershipUpdate(id: number, body: TeammembershipsTeamMembershipUpdatePayload, options?: AxiosRequestConfig) {
        return TeamMembershipsApiFp(this.configuration).teamMembershipUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List team memberships. Access is only available to administrators and team leaders. **Access policy**: restricted
     * @summary List team memberships
     * @param {number} id Team Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamMembershipsApi
     */
    public teamMemberships(id: number, options?: AxiosRequestConfig) {
        return TeamMembershipsApiFp(this.configuration).teamMemberships(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamsApi - axios parameter creator
 * @export
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new team. **Access policy**: administrator
         * @summary Create a new team
         * @param {TeamsTeamCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamCreate: async (body: TeamsTeamCreatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('teamCreate', 'body', body)
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a team. **Access policy**: administrator
         * @summary Remove a team
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamDelete', 'id', id)
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a team. Access is only available for administrator and leaders of that team. **Access policy**: administrator
         * @summary Inspect a team
         * @param {number} id Team identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamInspect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamInspect', 'id', id)
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List teams. For non-administrator users, will only list the teams they are member of. **Access policy**: restricted
         * @summary List teams
         * @param {boolean} [onlyLedTeams] Only list teams that the user is leader of
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamList: async (onlyLedTeams?: boolean, environmentId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (onlyLedTeams !== undefined) {
                localVarQueryParameter['onlyLedTeams'] = onlyLedTeams;
            }

            if (environmentId !== undefined) {
                localVarQueryParameter['environmentId'] = environmentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a team. **Access policy**: administrator
         * @summary Update a team
         * @param {number} id Team identifier
         * @param {TeamsTeamUpdatePayload} body Team details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamUpdate: async (id: number, body: TeamsTeamUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('teamUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('teamUpdate', 'body', body)
            const localVarPath = `/teams/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new team. **Access policy**: administrator
         * @summary Create a new team
         * @param {TeamsTeamCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamCreate(body: TeamsTeamCreatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerTeam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a team. **Access policy**: administrator
         * @summary Remove a team
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve details about a team. Access is only available for administrator and leaders of that team. **Access policy**: administrator
         * @summary Inspect a team
         * @param {number} id Team identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamInspect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerTeam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamInspect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List teams. For non-administrator users, will only list the teams they are member of. **Access policy**: restricted
         * @summary List teams
         * @param {boolean} [onlyLedTeams] Only list teams that the user is leader of
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamList(onlyLedTeams?: boolean, environmentId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerTeam>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamList(onlyLedTeams, environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a team. **Access policy**: administrator
         * @summary Update a team
         * @param {number} id Team identifier
         * @param {TeamsTeamUpdatePayload} body Team details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamUpdate(id: number, body: TeamsTeamUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerTeam>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamsApiFp(configuration)
    return {
        /**
         * Create a new team. **Access policy**: administrator
         * @summary Create a new team
         * @param {TeamsTeamCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamCreate(body: TeamsTeamCreatePayload, options?: any): AxiosPromise<PortainerTeam> {
            return localVarFp.teamCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a team. **Access policy**: administrator
         * @summary Remove a team
         * @param {number} id Team Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.teamDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details about a team. Access is only available for administrator and leaders of that team. **Access policy**: administrator
         * @summary Inspect a team
         * @param {number} id Team identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamInspect(id: number, options?: any): AxiosPromise<PortainerTeam> {
            return localVarFp.teamInspect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List teams. For non-administrator users, will only list the teams they are member of. **Access policy**: restricted
         * @summary List teams
         * @param {boolean} [onlyLedTeams] Only list teams that the user is leader of
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamList(onlyLedTeams?: boolean, environmentId?: number, options?: any): AxiosPromise<Array<PortainerTeam>> {
            return localVarFp.teamList(onlyLedTeams, environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a team. **Access policy**: administrator
         * @summary Update a team
         * @param {number} id Team identifier
         * @param {TeamsTeamUpdatePayload} body Team details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamUpdate(id: number, body: TeamsTeamUpdatePayload, options?: any): AxiosPromise<PortainerTeam> {
            return localVarFp.teamUpdate(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     * Create a new team. **Access policy**: administrator
     * @summary Create a new team
     * @param {TeamsTeamCreatePayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamCreate(body: TeamsTeamCreatePayload, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a team. **Access policy**: administrator
     * @summary Remove a team
     * @param {number} id Team Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamDelete(id: number, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details about a team. Access is only available for administrator and leaders of that team. **Access policy**: administrator
     * @summary Inspect a team
     * @param {number} id Team identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamInspect(id: number, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamInspect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List teams. For non-administrator users, will only list the teams they are member of. **Access policy**: restricted
     * @summary List teams
     * @param {boolean} [onlyLedTeams] Only list teams that the user is leader of
     * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized teams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamList(onlyLedTeams?: boolean, environmentId?: number, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamList(onlyLedTeams, environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a team. **Access policy**: administrator
     * @summary Update a team
     * @param {number} id Team identifier
     * @param {TeamsTeamUpdatePayload} body Team details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamUpdate(id: number, body: TeamsTeamUpdatePayload, options?: AxiosRequestConfig) {
        return TeamsApiFp(this.configuration).teamUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplatesApi - axios parameter creator
 * @export
 */
export const TemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a template\'s file **Access policy**: authenticated
         * @summary Get a template\'s file
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateFile: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('templateFile', 'id', id)
            const localVarPath = `/templates/{id}/file`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a template\'s file **Access policy**: authenticated
         * @summary Get a template\'s file
         * @param {TemplatesFilePayload} body File details
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        templateFileOld: async (body: TemplatesFilePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('templateFileOld', 'body', body)
            const localVarPath = `/templates/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available templates. **Access policy**: authenticated
         * @summary List available templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatesApi - functional programming interface
 * @export
 */
export const TemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a template\'s file **Access policy**: authenticated
         * @summary Get a template\'s file
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateFile(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a template\'s file **Access policy**: authenticated
         * @summary Get a template\'s file
         * @param {TemplatesFilePayload} body File details
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async templateFileOld(body: TemplatesFilePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateFileOld(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List available templates. **Access policy**: authenticated
         * @summary List available templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplatesApi - factory interface
 * @export
 */
export const TemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatesApiFp(configuration)
    return {
        /**
         * Get a template\'s file **Access policy**: authenticated
         * @summary Get a template\'s file
         * @param {number} id Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateFile(id: number, options?: any): AxiosPromise<TemplatesFileResponse> {
            return localVarFp.templateFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a template\'s file **Access policy**: authenticated
         * @summary Get a template\'s file
         * @param {TemplatesFilePayload} body File details
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        templateFileOld(body: TemplatesFilePayload, options?: any): AxiosPromise<TemplatesFileResponse> {
            return localVarFp.templateFileOld(body, options).then((request) => request(axios, basePath));
        },
        /**
         * List available templates. **Access policy**: authenticated
         * @summary List available templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateList(options?: any): AxiosPromise<TemplatesListResponse> {
            return localVarFp.templateList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatesApi - object-oriented interface
 * @export
 * @class TemplatesApi
 * @extends {BaseAPI}
 */
export class TemplatesApi extends BaseAPI {
    /**
     * Get a template\'s file **Access policy**: authenticated
     * @summary Get a template\'s file
     * @param {number} id Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templateFile(id: number, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templateFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a template\'s file **Access policy**: authenticated
     * @summary Get a template\'s file
     * @param {TemplatesFilePayload} body File details
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templateFileOld(body: TemplatesFilePayload, options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templateFileOld(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List available templates. **Access policy**: authenticated
     * @summary List available templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatesApi
     */
    public templateList(options?: AxiosRequestConfig) {
        return TemplatesApiFp(this.configuration).templateList(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UploadApi - axios parameter creator
 * @export
 */
export const UploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload TLS files
         * @param {'ca' | 'cert' | 'key'} certificate TLS file type. Valid values are \&#39;ca\&#39;, \&#39;cert\&#39; or \&#39;key\&#39;.
         * @param {string} folder Folder where the TLS file will be stored. Will be created if not existing
         * @param {File} file The file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTLS: async (certificate: 'ca' | 'cert' | 'key', folder: string, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'certificate' is not null or undefined
            assertParamExists('uploadTLS', 'certificate', certificate)
            // verify required parameter 'folder' is not null or undefined
            assertParamExists('uploadTLS', 'folder', folder)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadTLS', 'file', file)
            const localVarPath = `/upload/tls/{certificate}`
                .replace(`{${"certificate"}}`, encodeURIComponent(String(certificate)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (folder !== undefined) { 
                localVarFormParams.append('folder', folder as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadApi - functional programming interface
 * @export
 */
export const UploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload TLS files
         * @param {'ca' | 'cert' | 'key'} certificate TLS file type. Valid values are \&#39;ca\&#39;, \&#39;cert\&#39; or \&#39;key\&#39;.
         * @param {string} folder Folder where the TLS file will be stored. Will be created if not existing
         * @param {File} file The file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadTLS(certificate: 'ca' | 'cert' | 'key', folder: string, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadTLS(certificate, folder, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UploadApi - factory interface
 * @export
 */
export const UploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadApiFp(configuration)
    return {
        /**
         * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
         * @summary Upload TLS files
         * @param {'ca' | 'cert' | 'key'} certificate TLS file type. Valid values are \&#39;ca\&#39;, \&#39;cert\&#39; or \&#39;key\&#39;.
         * @param {string} folder Folder where the TLS file will be stored. Will be created if not existing
         * @param {File} file The file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTLS(certificate: 'ca' | 'cert' | 'key', folder: string, file: File, options?: any): AxiosPromise<void> {
            return localVarFp.uploadTLS(certificate, folder, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadApi - object-oriented interface
 * @export
 * @class UploadApi
 * @extends {BaseAPI}
 */
export class UploadApi extends BaseAPI {
    /**
     * Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
     * @summary Upload TLS files
     * @param {'ca' | 'cert' | 'key'} certificate TLS file type. Valid values are \&#39;ca\&#39;, \&#39;cert\&#39; or \&#39;key\&#39;.
     * @param {string} folder Folder where the TLS file will be stored. Will be created if not existing
     * @param {File} file The file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public uploadTLS(certificate: 'ca' | 'cert' | 'key', folder: string, file: File, options?: AxiosRequestConfig) {
        return UploadApiFp(this.configuration).uploadTLS(certificate, folder, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve details about the current  user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect the current user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserInspect: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if an administrator account exists in the database. **Access policy**: public
         * @summary Check administrator account existence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminCheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/admin/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initialize the \'admin\' user account. **Access policy**: public
         * @summary Initialize administrator account
         * @param {UsersAdminInitPayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminInit: async (body: UsersAdminInitPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userAdminInit', 'body', body)
            const localVarPath = `/users/admin/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Portainer user. Only administrators can create users. **Access policy**: restricted
         * @summary Create a new user
         * @param {UsersUserCreatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate: async (body: UsersUserCreatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userCreate', 'body', body)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a user. **Access policy**: administrator
         * @summary Remove a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userDelete', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an API key for a user. Only the calling user can generate a token for themselves. Password is required only for internal authentication. **Access policy**: restricted
         * @summary Generate an API key for a user
         * @param {number} id User identifier
         * @param {UsersUserAccessTokenCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGenerateAPIKey: async (id: number, body: UsersUserAccessTokenCreatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userGenerateAPIKey', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userGenerateAPIKey', 'body', body)
            const localVarPath = `/users/{id}/tokens`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all API keys for a user. Only the calling user or admin can retrieve api-keys. **Access policy**: authenticated
         * @summary Get all API keys for a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetAPIKeys: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userGetAPIKeys', 'id', id)
            const localVarPath = `/users/{id}/tokens`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details about a user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInspect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userInspect', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Portainer users. Non-administrator users will only be able to list other non-administrator user accounts. User passwords are filtered out, and should never be accessible. **Access policy**: restricted
         * @summary List users
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userList: async (environmentId?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (environmentId !== undefined) {
                localVarQueryParameter['environmentId'] = environmentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inspect a user memberships. **Access policy**: restricted
         * @summary Inspect a user memberships
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMembershipsInspect: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userMembershipsInspect', 'id', id)
            const localVarPath = `/users/{id}/memberships`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an api-key associated to a user.. Only the calling user or admin can remove api-key. **Access policy**: authenticated
         * @summary Remove an api-key associated to a user
         * @param {number} id User identifier
         * @param {number} keyID Api Key identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRemoveAPIKey: async (id: number, keyID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userRemoveAPIKey', 'id', id)
            // verify required parameter 'keyID' is not null or undefined
            assertParamExists('userRemoveAPIKey', 'keyID', keyID)
            const localVarPath = `/users/{id}/tokens/{keyID}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"keyID"}}`, encodeURIComponent(String(keyID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user details. A regular user account can only update his details. A regular user account cannot change their username or role. **Access policy**: authenticated
         * @summary Update a user
         * @param {number} id User identifier
         * @param {UsersUserUpdatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdate: async (id: number, body: UsersUserUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userUpdate', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userUpdate', 'body', body)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update password for the specified user. **Access policy**: authenticated
         * @summary Update password for a user
         * @param {number} id identifier
         * @param {UsersUserUpdatePasswordPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdatePassword: async (id: number, body: UsersUserUpdatePasswordPayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userUpdatePassword', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userUpdatePassword', 'body', body)
            const localVarPath = `/users/{id}/passwd`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve details about the current  user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect the current user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserInspect(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserInspect(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check if an administrator account exists in the database. **Access policy**: public
         * @summary Check administrator account existence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAdminCheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAdminCheck(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initialize the \'admin\' user account. **Access policy**: public
         * @summary Initialize administrator account
         * @param {UsersAdminInitPayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAdminInit(body: UsersAdminInitPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAdminInit(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new Portainer user. Only administrators can create users. **Access policy**: restricted
         * @summary Create a new user
         * @param {UsersUserCreatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreate(body: UsersUserCreatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreate(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove a user. **Access policy**: administrator
         * @summary Remove a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generates an API key for a user. Only the calling user can generate a token for themselves. Password is required only for internal authentication. **Access policy**: restricted
         * @summary Generate an API key for a user
         * @param {number} id User identifier
         * @param {UsersUserAccessTokenCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGenerateAPIKey(id: number, body: UsersUserAccessTokenCreatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGenerateAPIKey(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets all API keys for a user. Only the calling user or admin can retrieve api-keys. **Access policy**: authenticated
         * @summary Get all API keys for a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetAPIKeys(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerAPIKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetAPIKeys(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve details about a user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInspect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInspect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List Portainer users. Non-administrator users will only be able to list other non-administrator user accounts. User passwords are filtered out, and should never be accessible. **Access policy**: restricted
         * @summary List users
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userList(environmentId?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userList(environmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Inspect a user memberships. **Access policy**: restricted
         * @summary Inspect a user memberships
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userMembershipsInspect(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerTeamMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userMembershipsInspect(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove an api-key associated to a user.. Only the calling user or admin can remove api-key. **Access policy**: authenticated
         * @summary Remove an api-key associated to a user
         * @param {number} id User identifier
         * @param {number} keyID Api Key identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRemoveAPIKey(id: number, keyID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRemoveAPIKey(id, keyID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user details. A regular user account can only update his details. A regular user account cannot change their username or role. **Access policy**: authenticated
         * @summary Update a user
         * @param {number} id User identifier
         * @param {UsersUserUpdatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUpdate(id: number, body: UsersUserUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUpdate(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update password for the specified user. **Access policy**: authenticated
         * @summary Update password for a user
         * @param {number} id identifier
         * @param {UsersUserUpdatePasswordPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUpdatePassword(id: number, body: UsersUserUpdatePasswordPayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUpdatePassword(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Retrieve details about the current  user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect the current user user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserInspect(options?: any): AxiosPromise<PortainerUser> {
            return localVarFp.currentUserInspect(options).then((request) => request(axios, basePath));
        },
        /**
         * Check if an administrator account exists in the database. **Access policy**: public
         * @summary Check administrator account existence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminCheck(options?: any): AxiosPromise<void> {
            return localVarFp.userAdminCheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Initialize the \'admin\' user account. **Access policy**: public
         * @summary Initialize administrator account
         * @param {UsersAdminInitPayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAdminInit(body: UsersAdminInitPayload, options?: any): AxiosPromise<PortainerUser> {
            return localVarFp.userAdminInit(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Portainer user. Only administrators can create users. **Access policy**: restricted
         * @summary Create a new user
         * @param {UsersUserCreatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreate(body: UsersUserCreatePayload, options?: any): AxiosPromise<PortainerUser> {
            return localVarFp.userCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a user. **Access policy**: administrator
         * @summary Remove a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an API key for a user. Only the calling user can generate a token for themselves. Password is required only for internal authentication. **Access policy**: restricted
         * @summary Generate an API key for a user
         * @param {number} id User identifier
         * @param {UsersUserAccessTokenCreatePayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGenerateAPIKey(id: number, body: UsersUserAccessTokenCreatePayload, options?: any): AxiosPromise<UsersAccessTokenResponse> {
            return localVarFp.userGenerateAPIKey(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all API keys for a user. Only the calling user or admin can retrieve api-keys. **Access policy**: authenticated
         * @summary Get all API keys for a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetAPIKeys(id: number, options?: any): AxiosPromise<Array<PortainerAPIKey>> {
            return localVarFp.userGetAPIKeys(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details about a user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
         * @summary Inspect a user
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInspect(id: number, options?: any): AxiosPromise<PortainerUser> {
            return localVarFp.userInspect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List Portainer users. Non-administrator users will only be able to list other non-administrator user accounts. User passwords are filtered out, and should never be accessible. **Access policy**: restricted
         * @summary List users
         * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userList(environmentId?: number, options?: any): AxiosPromise<Array<PortainerUser>> {
            return localVarFp.userList(environmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Inspect a user memberships. **Access policy**: restricted
         * @summary Inspect a user memberships
         * @param {number} id User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userMembershipsInspect(id: number, options?: any): AxiosPromise<PortainerTeamMembership> {
            return localVarFp.userMembershipsInspect(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an api-key associated to a user.. Only the calling user or admin can remove api-key. **Access policy**: authenticated
         * @summary Remove an api-key associated to a user
         * @param {number} id User identifier
         * @param {number} keyID Api Key identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRemoveAPIKey(id: number, keyID: number, options?: any): AxiosPromise<void> {
            return localVarFp.userRemoveAPIKey(id, keyID, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user details. A regular user account can only update his details. A regular user account cannot change their username or role. **Access policy**: authenticated
         * @summary Update a user
         * @param {number} id User identifier
         * @param {UsersUserUpdatePayload} body User details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdate(id: number, body: UsersUserUpdatePayload, options?: any): AxiosPromise<PortainerUser> {
            return localVarFp.userUpdate(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Update password for the specified user. **Access policy**: authenticated
         * @summary Update password for a user
         * @param {number} id identifier
         * @param {UsersUserUpdatePasswordPayload} body details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdatePassword(id: number, body: UsersUserUpdatePasswordPayload, options?: any): AxiosPromise<void> {
            return localVarFp.userUpdatePassword(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Retrieve details about the current  user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
     * @summary Inspect the current user user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public currentUserInspect(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).currentUserInspect(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if an administrator account exists in the database. **Access policy**: public
     * @summary Check administrator account existence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userAdminCheck(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userAdminCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initialize the \'admin\' user account. **Access policy**: public
     * @summary Initialize administrator account
     * @param {UsersAdminInitPayload} body User details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userAdminInit(body: UsersAdminInitPayload, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userAdminInit(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Portainer user. Only administrators can create users. **Access policy**: restricted
     * @summary Create a new user
     * @param {UsersUserCreatePayload} body User details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userCreate(body: UsersUserCreatePayload, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userCreate(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove a user. **Access policy**: administrator
     * @summary Remove a user
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userDelete(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an API key for a user. Only the calling user can generate a token for themselves. Password is required only for internal authentication. **Access policy**: restricted
     * @summary Generate an API key for a user
     * @param {number} id User identifier
     * @param {UsersUserAccessTokenCreatePayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userGenerateAPIKey(id: number, body: UsersUserAccessTokenCreatePayload, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userGenerateAPIKey(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all API keys for a user. Only the calling user or admin can retrieve api-keys. **Access policy**: authenticated
     * @summary Get all API keys for a user
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userGetAPIKeys(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userGetAPIKeys(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details about a user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
     * @summary Inspect a user
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userInspect(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userInspect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Portainer users. Non-administrator users will only be able to list other non-administrator user accounts. User passwords are filtered out, and should never be accessible. **Access policy**: restricted
     * @summary List users
     * @param {number} [environmentId] Identifier of the environment(endpoint) that will be used to filter the authorized users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userList(environmentId?: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userList(environmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inspect a user memberships. **Access policy**: restricted
     * @summary Inspect a user memberships
     * @param {number} id User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userMembershipsInspect(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userMembershipsInspect(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove an api-key associated to a user.. Only the calling user or admin can remove api-key. **Access policy**: authenticated
     * @summary Remove an api-key associated to a user
     * @param {number} id User identifier
     * @param {number} keyID Api Key identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userRemoveAPIKey(id: number, keyID: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userRemoveAPIKey(id, keyID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user details. A regular user account can only update his details. A regular user account cannot change their username or role. **Access policy**: authenticated
     * @summary Update a user
     * @param {number} id User identifier
     * @param {UsersUserUpdatePayload} body User details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userUpdate(id: number, body: UsersUserUpdatePayload, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userUpdate(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update password for the specified user. **Access policy**: authenticated
     * @summary Update password for a user
     * @param {number} id identifier
     * @param {UsersUserUpdatePasswordPayload} body details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userUpdatePassword(id: number, body: UsersUserUpdatePasswordPayload, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).userUpdatePassword(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * **Access policy**: authenticated
         * @summary List webhooks
         * @param {string} [filters] Filters (json-string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet: async (filters?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a webhook
         * @param {number} id Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdDelete: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhooksIdDelete', 'id', id)
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Acts on a passed in token UUID to restart the docker service **Access policy**: public
         * @summary Execute a webhook
         * @param {string} id Webhook token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPost: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhooksIdPost', 'id', id)
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Update a webhook
         * @param {number} id Webhook id
         * @param {WebhooksWebhookUpdatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPut: async (id: number, body: WebhooksWebhookUpdatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webhooksIdPut', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('webhooksIdPut', 'body', body)
            const localVarPath = `/webhooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * **Access policy**: authenticated
         * @summary Create a webhook
         * @param {WebhooksWebhookCreatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost: async (body: WebhooksWebhookCreatePayload, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('webhooksPost', 'body', body)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * **Access policy**: authenticated
         * @summary List webhooks
         * @param {string} [filters] Filters (json-string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksGet(filters?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PortainerWebhook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksGet(filters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a webhook
         * @param {number} id Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksIdDelete(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Acts on a passed in token UUID to restart the docker service **Access policy**: public
         * @summary Execute a webhook
         * @param {string} id Webhook token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksIdPost(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksIdPost(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: authenticated
         * @summary Update a webhook
         * @param {number} id Webhook id
         * @param {WebhooksWebhookUpdatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksIdPut(id: number, body: WebhooksWebhookUpdatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerWebhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksIdPut(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * **Access policy**: authenticated
         * @summary Create a webhook
         * @param {WebhooksWebhookCreatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksPost(body: WebhooksWebhookCreatePayload, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortainerWebhook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * **Access policy**: authenticated
         * @summary List webhooks
         * @param {string} [filters] Filters (json-string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet(filters?: string, options?: any): AxiosPromise<Array<PortainerWebhook>> {
            return localVarFp.webhooksGet(filters, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: authenticated
         * @summary Delete a webhook
         * @param {number} id Webhook id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.webhooksIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Acts on a passed in token UUID to restart the docker service **Access policy**: public
         * @summary Execute a webhook
         * @param {string} id Webhook token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPost(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.webhooksIdPost(id, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: authenticated
         * @summary Update a webhook
         * @param {number} id Webhook id
         * @param {WebhooksWebhookUpdatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksIdPut(id: number, body: WebhooksWebhookUpdatePayload, options?: any): AxiosPromise<PortainerWebhook> {
            return localVarFp.webhooksIdPut(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * **Access policy**: authenticated
         * @summary Create a webhook
         * @param {WebhooksWebhookCreatePayload} body Webhook data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost(body: WebhooksWebhookCreatePayload, options?: any): AxiosPromise<PortainerWebhook> {
            return localVarFp.webhooksPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * **Access policy**: authenticated
     * @summary List webhooks
     * @param {string} [filters] Filters (json-string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksGet(filters?: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksGet(filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: authenticated
     * @summary Delete a webhook
     * @param {number} id Webhook id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksIdDelete(id: number, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Acts on a passed in token UUID to restart the docker service **Access policy**: public
     * @summary Execute a webhook
     * @param {string} id Webhook token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksIdPost(id: string, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksIdPost(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: authenticated
     * @summary Update a webhook
     * @param {number} id Webhook id
     * @param {WebhooksWebhookUpdatePayload} body Webhook data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksIdPut(id: number, body: WebhooksWebhookUpdatePayload, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksIdPut(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * **Access policy**: authenticated
     * @summary Create a webhook
     * @param {WebhooksWebhookCreatePayload} body Webhook data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksPost(body: WebhooksWebhookCreatePayload, options?: AxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebsocketApi - axios parameter creator
 * @export
 */
export const WebsocketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an AttachStart operation HTTP request will be created and hijacked. **Access policy**: authenticated
         * @summary Attach a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketAttachGet: async (endpointId: number, token: string, nodeName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('websocketAttachGet', 'endpointId', endpointId)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('websocketAttachGet', 'token', token)
            const localVarPath = `/websocket/attach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            if (nodeName !== undefined) {
                localVarQueryParameter['nodeName'] = nodeName;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an ExecStart operation HTTP request will be created and hijacked.
         * @summary Execute a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketExecGet: async (endpointId: number, token: string, nodeName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('websocketExecGet', 'endpointId', endpointId)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('websocketExecGet', 'token', token)
            const localVarPath = `/websocket/exec`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            if (nodeName !== undefined) {
                localVarQueryParameter['nodeName'] = nodeName;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection. **Access policy**: authenticated
         * @summary Execute a websocket on kubectl shell pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketKubernetesShellGet: async (endpointId: number, token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('websocketKubernetesShellGet', 'endpointId', endpointId)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('websocketKubernetesShellGet', 'token', token)
            const localVarPath = `/websocket/kubernetes-shell`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The request will be upgraded to the websocket protocol. **Access policy**: authenticated
         * @summary Execute a websocket on pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} namespace namespace where the container is located
         * @param {string} podName name of the pod containing the container
         * @param {string} containerName name of the container
         * @param {string} command command to execute in the container
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketPodGet: async (endpointId: number, namespace: string, podName: string, containerName: string, command: string, token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('websocketPodGet', 'endpointId', endpointId)
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('websocketPodGet', 'namespace', namespace)
            // verify required parameter 'podName' is not null or undefined
            assertParamExists('websocketPodGet', 'podName', podName)
            // verify required parameter 'containerName' is not null or undefined
            assertParamExists('websocketPodGet', 'containerName', containerName)
            // verify required parameter 'command' is not null or undefined
            assertParamExists('websocketPodGet', 'command', command)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('websocketPodGet', 'token', token)
            const localVarPath = `/websocket/pod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            // authentication jwt required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (endpointId !== undefined) {
                localVarQueryParameter['endpointId'] = endpointId;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (podName !== undefined) {
                localVarQueryParameter['podName'] = podName;
            }

            if (containerName !== undefined) {
                localVarQueryParameter['containerName'] = containerName;
            }

            if (command !== undefined) {
                localVarQueryParameter['command'] = command;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebsocketApi - functional programming interface
 * @export
 */
export const WebsocketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebsocketApiAxiosParamCreator(configuration)
    return {
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an AttachStart operation HTTP request will be created and hijacked. **Access policy**: authenticated
         * @summary Attach a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websocketAttachGet(endpointId: number, token: string, nodeName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websocketAttachGet(endpointId, token, nodeName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an ExecStart operation HTTP request will be created and hijacked.
         * @summary Execute a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websocketExecGet(endpointId: number, token: string, nodeName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websocketExecGet(endpointId, token, nodeName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection. **Access policy**: authenticated
         * @summary Execute a websocket on kubectl shell pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websocketKubernetesShellGet(endpointId: number, token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websocketKubernetesShellGet(endpointId, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The request will be upgraded to the websocket protocol. **Access policy**: authenticated
         * @summary Execute a websocket on pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} namespace namespace where the container is located
         * @param {string} podName name of the pod containing the container
         * @param {string} containerName name of the container
         * @param {string} command command to execute in the container
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websocketPodGet(endpointId: number, namespace: string, podName: string, containerName: string, command: string, token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websocketPodGet(endpointId, namespace, podName, containerName, command, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebsocketApi - factory interface
 * @export
 */
export const WebsocketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebsocketApiFp(configuration)
    return {
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an AttachStart operation HTTP request will be created and hijacked. **Access policy**: authenticated
         * @summary Attach a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketAttachGet(endpointId: number, token: string, nodeName?: string, options?: any): AxiosPromise<void> {
            return localVarFp.websocketAttachGet(endpointId, token, nodeName, options).then((request) => request(axios, basePath));
        },
        /**
         * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an ExecStart operation HTTP request will be created and hijacked.
         * @summary Execute a websocket
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {string} [nodeName] node name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketExecGet(endpointId: number, token: string, nodeName?: string, options?: any): AxiosPromise<void> {
            return localVarFp.websocketExecGet(endpointId, token, nodeName, options).then((request) => request(axios, basePath));
        },
        /**
         * The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection. **Access policy**: authenticated
         * @summary Execute a websocket on kubectl shell pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketKubernetesShellGet(endpointId: number, token: string, options?: any): AxiosPromise<void> {
            return localVarFp.websocketKubernetesShellGet(endpointId, token, options).then((request) => request(axios, basePath));
        },
        /**
         * The request will be upgraded to the websocket protocol. **Access policy**: authenticated
         * @summary Execute a websocket on pod
         * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
         * @param {string} namespace namespace where the container is located
         * @param {string} podName name of the pod containing the container
         * @param {string} containerName name of the container
         * @param {string} command command to execute in the container
         * @param {string} token JWT token used for authentication against this environment(endpoint)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websocketPodGet(endpointId: number, namespace: string, podName: string, containerName: string, command: string, token: string, options?: any): AxiosPromise<void> {
            return localVarFp.websocketPodGet(endpointId, namespace, podName, containerName, command, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebsocketApi - object-oriented interface
 * @export
 * @class WebsocketApi
 * @extends {BaseAPI}
 */
export class WebsocketApi extends BaseAPI {
    /**
     * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an AttachStart operation HTTP request will be created and hijacked. **Access policy**: authenticated
     * @summary Attach a websocket
     * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
     * @param {string} token JWT token used for authentication against this environment(endpoint)
     * @param {string} [nodeName] node name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocketAttachGet(endpointId: number, token: string, nodeName?: string, options?: AxiosRequestConfig) {
        return WebsocketApiFp(this.configuration).websocketAttachGet(endpointId, token, nodeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an ExecStart operation HTTP request will be created and hijacked.
     * @summary Execute a websocket
     * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
     * @param {string} token JWT token used for authentication against this environment(endpoint)
     * @param {string} [nodeName] node name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocketExecGet(endpointId: number, token: string, nodeName?: string, options?: AxiosRequestConfig) {
        return WebsocketApiFp(this.configuration).websocketExecGet(endpointId, token, nodeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection. **Access policy**: authenticated
     * @summary Execute a websocket on kubectl shell pod
     * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
     * @param {string} token JWT token used for authentication against this environment(endpoint)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocketKubernetesShellGet(endpointId: number, token: string, options?: AxiosRequestConfig) {
        return WebsocketApiFp(this.configuration).websocketKubernetesShellGet(endpointId, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The request will be upgraded to the websocket protocol. **Access policy**: authenticated
     * @summary Execute a websocket on pod
     * @param {number} endpointId environment(endpoint) ID of the environment(endpoint) where the resource is located
     * @param {string} namespace namespace where the container is located
     * @param {string} podName name of the pod containing the container
     * @param {string} containerName name of the container
     * @param {string} command command to execute in the container
     * @param {string} token JWT token used for authentication against this environment(endpoint)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsocketApi
     */
    public websocketPodGet(endpointId: number, namespace: string, podName: string, containerName: string, command: string, token: string, options?: AxiosRequestConfig) {
        return WebsocketApiFp(this.configuration).websocketPodGet(endpointId, namespace, podName, containerName, command, token, options).then((request) => request(this.axios, this.basePath));
    }
}


